var OD = Object.defineProperty;
var qb = (e) => {
  throw TypeError(e);
};
var AD = (e, t, n) => t in e ? OD(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var wt = (e, t, n) => AD(e, typeof t != "symbol" ? t + "" : t, n), Ah = (e, t, n) => t.has(e) || qb("Cannot " + n);
var _ = (e, t, n) => (Ah(e, t, "read from private field"), n ? n.call(e) : t.get(e)), ce = (e, t, n) => t.has(e) ? qb("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, n), te = (e, t, n, r) => (Ah(e, t, "write to private field"), r ? r.call(e, n) : t.set(e, n), n), Ce = (e, t, n) => (Ah(e, t, "access private method"), n);
var Ou = (e, t, n, r) => ({
  set _(a) {
    te(e, t, a, n);
  },
  get _() {
    return _(e, t, r);
  }
});
function wS(e, t) {
  for (var n = 0; n < t.length; n++) {
    const r = t[n];
    if (typeof r != "string" && !Array.isArray(r)) {
      for (const a in r)
        if (a !== "default" && !(a in e)) {
          const i = Object.getOwnPropertyDescriptor(r, a);
          i && Object.defineProperty(e, a, i.get ? i : {
            enumerable: !0,
            get: () => r[a]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }));
}
var C8 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function _d(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function O8(e) {
  if (e.__esModule) return e;
  var t = e.default;
  if (typeof t == "function") {
    var n = function r() {
      return this instanceof r ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    n.prototype = t.prototype;
  } else n = {};
  return Object.defineProperty(n, "__esModule", { value: !0 }), Object.keys(e).forEach(function(r) {
    var a = Object.getOwnPropertyDescriptor(e, r);
    Object.defineProperty(n, r, a.get ? a : {
      enumerable: !0,
      get: function() {
        return e[r];
      }
    });
  }), n;
}
var xS = { exports: {} }, Dd = {};
/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var RD = Symbol.for("react.transitional.element"), _D = Symbol.for("react.fragment");
function ES(e, t, n) {
  var r = null;
  if (n !== void 0 && (r = "" + n), t.key !== void 0 && (r = "" + t.key), "key" in t) {
    n = {};
    for (var a in t)
      a !== "key" && (n[a] = t[a]);
  } else n = t;
  return t = n.ref, {
    $$typeof: RD,
    type: e,
    key: r,
    ref: t !== void 0 ? t : null,
    props: n
  };
}
Dd.Fragment = _D;
Dd.jsx = ES;
Dd.jsxs = ES;
xS.exports = Dd;
var N = xS.exports, SS = { exports: {} }, Nd = {}, TS = { exports: {} }, CS = {};
/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(e) {
  function t(k, P) {
    var F = k.length;
    k.push(P);
    e: for (; 0 < F; ) {
      var H = F - 1 >>> 1, K = k[H];
      if (0 < a(K, P))
        k[H] = P, k[F] = K, F = H;
      else break e;
    }
  }
  function n(k) {
    return k.length === 0 ? null : k[0];
  }
  function r(k) {
    if (k.length === 0) return null;
    var P = k[0], F = k.pop();
    if (F !== P) {
      k[0] = F;
      e: for (var H = 0, K = k.length, Z = K >>> 1; H < Z; ) {
        var I = 2 * (H + 1) - 1, G = k[I], ee = I + 1, J = k[ee];
        if (0 > a(G, F))
          ee < K && 0 > a(J, G) ? (k[H] = J, k[ee] = F, H = ee) : (k[H] = G, k[I] = F, H = I);
        else if (ee < K && 0 > a(J, F))
          k[H] = J, k[ee] = F, H = ee;
        else break e;
      }
    }
    return P;
  }
  function a(k, P) {
    var F = k.sortIndex - P.sortIndex;
    return F !== 0 ? F : k.id - P.id;
  }
  if (e.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") {
    var i = performance;
    e.unstable_now = function() {
      return i.now();
    };
  } else {
    var o = Date, s = o.now();
    e.unstable_now = function() {
      return o.now() - s;
    };
  }
  var l = [], c = [], u = 1, f = null, d = 3, h = !1, g = !1, v = !1, b = !1, p = typeof setTimeout == "function" ? setTimeout : null, m = typeof clearTimeout == "function" ? clearTimeout : null, w = typeof setImmediate < "u" ? setImmediate : null;
  function x(k) {
    for (var P = n(c); P !== null; ) {
      if (P.callback === null) r(c);
      else if (P.startTime <= k)
        r(c), P.sortIndex = P.expirationTime, t(l, P);
      else break;
      P = n(c);
    }
  }
  function S(k) {
    if (v = !1, x(k), !g)
      if (n(l) !== null)
        g = !0, T || (T = !0, R());
      else {
        var P = n(c);
        P !== null && Q(S, P.startTime - k);
      }
  }
  var T = !1, E = -1, O = 5, D = -1;
  function A() {
    return b ? !0 : !(e.unstable_now() - D < O);
  }
  function U() {
    if (b = !1, T) {
      var k = e.unstable_now();
      D = k;
      var P = !0;
      try {
        e: {
          g = !1, v && (v = !1, m(E), E = -1), h = !0;
          var F = d;
          try {
            t: {
              for (x(k), f = n(l); f !== null && !(f.expirationTime > k && A()); ) {
                var H = f.callback;
                if (typeof H == "function") {
                  f.callback = null, d = f.priorityLevel;
                  var K = H(
                    f.expirationTime <= k
                  );
                  if (k = e.unstable_now(), typeof K == "function") {
                    f.callback = K, x(k), P = !0;
                    break t;
                  }
                  f === n(l) && r(l), x(k);
                } else r(l);
                f = n(l);
              }
              if (f !== null) P = !0;
              else {
                var Z = n(c);
                Z !== null && Q(
                  S,
                  Z.startTime - k
                ), P = !1;
              }
            }
            break e;
          } finally {
            f = null, d = F, h = !1;
          }
          P = void 0;
        }
      } finally {
        P ? R() : T = !1;
      }
    }
  }
  var R;
  if (typeof w == "function")
    R = function() {
      w(U);
    };
  else if (typeof MessageChannel < "u") {
    var q = new MessageChannel(), z = q.port2;
    q.port1.onmessage = U, R = function() {
      z.postMessage(null);
    };
  } else
    R = function() {
      p(U, 0);
    };
  function Q(k, P) {
    E = p(function() {
      k(e.unstable_now());
    }, P);
  }
  e.unstable_IdlePriority = 5, e.unstable_ImmediatePriority = 1, e.unstable_LowPriority = 4, e.unstable_NormalPriority = 3, e.unstable_Profiling = null, e.unstable_UserBlockingPriority = 2, e.unstable_cancelCallback = function(k) {
    k.callback = null;
  }, e.unstable_forceFrameRate = function(k) {
    0 > k || 125 < k ? console.error(
      "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
    ) : O = 0 < k ? Math.floor(1e3 / k) : 5;
  }, e.unstable_getCurrentPriorityLevel = function() {
    return d;
  }, e.unstable_next = function(k) {
    switch (d) {
      case 1:
      case 2:
      case 3:
        var P = 3;
        break;
      default:
        P = d;
    }
    var F = d;
    d = P;
    try {
      return k();
    } finally {
      d = F;
    }
  }, e.unstable_requestPaint = function() {
    b = !0;
  }, e.unstable_runWithPriority = function(k, P) {
    switch (k) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        k = 3;
    }
    var F = d;
    d = k;
    try {
      return P();
    } finally {
      d = F;
    }
  }, e.unstable_scheduleCallback = function(k, P, F) {
    var H = e.unstable_now();
    switch (typeof F == "object" && F !== null ? (F = F.delay, F = typeof F == "number" && 0 < F ? H + F : H) : F = H, k) {
      case 1:
        var K = -1;
        break;
      case 2:
        K = 250;
        break;
      case 5:
        K = 1073741823;
        break;
      case 4:
        K = 1e4;
        break;
      default:
        K = 5e3;
    }
    return K = F + K, k = {
      id: u++,
      callback: P,
      priorityLevel: k,
      startTime: F,
      expirationTime: K,
      sortIndex: -1
    }, F > H ? (k.sortIndex = F, t(c, k), n(l) === null && k === n(c) && (v ? (m(E), E = -1) : v = !0, Q(S, F - H))) : (k.sortIndex = K, t(l, k), g || h || (g = !0, T || (T = !0, R()))), k;
  }, e.unstable_shouldYield = A, e.unstable_wrapCallback = function(k) {
    var P = d;
    return function() {
      var F = d;
      d = P;
      try {
        return k.apply(this, arguments);
      } finally {
        d = F;
      }
    };
  };
})(CS);
TS.exports = CS;
var DD = TS.exports, OS = { exports: {} }, pe = {};
/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var mv = Symbol.for("react.transitional.element"), ND = Symbol.for("react.portal"), kD = Symbol.for("react.fragment"), MD = Symbol.for("react.strict_mode"), LD = Symbol.for("react.profiler"), zD = Symbol.for("react.consumer"), jD = Symbol.for("react.context"), PD = Symbol.for("react.forward_ref"), ID = Symbol.for("react.suspense"), FD = Symbol.for("react.memo"), AS = Symbol.for("react.lazy"), UD = Symbol.for("react.activity"), Bb = Symbol.iterator;
function qD(e) {
  return e === null || typeof e != "object" ? null : (e = Bb && e[Bb] || e["@@iterator"], typeof e == "function" ? e : null);
}
var RS = {
  isMounted: function() {
    return !1;
  },
  enqueueForceUpdate: function() {
  },
  enqueueReplaceState: function() {
  },
  enqueueSetState: function() {
  }
}, _S = Object.assign, DS = {};
function Vs(e, t, n) {
  this.props = e, this.context = t, this.refs = DS, this.updater = n || RS;
}
Vs.prototype.isReactComponent = {};
Vs.prototype.setState = function(e, t) {
  if (typeof e != "object" && typeof e != "function" && e != null)
    throw Error(
      "takes an object of state variables to update or a function which returns an object of state variables."
    );
  this.updater.enqueueSetState(this, e, t, "setState");
};
Vs.prototype.forceUpdate = function(e) {
  this.updater.enqueueForceUpdate(this, e, "forceUpdate");
};
function NS() {
}
NS.prototype = Vs.prototype;
function gv(e, t, n) {
  this.props = e, this.context = t, this.refs = DS, this.updater = n || RS;
}
var vv = gv.prototype = new NS();
vv.constructor = gv;
_S(vv, Vs.prototype);
vv.isPureReactComponent = !0;
var Vb = Array.isArray;
function tm() {
}
var Ke = { H: null, A: null, T: null, S: null }, kS = Object.prototype.hasOwnProperty;
function yv(e, t, n) {
  var r = n.ref;
  return {
    $$typeof: mv,
    type: e,
    key: t,
    ref: r !== void 0 ? r : null,
    props: n
  };
}
function BD(e, t) {
  return yv(e.type, t, e.props);
}
function bv(e) {
  return typeof e == "object" && e !== null && e.$$typeof === mv;
}
function VD(e) {
  var t = { "=": "=0", ":": "=2" };
  return "$" + e.replace(/[=:]/g, function(n) {
    return t[n];
  });
}
var Qb = /\/+/g;
function Rh(e, t) {
  return typeof e == "object" && e !== null && e.key != null ? VD("" + e.key) : t.toString(36);
}
function QD(e) {
  switch (e.status) {
    case "fulfilled":
      return e.value;
    case "rejected":
      throw e.reason;
    default:
      switch (typeof e.status == "string" ? e.then(tm, tm) : (e.status = "pending", e.then(
        function(t) {
          e.status === "pending" && (e.status = "fulfilled", e.value = t);
        },
        function(t) {
          e.status === "pending" && (e.status = "rejected", e.reason = t);
        }
      )), e.status) {
        case "fulfilled":
          return e.value;
        case "rejected":
          throw e.reason;
      }
  }
  throw e;
}
function To(e, t, n, r, a) {
  var i = typeof e;
  (i === "undefined" || i === "boolean") && (e = null);
  var o = !1;
  if (e === null) o = !0;
  else
    switch (i) {
      case "bigint":
      case "string":
      case "number":
        o = !0;
        break;
      case "object":
        switch (e.$$typeof) {
          case mv:
          case ND:
            o = !0;
            break;
          case AS:
            return o = e._init, To(
              o(e._payload),
              t,
              n,
              r,
              a
            );
        }
    }
  if (o)
    return a = a(e), o = r === "" ? "." + Rh(e, 0) : r, Vb(a) ? (n = "", o != null && (n = o.replace(Qb, "$&/") + "/"), To(a, t, n, "", function(c) {
      return c;
    })) : a != null && (bv(a) && (a = BD(
      a,
      n + (a.key == null || e && e.key === a.key ? "" : ("" + a.key).replace(
        Qb,
        "$&/"
      ) + "/") + o
    )), t.push(a)), 1;
  o = 0;
  var s = r === "" ? "." : r + ":";
  if (Vb(e))
    for (var l = 0; l < e.length; l++)
      r = e[l], i = s + Rh(r, l), o += To(
        r,
        t,
        n,
        i,
        a
      );
  else if (l = qD(e), typeof l == "function")
    for (e = l.call(e), l = 0; !(r = e.next()).done; )
      r = r.value, i = s + Rh(r, l++), o += To(
        r,
        t,
        n,
        i,
        a
      );
  else if (i === "object") {
    if (typeof e.then == "function")
      return To(
        QD(e),
        t,
        n,
        r,
        a
      );
    throw t = String(e), Error(
      "Objects are not valid as a React child (found: " + (t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t) + "). If you meant to render a collection of children, use an array instead."
    );
  }
  return o;
}
function Au(e, t, n) {
  if (e == null) return e;
  var r = [], a = 0;
  return To(e, r, "", "", function(i) {
    return t.call(n, i, a++);
  }), r;
}
function HD(e) {
  if (e._status === -1) {
    var t = e._result;
    t = t(), t.then(
      function(n) {
        (e._status === 0 || e._status === -1) && (e._status = 1, e._result = n);
      },
      function(n) {
        (e._status === 0 || e._status === -1) && (e._status = 2, e._result = n);
      }
    ), e._status === -1 && (e._status = 0, e._result = t);
  }
  if (e._status === 1) return e._result.default;
  throw e._result;
}
var Hb = typeof reportError == "function" ? reportError : function(e) {
  if (typeof window == "object" && typeof window.ErrorEvent == "function") {
    var t = new window.ErrorEvent("error", {
      bubbles: !0,
      cancelable: !0,
      message: typeof e == "object" && e !== null && typeof e.message == "string" ? String(e.message) : String(e),
      error: e
    });
    if (!window.dispatchEvent(t)) return;
  } else if (typeof process == "object" && typeof process.emit == "function") {
    process.emit("uncaughtException", e);
    return;
  }
  console.error(e);
}, $D = {
  map: Au,
  forEach: function(e, t, n) {
    Au(
      e,
      function() {
        t.apply(this, arguments);
      },
      n
    );
  },
  count: function(e) {
    var t = 0;
    return Au(e, function() {
      t++;
    }), t;
  },
  toArray: function(e) {
    return Au(e, function(t) {
      return t;
    }) || [];
  },
  only: function(e) {
    if (!bv(e))
      throw Error(
        "React.Children.only expected to receive a single React element child."
      );
    return e;
  }
};
pe.Activity = UD;
pe.Children = $D;
pe.Component = Vs;
pe.Fragment = kD;
pe.Profiler = LD;
pe.PureComponent = gv;
pe.StrictMode = MD;
pe.Suspense = ID;
pe.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Ke;
pe.__COMPILER_RUNTIME = {
  __proto__: null,
  c: function(e) {
    return Ke.H.useMemoCache(e);
  }
};
pe.cache = function(e) {
  return function() {
    return e.apply(null, arguments);
  };
};
pe.cacheSignal = function() {
  return null;
};
pe.cloneElement = function(e, t, n) {
  if (e == null)
    throw Error(
      "The argument must be a React element, but you passed " + e + "."
    );
  var r = _S({}, e.props), a = e.key;
  if (t != null)
    for (i in t.key !== void 0 && (a = "" + t.key), t)
      !kS.call(t, i) || i === "key" || i === "__self" || i === "__source" || i === "ref" && t.ref === void 0 || (r[i] = t[i]);
  var i = arguments.length - 2;
  if (i === 1) r.children = n;
  else if (1 < i) {
    for (var o = Array(i), s = 0; s < i; s++)
      o[s] = arguments[s + 2];
    r.children = o;
  }
  return yv(e.type, a, r);
};
pe.createContext = function(e) {
  return e = {
    $$typeof: jD,
    _currentValue: e,
    _currentValue2: e,
    _threadCount: 0,
    Provider: null,
    Consumer: null
  }, e.Provider = e, e.Consumer = {
    $$typeof: zD,
    _context: e
  }, e;
};
pe.createElement = function(e, t, n) {
  var r, a = {}, i = null;
  if (t != null)
    for (r in t.key !== void 0 && (i = "" + t.key), t)
      kS.call(t, r) && r !== "key" && r !== "__self" && r !== "__source" && (a[r] = t[r]);
  var o = arguments.length - 2;
  if (o === 1) a.children = n;
  else if (1 < o) {
    for (var s = Array(o), l = 0; l < o; l++)
      s[l] = arguments[l + 2];
    a.children = s;
  }
  if (e && e.defaultProps)
    for (r in o = e.defaultProps, o)
      a[r] === void 0 && (a[r] = o[r]);
  return yv(e, i, a);
};
pe.createRef = function() {
  return { current: null };
};
pe.forwardRef = function(e) {
  return { $$typeof: PD, render: e };
};
pe.isValidElement = bv;
pe.lazy = function(e) {
  return {
    $$typeof: AS,
    _payload: { _status: -1, _result: e },
    _init: HD
  };
};
pe.memo = function(e, t) {
  return {
    $$typeof: FD,
    type: e,
    compare: t === void 0 ? null : t
  };
};
pe.startTransition = function(e) {
  var t = Ke.T, n = {};
  Ke.T = n;
  try {
    var r = e(), a = Ke.S;
    a !== null && a(n, r), typeof r == "object" && r !== null && typeof r.then == "function" && r.then(tm, Hb);
  } catch (i) {
    Hb(i);
  } finally {
    t !== null && n.types !== null && (t.types = n.types), Ke.T = t;
  }
};
pe.unstable_useCacheRefresh = function() {
  return Ke.H.useCacheRefresh();
};
pe.use = function(e) {
  return Ke.H.use(e);
};
pe.useActionState = function(e, t, n) {
  return Ke.H.useActionState(e, t, n);
};
pe.useCallback = function(e, t) {
  return Ke.H.useCallback(e, t);
};
pe.useContext = function(e) {
  return Ke.H.useContext(e);
};
pe.useDebugValue = function() {
};
pe.useDeferredValue = function(e, t) {
  return Ke.H.useDeferredValue(e, t);
};
pe.useEffect = function(e, t) {
  return Ke.H.useEffect(e, t);
};
pe.useEffectEvent = function(e) {
  return Ke.H.useEffectEvent(e);
};
pe.useId = function() {
  return Ke.H.useId();
};
pe.useImperativeHandle = function(e, t, n) {
  return Ke.H.useImperativeHandle(e, t, n);
};
pe.useInsertionEffect = function(e, t) {
  return Ke.H.useInsertionEffect(e, t);
};
pe.useLayoutEffect = function(e, t) {
  return Ke.H.useLayoutEffect(e, t);
};
pe.useMemo = function(e, t) {
  return Ke.H.useMemo(e, t);
};
pe.useOptimistic = function(e, t) {
  return Ke.H.useOptimistic(e, t);
};
pe.useReducer = function(e, t, n) {
  return Ke.H.useReducer(e, t, n);
};
pe.useRef = function(e) {
  return Ke.H.useRef(e);
};
pe.useState = function(e) {
  return Ke.H.useState(e);
};
pe.useSyncExternalStore = function(e, t, n) {
  return Ke.H.useSyncExternalStore(
    e,
    t,
    n
  );
};
pe.useTransition = function() {
  return Ke.H.useTransition();
};
pe.version = "19.2.0";
OS.exports = pe;
var y = OS.exports;
const cn = /* @__PURE__ */ _d(y), wv = /* @__PURE__ */ wS({
  __proto__: null,
  default: cn
}, [y]);
var MS = { exports: {} }, Kt = {};
/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var GD = y;
function LS(e) {
  var t = "https://react.dev/errors/" + e;
  if (1 < arguments.length) {
    t += "?args[]=" + encodeURIComponent(arguments[1]);
    for (var n = 2; n < arguments.length; n++)
      t += "&args[]=" + encodeURIComponent(arguments[n]);
  }
  return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
function ia() {
}
var $t = {
  d: {
    f: ia,
    r: function() {
      throw Error(LS(522));
    },
    D: ia,
    C: ia,
    L: ia,
    m: ia,
    X: ia,
    S: ia,
    M: ia
  },
  p: 0,
  findDOMNode: null
}, YD = Symbol.for("react.portal");
function KD(e, t, n) {
  var r = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
  return {
    $$typeof: YD,
    key: r == null ? null : "" + r,
    children: e,
    containerInfo: t,
    implementation: n
  };
}
var Ql = GD.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
function kd(e, t) {
  if (e === "font") return "";
  if (typeof t == "string")
    return t === "use-credentials" ? t : "";
}
Kt.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = $t;
Kt.createPortal = function(e, t) {
  var n = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
  if (!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11)
    throw Error(LS(299));
  return KD(e, t, null, n);
};
Kt.flushSync = function(e) {
  var t = Ql.T, n = $t.p;
  try {
    if (Ql.T = null, $t.p = 2, e) return e();
  } finally {
    Ql.T = t, $t.p = n, $t.d.f();
  }
};
Kt.preconnect = function(e, t) {
  typeof e == "string" && (t ? (t = t.crossOrigin, t = typeof t == "string" ? t === "use-credentials" ? t : "" : void 0) : t = null, $t.d.C(e, t));
};
Kt.prefetchDNS = function(e) {
  typeof e == "string" && $t.d.D(e);
};
Kt.preinit = function(e, t) {
  if (typeof e == "string" && t && typeof t.as == "string") {
    var n = t.as, r = kd(n, t.crossOrigin), a = typeof t.integrity == "string" ? t.integrity : void 0, i = typeof t.fetchPriority == "string" ? t.fetchPriority : void 0;
    n === "style" ? $t.d.S(
      e,
      typeof t.precedence == "string" ? t.precedence : void 0,
      {
        crossOrigin: r,
        integrity: a,
        fetchPriority: i
      }
    ) : n === "script" && $t.d.X(e, {
      crossOrigin: r,
      integrity: a,
      fetchPriority: i,
      nonce: typeof t.nonce == "string" ? t.nonce : void 0
    });
  }
};
Kt.preinitModule = function(e, t) {
  if (typeof e == "string")
    if (typeof t == "object" && t !== null) {
      if (t.as == null || t.as === "script") {
        var n = kd(
          t.as,
          t.crossOrigin
        );
        $t.d.M(e, {
          crossOrigin: n,
          integrity: typeof t.integrity == "string" ? t.integrity : void 0,
          nonce: typeof t.nonce == "string" ? t.nonce : void 0
        });
      }
    } else t == null && $t.d.M(e);
};
Kt.preload = function(e, t) {
  if (typeof e == "string" && typeof t == "object" && t !== null && typeof t.as == "string") {
    var n = t.as, r = kd(n, t.crossOrigin);
    $t.d.L(e, n, {
      crossOrigin: r,
      integrity: typeof t.integrity == "string" ? t.integrity : void 0,
      nonce: typeof t.nonce == "string" ? t.nonce : void 0,
      type: typeof t.type == "string" ? t.type : void 0,
      fetchPriority: typeof t.fetchPriority == "string" ? t.fetchPriority : void 0,
      referrerPolicy: typeof t.referrerPolicy == "string" ? t.referrerPolicy : void 0,
      imageSrcSet: typeof t.imageSrcSet == "string" ? t.imageSrcSet : void 0,
      imageSizes: typeof t.imageSizes == "string" ? t.imageSizes : void 0,
      media: typeof t.media == "string" ? t.media : void 0
    });
  }
};
Kt.preloadModule = function(e, t) {
  if (typeof e == "string")
    if (t) {
      var n = kd(t.as, t.crossOrigin);
      $t.d.m(e, {
        as: typeof t.as == "string" && t.as !== "script" ? t.as : void 0,
        crossOrigin: n,
        integrity: typeof t.integrity == "string" ? t.integrity : void 0
      });
    } else $t.d.m(e);
};
Kt.requestFormReset = function(e) {
  $t.d.r(e);
};
Kt.unstable_batchedUpdates = function(e, t) {
  return e(t);
};
Kt.useFormState = function(e, t, n) {
  return Ql.H.useFormState(e, t, n);
};
Kt.useFormStatus = function() {
  return Ql.H.useHostTransitionStatus();
};
Kt.version = "19.2.0";
function zS() {
  if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(zS);
    } catch (e) {
      console.error(e);
    }
}
zS(), MS.exports = Kt;
var Gc = MS.exports;
const XD = /* @__PURE__ */ _d(Gc);
/**
 * @license React
 * react-dom-client.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var St = DD, jS = y, WD = Gc;
function V(e) {
  var t = "https://react.dev/errors/" + e;
  if (1 < arguments.length) {
    t += "?args[]=" + encodeURIComponent(arguments[1]);
    for (var n = 2; n < arguments.length; n++)
      t += "&args[]=" + encodeURIComponent(arguments[n]);
  }
  return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
function PS(e) {
  return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11);
}
function Yc(e) {
  var t = e, n = e;
  if (e.alternate) for (; t.return; ) t = t.return;
  else {
    e = t;
    do
      t = e, t.flags & 4098 && (n = t.return), e = t.return;
    while (e);
  }
  return t.tag === 3 ? n : null;
}
function IS(e) {
  if (e.tag === 13) {
    var t = e.memoizedState;
    if (t === null && (e = e.alternate, e !== null && (t = e.memoizedState)), t !== null) return t.dehydrated;
  }
  return null;
}
function FS(e) {
  if (e.tag === 31) {
    var t = e.memoizedState;
    if (t === null && (e = e.alternate, e !== null && (t = e.memoizedState)), t !== null) return t.dehydrated;
  }
  return null;
}
function $b(e) {
  if (Yc(e) !== e)
    throw Error(V(188));
}
function ZD(e) {
  var t = e.alternate;
  if (!t) {
    if (t = Yc(e), t === null) throw Error(V(188));
    return t !== e ? null : e;
  }
  for (var n = e, r = t; ; ) {
    var a = n.return;
    if (a === null) break;
    var i = a.alternate;
    if (i === null) {
      if (r = a.return, r !== null) {
        n = r;
        continue;
      }
      break;
    }
    if (a.child === i.child) {
      for (i = a.child; i; ) {
        if (i === n) return $b(a), e;
        if (i === r) return $b(a), t;
        i = i.sibling;
      }
      throw Error(V(188));
    }
    if (n.return !== r.return) n = a, r = i;
    else {
      for (var o = !1, s = a.child; s; ) {
        if (s === n) {
          o = !0, n = a, r = i;
          break;
        }
        if (s === r) {
          o = !0, r = a, n = i;
          break;
        }
        s = s.sibling;
      }
      if (!o) {
        for (s = i.child; s; ) {
          if (s === n) {
            o = !0, n = i, r = a;
            break;
          }
          if (s === r) {
            o = !0, r = i, n = a;
            break;
          }
          s = s.sibling;
        }
        if (!o) throw Error(V(189));
      }
    }
    if (n.alternate !== r) throw Error(V(190));
  }
  if (n.tag !== 3) throw Error(V(188));
  return n.stateNode.current === n ? e : t;
}
function US(e) {
  var t = e.tag;
  if (t === 5 || t === 26 || t === 27 || t === 6) return e;
  for (e = e.child; e !== null; ) {
    if (t = US(e), t !== null) return t;
    e = e.sibling;
  }
  return null;
}
var Xe = Object.assign, JD = Symbol.for("react.element"), Ru = Symbol.for("react.transitional.element"), kl = Symbol.for("react.portal"), ko = Symbol.for("react.fragment"), qS = Symbol.for("react.strict_mode"), nm = Symbol.for("react.profiler"), BS = Symbol.for("react.consumer"), Ir = Symbol.for("react.context"), xv = Symbol.for("react.forward_ref"), rm = Symbol.for("react.suspense"), am = Symbol.for("react.suspense_list"), Ev = Symbol.for("react.memo"), ha = Symbol.for("react.lazy"), im = Symbol.for("react.activity"), eN = Symbol.for("react.memo_cache_sentinel"), Gb = Symbol.iterator;
function fl(e) {
  return e === null || typeof e != "object" ? null : (e = Gb && e[Gb] || e["@@iterator"], typeof e == "function" ? e : null);
}
var tN = Symbol.for("react.client.reference");
function om(e) {
  if (e == null) return null;
  if (typeof e == "function")
    return e.$$typeof === tN ? null : e.displayName || e.name || null;
  if (typeof e == "string") return e;
  switch (e) {
    case ko:
      return "Fragment";
    case nm:
      return "Profiler";
    case qS:
      return "StrictMode";
    case rm:
      return "Suspense";
    case am:
      return "SuspenseList";
    case im:
      return "Activity";
  }
  if (typeof e == "object")
    switch (e.$$typeof) {
      case kl:
        return "Portal";
      case Ir:
        return e.displayName || "Context";
      case BS:
        return (e._context.displayName || "Context") + ".Consumer";
      case xv:
        var t = e.render;
        return e = e.displayName, e || (e = t.displayName || t.name || "", e = e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"), e;
      case Ev:
        return t = e.displayName || null, t !== null ? t : om(e.type) || "Memo";
      case ha:
        t = e._payload, e = e._init;
        try {
          return om(e(t));
        } catch {
        }
    }
  return null;
}
var Ml = Array.isArray, fe = jS.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, De = WD.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, Ui = {
  pending: !1,
  data: null,
  method: null,
  action: null
}, sm = [], Mo = -1;
function hr(e) {
  return { current: e };
}
function Dt(e) {
  0 > Mo || (e.current = sm[Mo], sm[Mo] = null, Mo--);
}
function Be(e, t) {
  Mo++, sm[Mo] = e.current, e.current = t;
}
var ir = hr(null), fc = hr(null), Ia = hr(null), zf = hr(null);
function jf(e, t) {
  switch (Be(Ia, t), Be(fc, e), Be(ir, null), t.nodeType) {
    case 9:
    case 11:
      e = (e = t.documentElement) && (e = e.namespaceURI) ? J0(e) : 0;
      break;
    default:
      if (e = t.tagName, t = t.namespaceURI)
        t = J0(t), e = lO(t, e);
      else
        switch (e) {
          case "svg":
            e = 1;
            break;
          case "math":
            e = 2;
            break;
          default:
            e = 0;
        }
  }
  Dt(ir), Be(ir, e);
}
function Ts() {
  Dt(ir), Dt(fc), Dt(Ia);
}
function lm(e) {
  e.memoizedState !== null && Be(zf, e);
  var t = ir.current, n = lO(t, e.type);
  t !== n && (Be(fc, e), Be(ir, n));
}
function Pf(e) {
  fc.current === e && (Dt(ir), Dt(fc)), zf.current === e && (Dt(zf), Ec._currentValue = Ui);
}
var _h, Yb;
function bi(e) {
  if (_h === void 0)
    try {
      throw Error();
    } catch (n) {
      var t = n.stack.trim().match(/\n( *(at )?)/);
      _h = t && t[1] || "", Yb = -1 < n.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < n.stack.indexOf("@") ? "@unknown:0:0" : "";
    }
  return `
` + _h + e + Yb;
}
var Dh = !1;
function Nh(e, t) {
  if (!e || Dh) return "";
  Dh = !0;
  var n = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    var r = {
      DetermineComponentFrameRoot: function() {
        try {
          if (t) {
            var f = function() {
              throw Error();
            };
            if (Object.defineProperty(f.prototype, "props", {
              set: function() {
                throw Error();
              }
            }), typeof Reflect == "object" && Reflect.construct) {
              try {
                Reflect.construct(f, []);
              } catch (h) {
                var d = h;
              }
              Reflect.construct(e, [], f);
            } else {
              try {
                f.call();
              } catch (h) {
                d = h;
              }
              e.call(f.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (h) {
              d = h;
            }
            (f = e()) && typeof f.catch == "function" && f.catch(function() {
            });
          }
        } catch (h) {
          if (h && d && typeof h.stack == "string")
            return [h.stack, d.stack];
        }
        return [null, null];
      }
    };
    r.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
    var a = Object.getOwnPropertyDescriptor(
      r.DetermineComponentFrameRoot,
      "name"
    );
    a && a.configurable && Object.defineProperty(
      r.DetermineComponentFrameRoot,
      "name",
      { value: "DetermineComponentFrameRoot" }
    );
    var i = r.DetermineComponentFrameRoot(), o = i[0], s = i[1];
    if (o && s) {
      var l = o.split(`
`), c = s.split(`
`);
      for (a = r = 0; r < l.length && !l[r].includes("DetermineComponentFrameRoot"); )
        r++;
      for (; a < c.length && !c[a].includes(
        "DetermineComponentFrameRoot"
      ); )
        a++;
      if (r === l.length || a === c.length)
        for (r = l.length - 1, a = c.length - 1; 1 <= r && 0 <= a && l[r] !== c[a]; )
          a--;
      for (; 1 <= r && 0 <= a; r--, a--)
        if (l[r] !== c[a]) {
          if (r !== 1 || a !== 1)
            do
              if (r--, a--, 0 > a || l[r] !== c[a]) {
                var u = `
` + l[r].replace(" at new ", " at ");
                return e.displayName && u.includes("<anonymous>") && (u = u.replace("<anonymous>", e.displayName)), u;
              }
            while (1 <= r && 0 <= a);
          break;
        }
    }
  } finally {
    Dh = !1, Error.prepareStackTrace = n;
  }
  return (n = e ? e.displayName || e.name : "") ? bi(n) : "";
}
function nN(e, t) {
  switch (e.tag) {
    case 26:
    case 27:
    case 5:
      return bi(e.type);
    case 16:
      return bi("Lazy");
    case 13:
      return e.child !== t && t !== null ? bi("Suspense Fallback") : bi("Suspense");
    case 19:
      return bi("SuspenseList");
    case 0:
    case 15:
      return Nh(e.type, !1);
    case 11:
      return Nh(e.type.render, !1);
    case 1:
      return Nh(e.type, !0);
    case 31:
      return bi("Activity");
    default:
      return "";
  }
}
function Kb(e) {
  try {
    var t = "", n = null;
    do
      t += nN(e, n), n = e, e = e.return;
    while (e);
    return t;
  } catch (r) {
    return `
Error generating stack: ` + r.message + `
` + r.stack;
  }
}
var cm = Object.prototype.hasOwnProperty, Sv = St.unstable_scheduleCallback, kh = St.unstable_cancelCallback, rN = St.unstable_shouldYield, aN = St.unstable_requestPaint, mn = St.unstable_now, iN = St.unstable_getCurrentPriorityLevel, VS = St.unstable_ImmediatePriority, QS = St.unstable_UserBlockingPriority, If = St.unstable_NormalPriority, oN = St.unstable_LowPriority, HS = St.unstable_IdlePriority, sN = St.log, lN = St.unstable_setDisableYieldValue, Kc = null, gn = null;
function ka(e) {
  if (typeof sN == "function" && lN(e), gn && typeof gn.setStrictMode == "function")
    try {
      gn.setStrictMode(Kc, e);
    } catch {
    }
}
var vn = Math.clz32 ? Math.clz32 : fN, cN = Math.log, uN = Math.LN2;
function fN(e) {
  return e >>>= 0, e === 0 ? 32 : 31 - (cN(e) / uN | 0) | 0;
}
var _u = 256, Du = 262144, Nu = 4194304;
function wi(e) {
  var t = e & 42;
  if (t !== 0) return t;
  switch (e & -e) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
      return 64;
    case 128:
      return 128;
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
      return e & 261888;
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return e & 3932160;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
      return e & 62914560;
    case 67108864:
      return 67108864;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 0;
    default:
      return e;
  }
}
function Md(e, t, n) {
  var r = e.pendingLanes;
  if (r === 0) return 0;
  var a = 0, i = e.suspendedLanes, o = e.pingedLanes;
  e = e.warmLanes;
  var s = r & 134217727;
  return s !== 0 ? (r = s & ~i, r !== 0 ? a = wi(r) : (o &= s, o !== 0 ? a = wi(o) : n || (n = s & ~e, n !== 0 && (a = wi(n))))) : (s = r & ~i, s !== 0 ? a = wi(s) : o !== 0 ? a = wi(o) : n || (n = r & ~e, n !== 0 && (a = wi(n)))), a === 0 ? 0 : t !== 0 && t !== a && !(t & i) && (i = a & -a, n = t & -t, i >= n || i === 32 && (n & 4194048) !== 0) ? t : a;
}
function Xc(e, t) {
  return (e.pendingLanes & ~(e.suspendedLanes & ~e.pingedLanes) & t) === 0;
}
function dN(e, t) {
  switch (e) {
    case 1:
    case 2:
    case 4:
    case 8:
    case 64:
      return t + 250;
    case 16:
    case 32:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return t + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
      return -1;
    case 67108864:
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function $S() {
  var e = Nu;
  return Nu <<= 1, !(Nu & 62914560) && (Nu = 4194304), e;
}
function Mh(e) {
  for (var t = [], n = 0; 31 > n; n++) t.push(e);
  return t;
}
function Wc(e, t) {
  e.pendingLanes |= t, t !== 268435456 && (e.suspendedLanes = 0, e.pingedLanes = 0, e.warmLanes = 0);
}
function hN(e, t, n, r, a, i) {
  var o = e.pendingLanes;
  e.pendingLanes = n, e.suspendedLanes = 0, e.pingedLanes = 0, e.warmLanes = 0, e.expiredLanes &= n, e.entangledLanes &= n, e.errorRecoveryDisabledLanes &= n, e.shellSuspendCounter = 0;
  var s = e.entanglements, l = e.expirationTimes, c = e.hiddenUpdates;
  for (n = o & ~n; 0 < n; ) {
    var u = 31 - vn(n), f = 1 << u;
    s[u] = 0, l[u] = -1;
    var d = c[u];
    if (d !== null)
      for (c[u] = null, u = 0; u < d.length; u++) {
        var h = d[u];
        h !== null && (h.lane &= -536870913);
      }
    n &= ~f;
  }
  r !== 0 && GS(e, r, 0), i !== 0 && a === 0 && e.tag !== 0 && (e.suspendedLanes |= i & ~(o & ~t));
}
function GS(e, t, n) {
  e.pendingLanes |= t, e.suspendedLanes &= ~t;
  var r = 31 - vn(t);
  e.entangledLanes |= t, e.entanglements[r] = e.entanglements[r] | 1073741824 | n & 261930;
}
function YS(e, t) {
  var n = e.entangledLanes |= t;
  for (e = e.entanglements; n; ) {
    var r = 31 - vn(n), a = 1 << r;
    a & t | e[r] & t && (e[r] |= t), n &= ~a;
  }
}
function KS(e, t) {
  var n = t & -t;
  return n = n & 42 ? 1 : Tv(n), n & (e.suspendedLanes | t) ? 0 : n;
}
function Tv(e) {
  switch (e) {
    case 2:
      e = 1;
      break;
    case 8:
      e = 4;
      break;
    case 32:
      e = 16;
      break;
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
      e = 128;
      break;
    case 268435456:
      e = 134217728;
      break;
    default:
      e = 0;
  }
  return e;
}
function Cv(e) {
  return e &= -e, 2 < e ? 8 < e ? e & 134217727 ? 32 : 268435456 : 8 : 2;
}
function XS() {
  var e = De.p;
  return e !== 0 ? e : (e = window.event, e === void 0 ? 32 : bO(e.type));
}
function Xb(e, t) {
  var n = De.p;
  try {
    return De.p = e, t();
  } finally {
    De.p = n;
  }
}
var ci = Math.random().toString(36).slice(2), zt = "__reactFiber$" + ci, on = "__reactProps$" + ci, Qs = "__reactContainer$" + ci, um = "__reactEvents$" + ci, pN = "__reactListeners$" + ci, mN = "__reactHandles$" + ci, Wb = "__reactResources$" + ci, Zc = "__reactMarker$" + ci;
function Ov(e) {
  delete e[zt], delete e[on], delete e[um], delete e[pN], delete e[mN];
}
function Lo(e) {
  var t = e[zt];
  if (t) return t;
  for (var n = e.parentNode; n; ) {
    if (t = n[Qs] || n[zt]) {
      if (n = t.alternate, t.child !== null || n !== null && n.child !== null)
        for (e = aw(e); e !== null; ) {
          if (n = e[zt]) return n;
          e = aw(e);
        }
      return t;
    }
    e = n, n = e.parentNode;
  }
  return null;
}
function Hs(e) {
  if (e = e[zt] || e[Qs]) {
    var t = e.tag;
    if (t === 5 || t === 6 || t === 13 || t === 31 || t === 26 || t === 27 || t === 3)
      return e;
  }
  return null;
}
function Ll(e) {
  var t = e.tag;
  if (t === 5 || t === 26 || t === 27 || t === 6) return e.stateNode;
  throw Error(V(33));
}
function Xo(e) {
  var t = e[Wb];
  return t || (t = e[Wb] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() }), t;
}
function _t(e) {
  e[Zc] = !0;
}
var WS = /* @__PURE__ */ new Set(), ZS = {};
function ao(e, t) {
  Cs(e, t), Cs(e + "Capture", t);
}
function Cs(e, t) {
  for (ZS[e] = t, e = 0; e < t.length; e++)
    WS.add(t[e]);
}
var gN = RegExp(
  "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
), Zb = {}, Jb = {};
function vN(e) {
  return cm.call(Jb, e) ? !0 : cm.call(Zb, e) ? !1 : gN.test(e) ? Jb[e] = !0 : (Zb[e] = !0, !1);
}
function of(e, t, n) {
  if (vN(t))
    if (n === null) e.removeAttribute(t);
    else {
      switch (typeof n) {
        case "undefined":
        case "function":
        case "symbol":
          e.removeAttribute(t);
          return;
        case "boolean":
          var r = t.toLowerCase().slice(0, 5);
          if (r !== "data-" && r !== "aria-") {
            e.removeAttribute(t);
            return;
          }
      }
      e.setAttribute(t, "" + n);
    }
}
function ku(e, t, n) {
  if (n === null) e.removeAttribute(t);
  else {
    switch (typeof n) {
      case "undefined":
      case "function":
      case "symbol":
      case "boolean":
        e.removeAttribute(t);
        return;
    }
    e.setAttribute(t, "" + n);
  }
}
function Tr(e, t, n, r) {
  if (r === null) e.removeAttribute(n);
  else {
    switch (typeof r) {
      case "undefined":
      case "function":
      case "symbol":
      case "boolean":
        e.removeAttribute(n);
        return;
    }
    e.setAttributeNS(t, n, "" + r);
  }
}
function On(e) {
  switch (typeof e) {
    case "bigint":
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return e;
    case "object":
      return e;
    default:
      return "";
  }
}
function JS(e) {
  var t = e.type;
  return (e = e.nodeName) && e.toLowerCase() === "input" && (t === "checkbox" || t === "radio");
}
function yN(e, t, n) {
  var r = Object.getOwnPropertyDescriptor(
    e.constructor.prototype,
    t
  );
  if (!e.hasOwnProperty(t) && typeof r < "u" && typeof r.get == "function" && typeof r.set == "function") {
    var a = r.get, i = r.set;
    return Object.defineProperty(e, t, {
      configurable: !0,
      get: function() {
        return a.call(this);
      },
      set: function(o) {
        n = "" + o, i.call(this, o);
      }
    }), Object.defineProperty(e, t, {
      enumerable: r.enumerable
    }), {
      getValue: function() {
        return n;
      },
      setValue: function(o) {
        n = "" + o;
      },
      stopTracking: function() {
        e._valueTracker = null, delete e[t];
      }
    };
  }
}
function fm(e) {
  if (!e._valueTracker) {
    var t = JS(e) ? "checked" : "value";
    e._valueTracker = yN(
      e,
      t,
      "" + e[t]
    );
  }
}
function eT(e) {
  if (!e) return !1;
  var t = e._valueTracker;
  if (!t) return !0;
  var n = t.getValue(), r = "";
  return e && (r = JS(e) ? e.checked ? "true" : "false" : e.value), e = r, e !== n ? (t.setValue(e), !0) : !1;
}
function Ff(e) {
  if (e = e || (typeof document < "u" ? document : void 0), typeof e > "u") return null;
  try {
    return e.activeElement || e.body;
  } catch {
    return e.body;
  }
}
var bN = /[\n"\\]/g;
function _n(e) {
  return e.replace(
    bN,
    function(t) {
      return "\\" + t.charCodeAt(0).toString(16) + " ";
    }
  );
}
function dm(e, t, n, r, a, i, o, s) {
  e.name = "", o != null && typeof o != "function" && typeof o != "symbol" && typeof o != "boolean" ? e.type = o : e.removeAttribute("type"), t != null ? o === "number" ? (t === 0 && e.value === "" || e.value != t) && (e.value = "" + On(t)) : e.value !== "" + On(t) && (e.value = "" + On(t)) : o !== "submit" && o !== "reset" || e.removeAttribute("value"), t != null ? hm(e, o, On(t)) : n != null ? hm(e, o, On(n)) : r != null && e.removeAttribute("value"), a == null && i != null && (e.defaultChecked = !!i), a != null && (e.checked = a && typeof a != "function" && typeof a != "symbol"), s != null && typeof s != "function" && typeof s != "symbol" && typeof s != "boolean" ? e.name = "" + On(s) : e.removeAttribute("name");
}
function tT(e, t, n, r, a, i, o, s) {
  if (i != null && typeof i != "function" && typeof i != "symbol" && typeof i != "boolean" && (e.type = i), t != null || n != null) {
    if (!(i !== "submit" && i !== "reset" || t != null)) {
      fm(e);
      return;
    }
    n = n != null ? "" + On(n) : "", t = t != null ? "" + On(t) : n, s || t === e.value || (e.value = t), e.defaultValue = t;
  }
  r = r ?? a, r = typeof r != "function" && typeof r != "symbol" && !!r, e.checked = s ? e.checked : !!r, e.defaultChecked = !!r, o != null && typeof o != "function" && typeof o != "symbol" && typeof o != "boolean" && (e.name = o), fm(e);
}
function hm(e, t, n) {
  t === "number" && Ff(e.ownerDocument) === e || e.defaultValue === "" + n || (e.defaultValue = "" + n);
}
function Wo(e, t, n, r) {
  if (e = e.options, t) {
    t = {};
    for (var a = 0; a < n.length; a++)
      t["$" + n[a]] = !0;
    for (n = 0; n < e.length; n++)
      a = t.hasOwnProperty("$" + e[n].value), e[n].selected !== a && (e[n].selected = a), a && r && (e[n].defaultSelected = !0);
  } else {
    for (n = "" + On(n), t = null, a = 0; a < e.length; a++) {
      if (e[a].value === n) {
        e[a].selected = !0, r && (e[a].defaultSelected = !0);
        return;
      }
      t !== null || e[a].disabled || (t = e[a]);
    }
    t !== null && (t.selected = !0);
  }
}
function nT(e, t, n) {
  if (t != null && (t = "" + On(t), t !== e.value && (e.value = t), n == null)) {
    e.defaultValue !== t && (e.defaultValue = t);
    return;
  }
  e.defaultValue = n != null ? "" + On(n) : "";
}
function rT(e, t, n, r) {
  if (t == null) {
    if (r != null) {
      if (n != null) throw Error(V(92));
      if (Ml(r)) {
        if (1 < r.length) throw Error(V(93));
        r = r[0];
      }
      n = r;
    }
    n == null && (n = ""), t = n;
  }
  n = On(t), e.defaultValue = n, r = e.textContent, r === n && r !== "" && r !== null && (e.value = r), fm(e);
}
function Os(e, t) {
  if (t) {
    var n = e.firstChild;
    if (n && n === e.lastChild && n.nodeType === 3) {
      n.nodeValue = t;
      return;
    }
  }
  e.textContent = t;
}
var wN = new Set(
  "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
    " "
  )
);
function e0(e, t, n) {
  var r = t.indexOf("--") === 0;
  n == null || typeof n == "boolean" || n === "" ? r ? e.setProperty(t, "") : t === "float" ? e.cssFloat = "" : e[t] = "" : r ? e.setProperty(t, n) : typeof n != "number" || n === 0 || wN.has(t) ? t === "float" ? e.cssFloat = n : e[t] = ("" + n).trim() : e[t] = n + "px";
}
function aT(e, t, n) {
  if (t != null && typeof t != "object")
    throw Error(V(62));
  if (e = e.style, n != null) {
    for (var r in n)
      !n.hasOwnProperty(r) || t != null && t.hasOwnProperty(r) || (r.indexOf("--") === 0 ? e.setProperty(r, "") : r === "float" ? e.cssFloat = "" : e[r] = "");
    for (var a in t)
      r = t[a], t.hasOwnProperty(a) && n[a] !== r && e0(e, a, r);
  } else
    for (var i in t)
      t.hasOwnProperty(i) && e0(e, i, t[i]);
}
function Av(e) {
  if (e.indexOf("-") === -1) return !1;
  switch (e) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return !1;
    default:
      return !0;
  }
}
var xN = /* @__PURE__ */ new Map([
  ["acceptCharset", "accept-charset"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"],
  ["crossOrigin", "crossorigin"],
  ["accentHeight", "accent-height"],
  ["alignmentBaseline", "alignment-baseline"],
  ["arabicForm", "arabic-form"],
  ["baselineShift", "baseline-shift"],
  ["capHeight", "cap-height"],
  ["clipPath", "clip-path"],
  ["clipRule", "clip-rule"],
  ["colorInterpolation", "color-interpolation"],
  ["colorInterpolationFilters", "color-interpolation-filters"],
  ["colorProfile", "color-profile"],
  ["colorRendering", "color-rendering"],
  ["dominantBaseline", "dominant-baseline"],
  ["enableBackground", "enable-background"],
  ["fillOpacity", "fill-opacity"],
  ["fillRule", "fill-rule"],
  ["floodColor", "flood-color"],
  ["floodOpacity", "flood-opacity"],
  ["fontFamily", "font-family"],
  ["fontSize", "font-size"],
  ["fontSizeAdjust", "font-size-adjust"],
  ["fontStretch", "font-stretch"],
  ["fontStyle", "font-style"],
  ["fontVariant", "font-variant"],
  ["fontWeight", "font-weight"],
  ["glyphName", "glyph-name"],
  ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
  ["glyphOrientationVertical", "glyph-orientation-vertical"],
  ["horizAdvX", "horiz-adv-x"],
  ["horizOriginX", "horiz-origin-x"],
  ["imageRendering", "image-rendering"],
  ["letterSpacing", "letter-spacing"],
  ["lightingColor", "lighting-color"],
  ["markerEnd", "marker-end"],
  ["markerMid", "marker-mid"],
  ["markerStart", "marker-start"],
  ["overlinePosition", "overline-position"],
  ["overlineThickness", "overline-thickness"],
  ["paintOrder", "paint-order"],
  ["panose-1", "panose-1"],
  ["pointerEvents", "pointer-events"],
  ["renderingIntent", "rendering-intent"],
  ["shapeRendering", "shape-rendering"],
  ["stopColor", "stop-color"],
  ["stopOpacity", "stop-opacity"],
  ["strikethroughPosition", "strikethrough-position"],
  ["strikethroughThickness", "strikethrough-thickness"],
  ["strokeDasharray", "stroke-dasharray"],
  ["strokeDashoffset", "stroke-dashoffset"],
  ["strokeLinecap", "stroke-linecap"],
  ["strokeLinejoin", "stroke-linejoin"],
  ["strokeMiterlimit", "stroke-miterlimit"],
  ["strokeOpacity", "stroke-opacity"],
  ["strokeWidth", "stroke-width"],
  ["textAnchor", "text-anchor"],
  ["textDecoration", "text-decoration"],
  ["textRendering", "text-rendering"],
  ["transformOrigin", "transform-origin"],
  ["underlinePosition", "underline-position"],
  ["underlineThickness", "underline-thickness"],
  ["unicodeBidi", "unicode-bidi"],
  ["unicodeRange", "unicode-range"],
  ["unitsPerEm", "units-per-em"],
  ["vAlphabetic", "v-alphabetic"],
  ["vHanging", "v-hanging"],
  ["vIdeographic", "v-ideographic"],
  ["vMathematical", "v-mathematical"],
  ["vectorEffect", "vector-effect"],
  ["vertAdvY", "vert-adv-y"],
  ["vertOriginX", "vert-origin-x"],
  ["vertOriginY", "vert-origin-y"],
  ["wordSpacing", "word-spacing"],
  ["writingMode", "writing-mode"],
  ["xmlnsXlink", "xmlns:xlink"],
  ["xHeight", "x-height"]
]), EN = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
function sf(e) {
  return EN.test("" + e) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : e;
}
function Fr() {
}
var pm = null;
function Rv(e) {
  return e = e.target || e.srcElement || window, e.correspondingUseElement && (e = e.correspondingUseElement), e.nodeType === 3 ? e.parentNode : e;
}
var zo = null, Zo = null;
function t0(e) {
  var t = Hs(e);
  if (t && (e = t.stateNode)) {
    var n = e[on] || null;
    e: switch (e = t.stateNode, t.type) {
      case "input":
        if (dm(
          e,
          n.value,
          n.defaultValue,
          n.defaultValue,
          n.checked,
          n.defaultChecked,
          n.type,
          n.name
        ), t = n.name, n.type === "radio" && t != null) {
          for (n = e; n.parentNode; ) n = n.parentNode;
          for (n = n.querySelectorAll(
            'input[name="' + _n(
              "" + t
            ) + '"][type="radio"]'
          ), t = 0; t < n.length; t++) {
            var r = n[t];
            if (r !== e && r.form === e.form) {
              var a = r[on] || null;
              if (!a) throw Error(V(90));
              dm(
                r,
                a.value,
                a.defaultValue,
                a.defaultValue,
                a.checked,
                a.defaultChecked,
                a.type,
                a.name
              );
            }
          }
          for (t = 0; t < n.length; t++)
            r = n[t], r.form === e.form && eT(r);
        }
        break e;
      case "textarea":
        nT(e, n.value, n.defaultValue);
        break e;
      case "select":
        t = n.value, t != null && Wo(e, !!n.multiple, t, !1);
    }
  }
}
var Lh = !1;
function iT(e, t, n) {
  if (Lh) return e(t, n);
  Lh = !0;
  try {
    var r = e(t);
    return r;
  } finally {
    if (Lh = !1, (zo !== null || Zo !== null) && (Hd(), zo && (t = zo, e = Zo, Zo = zo = null, t0(t), e)))
      for (t = 0; t < e.length; t++) t0(e[t]);
  }
}
function dc(e, t) {
  var n = e.stateNode;
  if (n === null) return null;
  var r = n[on] || null;
  if (r === null) return null;
  n = r[t];
  e: switch (t) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      (r = !r.disabled) || (e = e.type, r = !(e === "button" || e === "input" || e === "select" || e === "textarea")), e = !r;
      break e;
    default:
      e = !1;
  }
  if (e) return null;
  if (n && typeof n != "function")
    throw Error(
      V(231, t, typeof n)
    );
  return n;
}
var Qr = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), mm = !1;
if (Qr)
  try {
    var dl = {};
    Object.defineProperty(dl, "passive", {
      get: function() {
        mm = !0;
      }
    }), window.addEventListener("test", dl, dl), window.removeEventListener("test", dl, dl);
  } catch {
    mm = !1;
  }
var Ma = null, _v = null, lf = null;
function oT() {
  if (lf) return lf;
  var e, t = _v, n = t.length, r, a = "value" in Ma ? Ma.value : Ma.textContent, i = a.length;
  for (e = 0; e < n && t[e] === a[e]; e++) ;
  var o = n - e;
  for (r = 1; r <= o && t[n - r] === a[i - r]; r++) ;
  return lf = a.slice(e, 1 < r ? 1 - r : void 0);
}
function cf(e) {
  var t = e.keyCode;
  return "charCode" in e ? (e = e.charCode, e === 0 && t === 13 && (e = 13)) : e = t, e === 10 && (e = 13), 32 <= e || e === 13 ? e : 0;
}
function Mu() {
  return !0;
}
function n0() {
  return !1;
}
function sn(e) {
  function t(n, r, a, i, o) {
    this._reactName = n, this._targetInst = a, this.type = r, this.nativeEvent = i, this.target = o, this.currentTarget = null;
    for (var s in e)
      e.hasOwnProperty(s) && (n = e[s], this[s] = n ? n(i) : i[s]);
    return this.isDefaultPrevented = (i.defaultPrevented != null ? i.defaultPrevented : i.returnValue === !1) ? Mu : n0, this.isPropagationStopped = n0, this;
  }
  return Xe(t.prototype, {
    preventDefault: function() {
      this.defaultPrevented = !0;
      var n = this.nativeEvent;
      n && (n.preventDefault ? n.preventDefault() : typeof n.returnValue != "unknown" && (n.returnValue = !1), this.isDefaultPrevented = Mu);
    },
    stopPropagation: function() {
      var n = this.nativeEvent;
      n && (n.stopPropagation ? n.stopPropagation() : typeof n.cancelBubble != "unknown" && (n.cancelBubble = !0), this.isPropagationStopped = Mu);
    },
    persist: function() {
    },
    isPersistent: Mu
  }), t;
}
var io = {
  eventPhase: 0,
  bubbles: 0,
  cancelable: 0,
  timeStamp: function(e) {
    return e.timeStamp || Date.now();
  },
  defaultPrevented: 0,
  isTrusted: 0
}, Ld = sn(io), Jc = Xe({}, io, { view: 0, detail: 0 }), SN = sn(Jc), zh, jh, hl, zd = Xe({}, Jc, {
  screenX: 0,
  screenY: 0,
  clientX: 0,
  clientY: 0,
  pageX: 0,
  pageY: 0,
  ctrlKey: 0,
  shiftKey: 0,
  altKey: 0,
  metaKey: 0,
  getModifierState: Dv,
  button: 0,
  buttons: 0,
  relatedTarget: function(e) {
    return e.relatedTarget === void 0 ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget;
  },
  movementX: function(e) {
    return "movementX" in e ? e.movementX : (e !== hl && (hl && e.type === "mousemove" ? (zh = e.screenX - hl.screenX, jh = e.screenY - hl.screenY) : jh = zh = 0, hl = e), zh);
  },
  movementY: function(e) {
    return "movementY" in e ? e.movementY : jh;
  }
}), r0 = sn(zd), TN = Xe({}, zd, { dataTransfer: 0 }), CN = sn(TN), ON = Xe({}, Jc, { relatedTarget: 0 }), Ph = sn(ON), AN = Xe({}, io, {
  animationName: 0,
  elapsedTime: 0,
  pseudoElement: 0
}), RN = sn(AN), _N = Xe({}, io, {
  clipboardData: function(e) {
    return "clipboardData" in e ? e.clipboardData : window.clipboardData;
  }
}), DN = sn(_N), NN = Xe({}, io, { data: 0 }), a0 = sn(NN), kN = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, MN = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, LN = {
  Alt: "altKey",
  Control: "ctrlKey",
  Meta: "metaKey",
  Shift: "shiftKey"
};
function zN(e) {
  var t = this.nativeEvent;
  return t.getModifierState ? t.getModifierState(e) : (e = LN[e]) ? !!t[e] : !1;
}
function Dv() {
  return zN;
}
var jN = Xe({}, Jc, {
  key: function(e) {
    if (e.key) {
      var t = kN[e.key] || e.key;
      if (t !== "Unidentified") return t;
    }
    return e.type === "keypress" ? (e = cf(e), e === 13 ? "Enter" : String.fromCharCode(e)) : e.type === "keydown" || e.type === "keyup" ? MN[e.keyCode] || "Unidentified" : "";
  },
  code: 0,
  location: 0,
  ctrlKey: 0,
  shiftKey: 0,
  altKey: 0,
  metaKey: 0,
  repeat: 0,
  locale: 0,
  getModifierState: Dv,
  charCode: function(e) {
    return e.type === "keypress" ? cf(e) : 0;
  },
  keyCode: function(e) {
    return e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0;
  },
  which: function(e) {
    return e.type === "keypress" ? cf(e) : e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0;
  }
}), PN = sn(jN), IN = Xe({}, zd, {
  pointerId: 0,
  width: 0,
  height: 0,
  pressure: 0,
  tangentialPressure: 0,
  tiltX: 0,
  tiltY: 0,
  twist: 0,
  pointerType: 0,
  isPrimary: 0
}), i0 = sn(IN), FN = Xe({}, Jc, {
  touches: 0,
  targetTouches: 0,
  changedTouches: 0,
  altKey: 0,
  metaKey: 0,
  ctrlKey: 0,
  shiftKey: 0,
  getModifierState: Dv
}), UN = sn(FN), qN = Xe({}, io, {
  propertyName: 0,
  elapsedTime: 0,
  pseudoElement: 0
}), BN = sn(qN), VN = Xe({}, zd, {
  deltaX: function(e) {
    return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0;
  },
  deltaY: function(e) {
    return "deltaY" in e ? e.deltaY : "wheelDeltaY" in e ? -e.wheelDeltaY : "wheelDelta" in e ? -e.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), QN = sn(VN), HN = Xe({}, io, {
  newState: 0,
  oldState: 0
}), $N = sn(HN), GN = [9, 13, 27, 32], Nv = Qr && "CompositionEvent" in window, Hl = null;
Qr && "documentMode" in document && (Hl = document.documentMode);
var YN = Qr && "TextEvent" in window && !Hl, sT = Qr && (!Nv || Hl && 8 < Hl && 11 >= Hl), o0 = " ", s0 = !1;
function lT(e, t) {
  switch (e) {
    case "keyup":
      return GN.indexOf(t.keyCode) !== -1;
    case "keydown":
      return t.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
      return !0;
    default:
      return !1;
  }
}
function cT(e) {
  return e = e.detail, typeof e == "object" && "data" in e ? e.data : null;
}
var jo = !1;
function KN(e, t) {
  switch (e) {
    case "compositionend":
      return cT(t);
    case "keypress":
      return t.which !== 32 ? null : (s0 = !0, o0);
    case "textInput":
      return e = t.data, e === o0 && s0 ? null : e;
    default:
      return null;
  }
}
function XN(e, t) {
  if (jo)
    return e === "compositionend" || !Nv && lT(e, t) ? (e = oT(), lf = _v = Ma = null, jo = !1, e) : null;
  switch (e) {
    case "paste":
      return null;
    case "keypress":
      if (!(t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) {
        if (t.char && 1 < t.char.length)
          return t.char;
        if (t.which) return String.fromCharCode(t.which);
      }
      return null;
    case "compositionend":
      return sT && t.locale !== "ko" ? null : t.data;
    default:
      return null;
  }
}
var WN = {
  color: !0,
  date: !0,
  datetime: !0,
  "datetime-local": !0,
  email: !0,
  month: !0,
  number: !0,
  password: !0,
  range: !0,
  search: !0,
  tel: !0,
  text: !0,
  time: !0,
  url: !0,
  week: !0
};
function l0(e) {
  var t = e && e.nodeName && e.nodeName.toLowerCase();
  return t === "input" ? !!WN[e.type] : t === "textarea";
}
function uT(e, t, n, r) {
  zo ? Zo ? Zo.push(r) : Zo = [r] : zo = r, t = rd(t, "onChange"), 0 < t.length && (n = new Ld(
    "onChange",
    "change",
    null,
    n,
    r
  ), e.push({ event: n, listeners: t }));
}
var $l = null, hc = null;
function ZN(e) {
  iO(e, 0);
}
function jd(e) {
  var t = Ll(e);
  if (eT(t)) return e;
}
function c0(e, t) {
  if (e === "change") return t;
}
var fT = !1;
if (Qr) {
  var Ih;
  if (Qr) {
    var Fh = "oninput" in document;
    if (!Fh) {
      var u0 = document.createElement("div");
      u0.setAttribute("oninput", "return;"), Fh = typeof u0.oninput == "function";
    }
    Ih = Fh;
  } else Ih = !1;
  fT = Ih && (!document.documentMode || 9 < document.documentMode);
}
function f0() {
  $l && ($l.detachEvent("onpropertychange", dT), hc = $l = null);
}
function dT(e) {
  if (e.propertyName === "value" && jd(hc)) {
    var t = [];
    uT(
      t,
      hc,
      e,
      Rv(e)
    ), iT(ZN, t);
  }
}
function JN(e, t, n) {
  e === "focusin" ? (f0(), $l = t, hc = n, $l.attachEvent("onpropertychange", dT)) : e === "focusout" && f0();
}
function ek(e) {
  if (e === "selectionchange" || e === "keyup" || e === "keydown")
    return jd(hc);
}
function tk(e, t) {
  if (e === "click") return jd(t);
}
function nk(e, t) {
  if (e === "input" || e === "change")
    return jd(t);
}
function rk(e, t) {
  return e === t && (e !== 0 || 1 / e === 1 / t) || e !== e && t !== t;
}
var wn = typeof Object.is == "function" ? Object.is : rk;
function pc(e, t) {
  if (wn(e, t)) return !0;
  if (typeof e != "object" || e === null || typeof t != "object" || t === null)
    return !1;
  var n = Object.keys(e), r = Object.keys(t);
  if (n.length !== r.length) return !1;
  for (r = 0; r < n.length; r++) {
    var a = n[r];
    if (!cm.call(t, a) || !wn(e[a], t[a]))
      return !1;
  }
  return !0;
}
function d0(e) {
  for (; e && e.firstChild; ) e = e.firstChild;
  return e;
}
function h0(e, t) {
  var n = d0(e);
  e = 0;
  for (var r; n; ) {
    if (n.nodeType === 3) {
      if (r = e + n.textContent.length, e <= t && r >= t)
        return { node: n, offset: t - e };
      e = r;
    }
    e: {
      for (; n; ) {
        if (n.nextSibling) {
          n = n.nextSibling;
          break e;
        }
        n = n.parentNode;
      }
      n = void 0;
    }
    n = d0(n);
  }
}
function hT(e, t) {
  return e && t ? e === t ? !0 : e && e.nodeType === 3 ? !1 : t && t.nodeType === 3 ? hT(e, t.parentNode) : "contains" in e ? e.contains(t) : e.compareDocumentPosition ? !!(e.compareDocumentPosition(t) & 16) : !1 : !1;
}
function pT(e) {
  e = e != null && e.ownerDocument != null && e.ownerDocument.defaultView != null ? e.ownerDocument.defaultView : window;
  for (var t = Ff(e.document); t instanceof e.HTMLIFrameElement; ) {
    try {
      var n = typeof t.contentWindow.location.href == "string";
    } catch {
      n = !1;
    }
    if (n) e = t.contentWindow;
    else break;
    t = Ff(e.document);
  }
  return t;
}
function kv(e) {
  var t = e && e.nodeName && e.nodeName.toLowerCase();
  return t && (t === "input" && (e.type === "text" || e.type === "search" || e.type === "tel" || e.type === "url" || e.type === "password") || t === "textarea" || e.contentEditable === "true");
}
var ak = Qr && "documentMode" in document && 11 >= document.documentMode, Po = null, gm = null, Gl = null, vm = !1;
function p0(e, t, n) {
  var r = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument;
  vm || Po == null || Po !== Ff(r) || (r = Po, "selectionStart" in r && kv(r) ? r = { start: r.selectionStart, end: r.selectionEnd } : (r = (r.ownerDocument && r.ownerDocument.defaultView || window).getSelection(), r = {
    anchorNode: r.anchorNode,
    anchorOffset: r.anchorOffset,
    focusNode: r.focusNode,
    focusOffset: r.focusOffset
  }), Gl && pc(Gl, r) || (Gl = r, r = rd(gm, "onSelect"), 0 < r.length && (t = new Ld(
    "onSelect",
    "select",
    null,
    t,
    n
  ), e.push({ event: t, listeners: r }), t.target = Po)));
}
function yi(e, t) {
  var n = {};
  return n[e.toLowerCase()] = t.toLowerCase(), n["Webkit" + e] = "webkit" + t, n["Moz" + e] = "moz" + t, n;
}
var Io = {
  animationend: yi("Animation", "AnimationEnd"),
  animationiteration: yi("Animation", "AnimationIteration"),
  animationstart: yi("Animation", "AnimationStart"),
  transitionrun: yi("Transition", "TransitionRun"),
  transitionstart: yi("Transition", "TransitionStart"),
  transitioncancel: yi("Transition", "TransitionCancel"),
  transitionend: yi("Transition", "TransitionEnd")
}, Uh = {}, mT = {};
Qr && (mT = document.createElement("div").style, "AnimationEvent" in window || (delete Io.animationend.animation, delete Io.animationiteration.animation, delete Io.animationstart.animation), "TransitionEvent" in window || delete Io.transitionend.transition);
function oo(e) {
  if (Uh[e]) return Uh[e];
  if (!Io[e]) return e;
  var t = Io[e], n;
  for (n in t)
    if (t.hasOwnProperty(n) && n in mT)
      return Uh[e] = t[n];
  return e;
}
var gT = oo("animationend"), vT = oo("animationiteration"), yT = oo("animationstart"), ik = oo("transitionrun"), ok = oo("transitionstart"), sk = oo("transitioncancel"), bT = oo("transitionend"), wT = /* @__PURE__ */ new Map(), ym = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
  " "
);
ym.push("scrollEnd");
function $n(e, t) {
  wT.set(e, t), ao(t, [e]);
}
var Uf = typeof reportError == "function" ? reportError : function(e) {
  if (typeof window == "object" && typeof window.ErrorEvent == "function") {
    var t = new window.ErrorEvent("error", {
      bubbles: !0,
      cancelable: !0,
      message: typeof e == "object" && e !== null && typeof e.message == "string" ? String(e.message) : String(e),
      error: e
    });
    if (!window.dispatchEvent(t)) return;
  } else if (typeof process == "object" && typeof process.emit == "function") {
    process.emit("uncaughtException", e);
    return;
  }
  console.error(e);
}, Sn = [], Fo = 0, Mv = 0;
function Pd() {
  for (var e = Fo, t = Mv = Fo = 0; t < e; ) {
    var n = Sn[t];
    Sn[t++] = null;
    var r = Sn[t];
    Sn[t++] = null;
    var a = Sn[t];
    Sn[t++] = null;
    var i = Sn[t];
    if (Sn[t++] = null, r !== null && a !== null) {
      var o = r.pending;
      o === null ? a.next = a : (a.next = o.next, o.next = a), r.pending = a;
    }
    i !== 0 && xT(n, a, i);
  }
}
function Id(e, t, n, r) {
  Sn[Fo++] = e, Sn[Fo++] = t, Sn[Fo++] = n, Sn[Fo++] = r, Mv |= r, e.lanes |= r, e = e.alternate, e !== null && (e.lanes |= r);
}
function Lv(e, t, n, r) {
  return Id(e, t, n, r), qf(e);
}
function so(e, t) {
  return Id(e, null, null, t), qf(e);
}
function xT(e, t, n) {
  e.lanes |= n;
  var r = e.alternate;
  r !== null && (r.lanes |= n);
  for (var a = !1, i = e.return; i !== null; )
    i.childLanes |= n, r = i.alternate, r !== null && (r.childLanes |= n), i.tag === 22 && (e = i.stateNode, e === null || e._visibility & 1 || (a = !0)), e = i, i = i.return;
  return e.tag === 3 ? (i = e.stateNode, a && t !== null && (a = 31 - vn(n), e = i.hiddenUpdates, r = e[a], r === null ? e[a] = [t] : r.push(t), t.lane = n | 536870912), i) : null;
}
function qf(e) {
  if (50 < nc)
    throw nc = 0, Fm = null, Error(V(185));
  for (var t = e.return; t !== null; )
    e = t, t = e.return;
  return e.tag === 3 ? e.stateNode : null;
}
var Uo = {};
function lk(e, t, n, r) {
  this.tag = e, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = t, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
}
function hn(e, t, n, r) {
  return new lk(e, t, n, r);
}
function zv(e) {
  return e = e.prototype, !(!e || !e.isReactComponent);
}
function qr(e, t) {
  var n = e.alternate;
  return n === null ? (n = hn(
    e.tag,
    t,
    e.key,
    e.mode
  ), n.elementType = e.elementType, n.type = e.type, n.stateNode = e.stateNode, n.alternate = e, e.alternate = n) : (n.pendingProps = t, n.type = e.type, n.flags = 0, n.subtreeFlags = 0, n.deletions = null), n.flags = e.flags & 65011712, n.childLanes = e.childLanes, n.lanes = e.lanes, n.child = e.child, n.memoizedProps = e.memoizedProps, n.memoizedState = e.memoizedState, n.updateQueue = e.updateQueue, t = e.dependencies, n.dependencies = t === null ? null : { lanes: t.lanes, firstContext: t.firstContext }, n.sibling = e.sibling, n.index = e.index, n.ref = e.ref, n.refCleanup = e.refCleanup, n;
}
function ET(e, t) {
  e.flags &= 65011714;
  var n = e.alternate;
  return n === null ? (e.childLanes = 0, e.lanes = t, e.child = null, e.subtreeFlags = 0, e.memoizedProps = null, e.memoizedState = null, e.updateQueue = null, e.dependencies = null, e.stateNode = null) : (e.childLanes = n.childLanes, e.lanes = n.lanes, e.child = n.child, e.subtreeFlags = 0, e.deletions = null, e.memoizedProps = n.memoizedProps, e.memoizedState = n.memoizedState, e.updateQueue = n.updateQueue, e.type = n.type, t = n.dependencies, e.dependencies = t === null ? null : {
    lanes: t.lanes,
    firstContext: t.firstContext
  }), e;
}
function uf(e, t, n, r, a, i) {
  var o = 0;
  if (r = e, typeof e == "function") zv(e) && (o = 1);
  else if (typeof e == "string")
    o = hM(
      e,
      n,
      ir.current
    ) ? 26 : e === "html" || e === "head" || e === "body" ? 27 : 5;
  else
    e: switch (e) {
      case im:
        return e = hn(31, n, t, a), e.elementType = im, e.lanes = i, e;
      case ko:
        return qi(n.children, a, i, t);
      case qS:
        o = 8, a |= 24;
        break;
      case nm:
        return e = hn(12, n, t, a | 2), e.elementType = nm, e.lanes = i, e;
      case rm:
        return e = hn(13, n, t, a), e.elementType = rm, e.lanes = i, e;
      case am:
        return e = hn(19, n, t, a), e.elementType = am, e.lanes = i, e;
      default:
        if (typeof e == "object" && e !== null)
          switch (e.$$typeof) {
            case Ir:
              o = 10;
              break e;
            case BS:
              o = 9;
              break e;
            case xv:
              o = 11;
              break e;
            case Ev:
              o = 14;
              break e;
            case ha:
              o = 16, r = null;
              break e;
          }
        o = 29, n = Error(
          V(130, e === null ? "null" : typeof e, "")
        ), r = null;
    }
  return t = hn(o, n, t, a), t.elementType = e, t.type = r, t.lanes = i, t;
}
function qi(e, t, n, r) {
  return e = hn(7, e, r, t), e.lanes = n, e;
}
function qh(e, t, n) {
  return e = hn(6, e, null, t), e.lanes = n, e;
}
function ST(e) {
  var t = hn(18, null, null, 0);
  return t.stateNode = e, t;
}
function Bh(e, t, n) {
  return t = hn(
    4,
    e.children !== null ? e.children : [],
    e.key,
    t
  ), t.lanes = n, t.stateNode = {
    containerInfo: e.containerInfo,
    pendingChildren: null,
    implementation: e.implementation
  }, t;
}
var m0 = /* @__PURE__ */ new WeakMap();
function Dn(e, t) {
  if (typeof e == "object" && e !== null) {
    var n = m0.get(e);
    return n !== void 0 ? n : (t = {
      value: e,
      source: t,
      stack: Kb(t)
    }, m0.set(e, t), t);
  }
  return {
    value: e,
    source: t,
    stack: Kb(t)
  };
}
var qo = [], Bo = 0, Bf = null, mc = 0, An = [], Rn = 0, Xa = null, er = 1, tr = "";
function Lr(e, t) {
  qo[Bo++] = mc, qo[Bo++] = Bf, Bf = e, mc = t;
}
function TT(e, t, n) {
  An[Rn++] = er, An[Rn++] = tr, An[Rn++] = Xa, Xa = e;
  var r = er;
  e = tr;
  var a = 32 - vn(r) - 1;
  r &= ~(1 << a), n += 1;
  var i = 32 - vn(t) + a;
  if (30 < i) {
    var o = a - a % 5;
    i = (r & (1 << o) - 1).toString(32), r >>= o, a -= o, er = 1 << 32 - vn(t) + a | n << a | r, tr = i + e;
  } else
    er = 1 << i | n << a | r, tr = e;
}
function jv(e) {
  e.return !== null && (Lr(e, 1), TT(e, 1, 0));
}
function Pv(e) {
  for (; e === Bf; )
    Bf = qo[--Bo], qo[Bo] = null, mc = qo[--Bo], qo[Bo] = null;
  for (; e === Xa; )
    Xa = An[--Rn], An[Rn] = null, tr = An[--Rn], An[Rn] = null, er = An[--Rn], An[Rn] = null;
}
function CT(e, t) {
  An[Rn++] = er, An[Rn++] = tr, An[Rn++] = Xa, er = t.id, tr = t.overflow, Xa = e;
}
var jt = null, Ye = null, Ae = !1, Fa = null, Nn = !1, bm = Error(V(519));
function Wa(e) {
  var t = Error(
    V(
      418,
      1 < arguments.length && arguments[1] !== void 0 && arguments[1] ? "text" : "HTML",
      ""
    )
  );
  throw gc(Dn(t, e)), bm;
}
function g0(e) {
  var t = e.stateNode, n = e.type, r = e.memoizedProps;
  switch (t[zt] = e, t[on] = r, n) {
    case "dialog":
      xe("cancel", t), xe("close", t);
      break;
    case "iframe":
    case "object":
    case "embed":
      xe("load", t);
      break;
    case "video":
    case "audio":
      for (n = 0; n < wc.length; n++)
        xe(wc[n], t);
      break;
    case "source":
      xe("error", t);
      break;
    case "img":
    case "image":
    case "link":
      xe("error", t), xe("load", t);
      break;
    case "details":
      xe("toggle", t);
      break;
    case "input":
      xe("invalid", t), tT(
        t,
        r.value,
        r.defaultValue,
        r.checked,
        r.defaultChecked,
        r.type,
        r.name,
        !0
      );
      break;
    case "select":
      xe("invalid", t);
      break;
    case "textarea":
      xe("invalid", t), rT(t, r.value, r.defaultValue, r.children);
  }
  n = r.children, typeof n != "string" && typeof n != "number" && typeof n != "bigint" || t.textContent === "" + n || r.suppressHydrationWarning === !0 || sO(t.textContent, n) ? (r.popover != null && (xe("beforetoggle", t), xe("toggle", t)), r.onScroll != null && xe("scroll", t), r.onScrollEnd != null && xe("scrollend", t), r.onClick != null && (t.onclick = Fr), t = !0) : t = !1, t || Wa(e, !0);
}
function v0(e) {
  for (jt = e.return; jt; )
    switch (jt.tag) {
      case 5:
      case 31:
      case 13:
        Nn = !1;
        return;
      case 27:
      case 3:
        Nn = !0;
        return;
      default:
        jt = jt.return;
    }
}
function mo(e) {
  if (e !== jt) return !1;
  if (!Ae) return v0(e), Ae = !0, !1;
  var t = e.tag, n;
  if ((n = t !== 3 && t !== 27) && ((n = t === 5) && (n = e.type, n = !(n !== "form" && n !== "button") || Qm(e.type, e.memoizedProps)), n = !n), n && Ye && Wa(e), v0(e), t === 13) {
    if (e = e.memoizedState, e = e !== null ? e.dehydrated : null, !e) throw Error(V(317));
    Ye = rw(e);
  } else if (t === 31) {
    if (e = e.memoizedState, e = e !== null ? e.dehydrated : null, !e) throw Error(V(317));
    Ye = rw(e);
  } else
    t === 27 ? (t = Ye, ui(e.type) ? (e = Ym, Ym = null, Ye = e) : Ye = t) : Ye = jt ? Mn(e.stateNode.nextSibling) : null;
  return !0;
}
function $i() {
  Ye = jt = null, Ae = !1;
}
function Vh() {
  var e = Fa;
  return e !== null && (nn === null ? nn = e : nn.push.apply(
    nn,
    e
  ), Fa = null), e;
}
function gc(e) {
  Fa === null ? Fa = [e] : Fa.push(e);
}
var wm = hr(null), lo = null, Ur = null;
function ya(e, t, n) {
  Be(wm, t._currentValue), t._currentValue = n;
}
function Br(e) {
  e._currentValue = wm.current, Dt(wm);
}
function xm(e, t, n) {
  for (; e !== null; ) {
    var r = e.alternate;
    if ((e.childLanes & t) !== t ? (e.childLanes |= t, r !== null && (r.childLanes |= t)) : r !== null && (r.childLanes & t) !== t && (r.childLanes |= t), e === n) break;
    e = e.return;
  }
}
function Em(e, t, n, r) {
  var a = e.child;
  for (a !== null && (a.return = e); a !== null; ) {
    var i = a.dependencies;
    if (i !== null) {
      var o = a.child;
      i = i.firstContext;
      e: for (; i !== null; ) {
        var s = i;
        i = a;
        for (var l = 0; l < t.length; l++)
          if (s.context === t[l]) {
            i.lanes |= n, s = i.alternate, s !== null && (s.lanes |= n), xm(
              i.return,
              n,
              e
            ), r || (o = null);
            break e;
          }
        i = s.next;
      }
    } else if (a.tag === 18) {
      if (o = a.return, o === null) throw Error(V(341));
      o.lanes |= n, i = o.alternate, i !== null && (i.lanes |= n), xm(o, n, e), o = null;
    } else o = a.child;
    if (o !== null) o.return = a;
    else
      for (o = a; o !== null; ) {
        if (o === e) {
          o = null;
          break;
        }
        if (a = o.sibling, a !== null) {
          a.return = o.return, o = a;
          break;
        }
        o = o.return;
      }
    a = o;
  }
}
function $s(e, t, n, r) {
  e = null;
  for (var a = t, i = !1; a !== null; ) {
    if (!i) {
      if (a.flags & 524288) i = !0;
      else if (a.flags & 262144) break;
    }
    if (a.tag === 10) {
      var o = a.alternate;
      if (o === null) throw Error(V(387));
      if (o = o.memoizedProps, o !== null) {
        var s = a.type;
        wn(a.pendingProps.value, o.value) || (e !== null ? e.push(s) : e = [s]);
      }
    } else if (a === zf.current) {
      if (o = a.alternate, o === null) throw Error(V(387));
      o.memoizedState.memoizedState !== a.memoizedState.memoizedState && (e !== null ? e.push(Ec) : e = [Ec]);
    }
    a = a.return;
  }
  e !== null && Em(
    t,
    e,
    n,
    r
  ), t.flags |= 262144;
}
function Vf(e) {
  for (e = e.firstContext; e !== null; ) {
    if (!wn(
      e.context._currentValue,
      e.memoizedValue
    ))
      return !0;
    e = e.next;
  }
  return !1;
}
function Gi(e) {
  lo = e, Ur = null, e = e.dependencies, e !== null && (e.firstContext = null);
}
function Pt(e) {
  return OT(lo, e);
}
function Lu(e, t) {
  return lo === null && Gi(e), OT(e, t);
}
function OT(e, t) {
  var n = t._currentValue;
  if (t = { context: t, memoizedValue: n, next: null }, Ur === null) {
    if (e === null) throw Error(V(308));
    Ur = t, e.dependencies = { lanes: 0, firstContext: t }, e.flags |= 524288;
  } else Ur = Ur.next = t;
  return n;
}
var ck = typeof AbortController < "u" ? AbortController : function() {
  var e = [], t = this.signal = {
    aborted: !1,
    addEventListener: function(n, r) {
      e.push(r);
    }
  };
  this.abort = function() {
    t.aborted = !0, e.forEach(function(n) {
      return n();
    });
  };
}, uk = St.unstable_scheduleCallback, fk = St.unstable_NormalPriority, mt = {
  $$typeof: Ir,
  Consumer: null,
  Provider: null,
  _currentValue: null,
  _currentValue2: null,
  _threadCount: 0
};
function Iv() {
  return {
    controller: new ck(),
    data: /* @__PURE__ */ new Map(),
    refCount: 0
  };
}
function eu(e) {
  e.refCount--, e.refCount === 0 && uk(fk, function() {
    e.controller.abort();
  });
}
var Yl = null, Sm = 0, As = 0, Jo = null;
function dk(e, t) {
  if (Yl === null) {
    var n = Yl = [];
    Sm = 0, As = cy(), Jo = {
      status: "pending",
      value: void 0,
      then: function(r) {
        n.push(r);
      }
    };
  }
  return Sm++, t.then(y0, y0), t;
}
function y0() {
  if (--Sm === 0 && Yl !== null) {
    Jo !== null && (Jo.status = "fulfilled");
    var e = Yl;
    Yl = null, As = 0, Jo = null;
    for (var t = 0; t < e.length; t++) (0, e[t])();
  }
}
function hk(e, t) {
  var n = [], r = {
    status: "pending",
    value: null,
    reason: null,
    then: function(a) {
      n.push(a);
    }
  };
  return e.then(
    function() {
      r.status = "fulfilled", r.value = t;
      for (var a = 0; a < n.length; a++) (0, n[a])(t);
    },
    function(a) {
      for (r.status = "rejected", r.reason = a, a = 0; a < n.length; a++)
        (0, n[a])(void 0);
    }
  ), r;
}
var b0 = fe.S;
fe.S = function(e, t) {
  UC = mn(), typeof t == "object" && t !== null && typeof t.then == "function" && dk(e, t), b0 !== null && b0(e, t);
};
var Bi = hr(null);
function Fv() {
  var e = Bi.current;
  return e !== null ? e : Fe.pooledCache;
}
function ff(e, t) {
  t === null ? Be(Bi, Bi.current) : Be(Bi, t.pool);
}
function AT() {
  var e = Fv();
  return e === null ? null : { parent: mt._currentValue, pool: e };
}
var Gs = Error(V(460)), Uv = Error(V(474)), Fd = Error(V(542)), Qf = { then: function() {
} };
function w0(e) {
  return e = e.status, e === "fulfilled" || e === "rejected";
}
function RT(e, t, n) {
  switch (n = e[n], n === void 0 ? e.push(t) : n !== t && (t.then(Fr, Fr), t = n), t.status) {
    case "fulfilled":
      return t.value;
    case "rejected":
      throw e = t.reason, E0(e), e;
    default:
      if (typeof t.status == "string") t.then(Fr, Fr);
      else {
        if (e = Fe, e !== null && 100 < e.shellSuspendCounter)
          throw Error(V(482));
        e = t, e.status = "pending", e.then(
          function(r) {
            if (t.status === "pending") {
              var a = t;
              a.status = "fulfilled", a.value = r;
            }
          },
          function(r) {
            if (t.status === "pending") {
              var a = t;
              a.status = "rejected", a.reason = r;
            }
          }
        );
      }
      switch (t.status) {
        case "fulfilled":
          return t.value;
        case "rejected":
          throw e = t.reason, E0(e), e;
      }
      throw Vi = t, Gs;
  }
}
function xi(e) {
  try {
    var t = e._init;
    return t(e._payload);
  } catch (n) {
    throw n !== null && typeof n == "object" && typeof n.then == "function" ? (Vi = n, Gs) : n;
  }
}
var Vi = null;
function x0() {
  if (Vi === null) throw Error(V(459));
  var e = Vi;
  return Vi = null, e;
}
function E0(e) {
  if (e === Gs || e === Fd)
    throw Error(V(483));
}
var es = null, vc = 0;
function zu(e) {
  var t = vc;
  return vc += 1, es === null && (es = []), RT(es, e, t);
}
function pl(e, t) {
  t = t.props.ref, e.ref = t !== void 0 ? t : null;
}
function ju(e, t) {
  throw t.$$typeof === JD ? Error(V(525)) : (e = Object.prototype.toString.call(t), Error(
    V(
      31,
      e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e
    )
  ));
}
function _T(e) {
  function t(p, m) {
    if (e) {
      var w = p.deletions;
      w === null ? (p.deletions = [m], p.flags |= 16) : w.push(m);
    }
  }
  function n(p, m) {
    if (!e) return null;
    for (; m !== null; )
      t(p, m), m = m.sibling;
    return null;
  }
  function r(p) {
    for (var m = /* @__PURE__ */ new Map(); p !== null; )
      p.key !== null ? m.set(p.key, p) : m.set(p.index, p), p = p.sibling;
    return m;
  }
  function a(p, m) {
    return p = qr(p, m), p.index = 0, p.sibling = null, p;
  }
  function i(p, m, w) {
    return p.index = w, e ? (w = p.alternate, w !== null ? (w = w.index, w < m ? (p.flags |= 67108866, m) : w) : (p.flags |= 67108866, m)) : (p.flags |= 1048576, m);
  }
  function o(p) {
    return e && p.alternate === null && (p.flags |= 67108866), p;
  }
  function s(p, m, w, x) {
    return m === null || m.tag !== 6 ? (m = qh(w, p.mode, x), m.return = p, m) : (m = a(m, w), m.return = p, m);
  }
  function l(p, m, w, x) {
    var S = w.type;
    return S === ko ? u(
      p,
      m,
      w.props.children,
      x,
      w.key
    ) : m !== null && (m.elementType === S || typeof S == "object" && S !== null && S.$$typeof === ha && xi(S) === m.type) ? (m = a(m, w.props), pl(m, w), m.return = p, m) : (m = uf(
      w.type,
      w.key,
      w.props,
      null,
      p.mode,
      x
    ), pl(m, w), m.return = p, m);
  }
  function c(p, m, w, x) {
    return m === null || m.tag !== 4 || m.stateNode.containerInfo !== w.containerInfo || m.stateNode.implementation !== w.implementation ? (m = Bh(w, p.mode, x), m.return = p, m) : (m = a(m, w.children || []), m.return = p, m);
  }
  function u(p, m, w, x, S) {
    return m === null || m.tag !== 7 ? (m = qi(
      w,
      p.mode,
      x,
      S
    ), m.return = p, m) : (m = a(m, w), m.return = p, m);
  }
  function f(p, m, w) {
    if (typeof m == "string" && m !== "" || typeof m == "number" || typeof m == "bigint")
      return m = qh(
        "" + m,
        p.mode,
        w
      ), m.return = p, m;
    if (typeof m == "object" && m !== null) {
      switch (m.$$typeof) {
        case Ru:
          return w = uf(
            m.type,
            m.key,
            m.props,
            null,
            p.mode,
            w
          ), pl(w, m), w.return = p, w;
        case kl:
          return m = Bh(
            m,
            p.mode,
            w
          ), m.return = p, m;
        case ha:
          return m = xi(m), f(p, m, w);
      }
      if (Ml(m) || fl(m))
        return m = qi(
          m,
          p.mode,
          w,
          null
        ), m.return = p, m;
      if (typeof m.then == "function")
        return f(p, zu(m), w);
      if (m.$$typeof === Ir)
        return f(
          p,
          Lu(p, m),
          w
        );
      ju(p, m);
    }
    return null;
  }
  function d(p, m, w, x) {
    var S = m !== null ? m.key : null;
    if (typeof w == "string" && w !== "" || typeof w == "number" || typeof w == "bigint")
      return S !== null ? null : s(p, m, "" + w, x);
    if (typeof w == "object" && w !== null) {
      switch (w.$$typeof) {
        case Ru:
          return w.key === S ? l(p, m, w, x) : null;
        case kl:
          return w.key === S ? c(p, m, w, x) : null;
        case ha:
          return w = xi(w), d(p, m, w, x);
      }
      if (Ml(w) || fl(w))
        return S !== null ? null : u(p, m, w, x, null);
      if (typeof w.then == "function")
        return d(
          p,
          m,
          zu(w),
          x
        );
      if (w.$$typeof === Ir)
        return d(
          p,
          m,
          Lu(p, w),
          x
        );
      ju(p, w);
    }
    return null;
  }
  function h(p, m, w, x, S) {
    if (typeof x == "string" && x !== "" || typeof x == "number" || typeof x == "bigint")
      return p = p.get(w) || null, s(m, p, "" + x, S);
    if (typeof x == "object" && x !== null) {
      switch (x.$$typeof) {
        case Ru:
          return p = p.get(
            x.key === null ? w : x.key
          ) || null, l(m, p, x, S);
        case kl:
          return p = p.get(
            x.key === null ? w : x.key
          ) || null, c(m, p, x, S);
        case ha:
          return x = xi(x), h(
            p,
            m,
            w,
            x,
            S
          );
      }
      if (Ml(x) || fl(x))
        return p = p.get(w) || null, u(m, p, x, S, null);
      if (typeof x.then == "function")
        return h(
          p,
          m,
          w,
          zu(x),
          S
        );
      if (x.$$typeof === Ir)
        return h(
          p,
          m,
          w,
          Lu(m, x),
          S
        );
      ju(m, x);
    }
    return null;
  }
  function g(p, m, w, x) {
    for (var S = null, T = null, E = m, O = m = 0, D = null; E !== null && O < w.length; O++) {
      E.index > O ? (D = E, E = null) : D = E.sibling;
      var A = d(
        p,
        E,
        w[O],
        x
      );
      if (A === null) {
        E === null && (E = D);
        break;
      }
      e && E && A.alternate === null && t(p, E), m = i(A, m, O), T === null ? S = A : T.sibling = A, T = A, E = D;
    }
    if (O === w.length)
      return n(p, E), Ae && Lr(p, O), S;
    if (E === null) {
      for (; O < w.length; O++)
        E = f(p, w[O], x), E !== null && (m = i(
          E,
          m,
          O
        ), T === null ? S = E : T.sibling = E, T = E);
      return Ae && Lr(p, O), S;
    }
    for (E = r(E); O < w.length; O++)
      D = h(
        E,
        p,
        O,
        w[O],
        x
      ), D !== null && (e && D.alternate !== null && E.delete(
        D.key === null ? O : D.key
      ), m = i(
        D,
        m,
        O
      ), T === null ? S = D : T.sibling = D, T = D);
    return e && E.forEach(function(U) {
      return t(p, U);
    }), Ae && Lr(p, O), S;
  }
  function v(p, m, w, x) {
    if (w == null) throw Error(V(151));
    for (var S = null, T = null, E = m, O = m = 0, D = null, A = w.next(); E !== null && !A.done; O++, A = w.next()) {
      E.index > O ? (D = E, E = null) : D = E.sibling;
      var U = d(p, E, A.value, x);
      if (U === null) {
        E === null && (E = D);
        break;
      }
      e && E && U.alternate === null && t(p, E), m = i(U, m, O), T === null ? S = U : T.sibling = U, T = U, E = D;
    }
    if (A.done)
      return n(p, E), Ae && Lr(p, O), S;
    if (E === null) {
      for (; !A.done; O++, A = w.next())
        A = f(p, A.value, x), A !== null && (m = i(A, m, O), T === null ? S = A : T.sibling = A, T = A);
      return Ae && Lr(p, O), S;
    }
    for (E = r(E); !A.done; O++, A = w.next())
      A = h(E, p, O, A.value, x), A !== null && (e && A.alternate !== null && E.delete(A.key === null ? O : A.key), m = i(A, m, O), T === null ? S = A : T.sibling = A, T = A);
    return e && E.forEach(function(R) {
      return t(p, R);
    }), Ae && Lr(p, O), S;
  }
  function b(p, m, w, x) {
    if (typeof w == "object" && w !== null && w.type === ko && w.key === null && (w = w.props.children), typeof w == "object" && w !== null) {
      switch (w.$$typeof) {
        case Ru:
          e: {
            for (var S = w.key; m !== null; ) {
              if (m.key === S) {
                if (S = w.type, S === ko) {
                  if (m.tag === 7) {
                    n(
                      p,
                      m.sibling
                    ), x = a(
                      m,
                      w.props.children
                    ), x.return = p, p = x;
                    break e;
                  }
                } else if (m.elementType === S || typeof S == "object" && S !== null && S.$$typeof === ha && xi(S) === m.type) {
                  n(
                    p,
                    m.sibling
                  ), x = a(m, w.props), pl(x, w), x.return = p, p = x;
                  break e;
                }
                n(p, m);
                break;
              } else t(p, m);
              m = m.sibling;
            }
            w.type === ko ? (x = qi(
              w.props.children,
              p.mode,
              x,
              w.key
            ), x.return = p, p = x) : (x = uf(
              w.type,
              w.key,
              w.props,
              null,
              p.mode,
              x
            ), pl(x, w), x.return = p, p = x);
          }
          return o(p);
        case kl:
          e: {
            for (S = w.key; m !== null; ) {
              if (m.key === S)
                if (m.tag === 4 && m.stateNode.containerInfo === w.containerInfo && m.stateNode.implementation === w.implementation) {
                  n(
                    p,
                    m.sibling
                  ), x = a(m, w.children || []), x.return = p, p = x;
                  break e;
                } else {
                  n(p, m);
                  break;
                }
              else t(p, m);
              m = m.sibling;
            }
            x = Bh(w, p.mode, x), x.return = p, p = x;
          }
          return o(p);
        case ha:
          return w = xi(w), b(
            p,
            m,
            w,
            x
          );
      }
      if (Ml(w))
        return g(
          p,
          m,
          w,
          x
        );
      if (fl(w)) {
        if (S = fl(w), typeof S != "function") throw Error(V(150));
        return w = S.call(w), v(
          p,
          m,
          w,
          x
        );
      }
      if (typeof w.then == "function")
        return b(
          p,
          m,
          zu(w),
          x
        );
      if (w.$$typeof === Ir)
        return b(
          p,
          m,
          Lu(p, w),
          x
        );
      ju(p, w);
    }
    return typeof w == "string" && w !== "" || typeof w == "number" || typeof w == "bigint" ? (w = "" + w, m !== null && m.tag === 6 ? (n(p, m.sibling), x = a(m, w), x.return = p, p = x) : (n(p, m), x = qh(w, p.mode, x), x.return = p, p = x), o(p)) : n(p, m);
  }
  return function(p, m, w, x) {
    try {
      vc = 0;
      var S = b(
        p,
        m,
        w,
        x
      );
      return es = null, S;
    } catch (E) {
      if (E === Gs || E === Fd) throw E;
      var T = hn(29, E, null, p.mode);
      return T.lanes = x, T.return = p, T;
    } finally {
    }
  };
}
var Yi = _T(!0), DT = _T(!1), pa = !1;
function qv(e) {
  e.updateQueue = {
    baseState: e.memoizedState,
    firstBaseUpdate: null,
    lastBaseUpdate: null,
    shared: { pending: null, lanes: 0, hiddenCallbacks: null },
    callbacks: null
  };
}
function Tm(e, t) {
  e = e.updateQueue, t.updateQueue === e && (t.updateQueue = {
    baseState: e.baseState,
    firstBaseUpdate: e.firstBaseUpdate,
    lastBaseUpdate: e.lastBaseUpdate,
    shared: e.shared,
    callbacks: null
  });
}
function Ua(e) {
  return { lane: e, tag: 0, payload: null, callback: null, next: null };
}
function qa(e, t, n) {
  var r = e.updateQueue;
  if (r === null) return null;
  if (r = r.shared, _e & 2) {
    var a = r.pending;
    return a === null ? t.next = t : (t.next = a.next, a.next = t), r.pending = t, t = qf(e), xT(e, null, n), t;
  }
  return Id(e, r, t, n), qf(e);
}
function Kl(e, t, n) {
  if (t = t.updateQueue, t !== null && (t = t.shared, (n & 4194048) !== 0)) {
    var r = t.lanes;
    r &= e.pendingLanes, n |= r, t.lanes = n, YS(e, n);
  }
}
function Qh(e, t) {
  var n = e.updateQueue, r = e.alternate;
  if (r !== null && (r = r.updateQueue, n === r)) {
    var a = null, i = null;
    if (n = n.firstBaseUpdate, n !== null) {
      do {
        var o = {
          lane: n.lane,
          tag: n.tag,
          payload: n.payload,
          callback: null,
          next: null
        };
        i === null ? a = i = o : i = i.next = o, n = n.next;
      } while (n !== null);
      i === null ? a = i = t : i = i.next = t;
    } else a = i = t;
    n = {
      baseState: r.baseState,
      firstBaseUpdate: a,
      lastBaseUpdate: i,
      shared: r.shared,
      callbacks: r.callbacks
    }, e.updateQueue = n;
    return;
  }
  e = n.lastBaseUpdate, e === null ? n.firstBaseUpdate = t : e.next = t, n.lastBaseUpdate = t;
}
var Cm = !1;
function Xl() {
  if (Cm) {
    var e = Jo;
    if (e !== null) throw e;
  }
}
function Wl(e, t, n, r) {
  Cm = !1;
  var a = e.updateQueue;
  pa = !1;
  var i = a.firstBaseUpdate, o = a.lastBaseUpdate, s = a.shared.pending;
  if (s !== null) {
    a.shared.pending = null;
    var l = s, c = l.next;
    l.next = null, o === null ? i = c : o.next = c, o = l;
    var u = e.alternate;
    u !== null && (u = u.updateQueue, s = u.lastBaseUpdate, s !== o && (s === null ? u.firstBaseUpdate = c : s.next = c, u.lastBaseUpdate = l));
  }
  if (i !== null) {
    var f = a.baseState;
    o = 0, u = c = l = null, s = i;
    do {
      var d = s.lane & -536870913, h = d !== s.lane;
      if (h ? (Te & d) === d : (r & d) === d) {
        d !== 0 && d === As && (Cm = !0), u !== null && (u = u.next = {
          lane: 0,
          tag: s.tag,
          payload: s.payload,
          callback: null,
          next: null
        });
        e: {
          var g = e, v = s;
          d = t;
          var b = n;
          switch (v.tag) {
            case 1:
              if (g = v.payload, typeof g == "function") {
                f = g.call(b, f, d);
                break e;
              }
              f = g;
              break e;
            case 3:
              g.flags = g.flags & -65537 | 128;
            case 0:
              if (g = v.payload, d = typeof g == "function" ? g.call(b, f, d) : g, d == null) break e;
              f = Xe({}, f, d);
              break e;
            case 2:
              pa = !0;
          }
        }
        d = s.callback, d !== null && (e.flags |= 64, h && (e.flags |= 8192), h = a.callbacks, h === null ? a.callbacks = [d] : h.push(d));
      } else
        h = {
          lane: d,
          tag: s.tag,
          payload: s.payload,
          callback: s.callback,
          next: null
        }, u === null ? (c = u = h, l = f) : u = u.next = h, o |= d;
      if (s = s.next, s === null) {
        if (s = a.shared.pending, s === null)
          break;
        h = s, s = h.next, h.next = null, a.lastBaseUpdate = h, a.shared.pending = null;
      }
    } while (!0);
    u === null && (l = f), a.baseState = l, a.firstBaseUpdate = c, a.lastBaseUpdate = u, i === null && (a.shared.lanes = 0), Ja |= o, e.lanes = o, e.memoizedState = f;
  }
}
function NT(e, t) {
  if (typeof e != "function")
    throw Error(V(191, e));
  e.call(t);
}
function kT(e, t) {
  var n = e.callbacks;
  if (n !== null)
    for (e.callbacks = null, e = 0; e < n.length; e++)
      NT(n[e], t);
}
var Rs = hr(null), Hf = hr(0);
function S0(e, t) {
  e = Yr, Be(Hf, e), Be(Rs, t), Yr = e | t.baseLanes;
}
function Om() {
  Be(Hf, Yr), Be(Rs, Rs.current);
}
function Bv() {
  Yr = Hf.current, Dt(Rs), Dt(Hf);
}
var xn = hr(null), kn = null;
function ba(e) {
  var t = e.alternate;
  Be(lt, lt.current & 1), Be(xn, e), kn === null && (t === null || Rs.current !== null || t.memoizedState !== null) && (kn = e);
}
function Am(e) {
  Be(lt, lt.current), Be(xn, e), kn === null && (kn = e);
}
function MT(e) {
  e.tag === 22 ? (Be(lt, lt.current), Be(xn, e), kn === null && (kn = e)) : wa();
}
function wa() {
  Be(lt, lt.current), Be(xn, xn.current);
}
function fn(e) {
  Dt(xn), kn === e && (kn = null), Dt(lt);
}
var lt = hr(0);
function $f(e) {
  for (var t = e; t !== null; ) {
    if (t.tag === 13) {
      var n = t.memoizedState;
      if (n !== null && (n = n.dehydrated, n === null || $m(n) || Gm(n)))
        return t;
    } else if (t.tag === 19 && (t.memoizedProps.revealOrder === "forwards" || t.memoizedProps.revealOrder === "backwards" || t.memoizedProps.revealOrder === "unstable_legacy-backwards" || t.memoizedProps.revealOrder === "together")) {
      if (t.flags & 128) return t;
    } else if (t.child !== null) {
      t.child.return = t, t = t.child;
      continue;
    }
    if (t === e) break;
    for (; t.sibling === null; ) {
      if (t.return === null || t.return === e) return null;
      t = t.return;
    }
    t.sibling.return = t.return, t = t.sibling;
  }
  return null;
}
var Hr = 0, ge = null, Ie = null, ht = null, Gf = !1, ts = !1, Ki = !1, Yf = 0, yc = 0, ns = null, pk = 0;
function tt() {
  throw Error(V(321));
}
function Vv(e, t) {
  if (t === null) return !1;
  for (var n = 0; n < t.length && n < e.length; n++)
    if (!wn(e[n], t[n])) return !1;
  return !0;
}
function Qv(e, t, n, r, a, i) {
  return Hr = i, ge = t, t.memoizedState = null, t.updateQueue = null, t.lanes = 0, fe.H = e === null || e.memoizedState === null ? uC : ty, Ki = !1, i = n(r, a), Ki = !1, ts && (i = zT(
    t,
    n,
    r,
    a
  )), LT(e), i;
}
function LT(e) {
  fe.H = bc;
  var t = Ie !== null && Ie.next !== null;
  if (Hr = 0, ht = Ie = ge = null, Gf = !1, yc = 0, ns = null, t) throw Error(V(300));
  e === null || gt || (e = e.dependencies, e !== null && Vf(e) && (gt = !0));
}
function zT(e, t, n, r) {
  ge = e;
  var a = 0;
  do {
    if (ts && (ns = null), yc = 0, ts = !1, 25 <= a) throw Error(V(301));
    if (a += 1, ht = Ie = null, e.updateQueue != null) {
      var i = e.updateQueue;
      i.lastEffect = null, i.events = null, i.stores = null, i.memoCache != null && (i.memoCache.index = 0);
    }
    fe.H = fC, i = t(n, r);
  } while (ts);
  return i;
}
function mk() {
  var e = fe.H, t = e.useState()[0];
  return t = typeof t.then == "function" ? tu(t) : t, e = e.useState()[0], (Ie !== null ? Ie.memoizedState : null) !== e && (ge.flags |= 1024), t;
}
function Hv() {
  var e = Yf !== 0;
  return Yf = 0, e;
}
function $v(e, t, n) {
  t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~n;
}
function Gv(e) {
  if (Gf) {
    for (e = e.memoizedState; e !== null; ) {
      var t = e.queue;
      t !== null && (t.pending = null), e = e.next;
    }
    Gf = !1;
  }
  Hr = 0, ht = Ie = ge = null, ts = !1, yc = Yf = 0, ns = null;
}
function Vt() {
  var e = {
    memoizedState: null,
    baseState: null,
    baseQueue: null,
    queue: null,
    next: null
  };
  return ht === null ? ge.memoizedState = ht = e : ht = ht.next = e, ht;
}
function ct() {
  if (Ie === null) {
    var e = ge.alternate;
    e = e !== null ? e.memoizedState : null;
  } else e = Ie.next;
  var t = ht === null ? ge.memoizedState : ht.next;
  if (t !== null)
    ht = t, Ie = e;
  else {
    if (e === null)
      throw ge.alternate === null ? Error(V(467)) : Error(V(310));
    Ie = e, e = {
      memoizedState: Ie.memoizedState,
      baseState: Ie.baseState,
      baseQueue: Ie.baseQueue,
      queue: Ie.queue,
      next: null
    }, ht === null ? ge.memoizedState = ht = e : ht = ht.next = e;
  }
  return ht;
}
function Ud() {
  return { lastEffect: null, events: null, stores: null, memoCache: null };
}
function tu(e) {
  var t = yc;
  return yc += 1, ns === null && (ns = []), e = RT(ns, e, t), t = ge, (ht === null ? t.memoizedState : ht.next) === null && (t = t.alternate, fe.H = t === null || t.memoizedState === null ? uC : ty), e;
}
function qd(e) {
  if (e !== null && typeof e == "object") {
    if (typeof e.then == "function") return tu(e);
    if (e.$$typeof === Ir) return Pt(e);
  }
  throw Error(V(438, String(e)));
}
function Yv(e) {
  var t = null, n = ge.updateQueue;
  if (n !== null && (t = n.memoCache), t == null) {
    var r = ge.alternate;
    r !== null && (r = r.updateQueue, r !== null && (r = r.memoCache, r != null && (t = {
      data: r.data.map(function(a) {
        return a.slice();
      }),
      index: 0
    })));
  }
  if (t == null && (t = { data: [], index: 0 }), n === null && (n = Ud(), ge.updateQueue = n), n.memoCache = t, n = t.data[t.index], n === void 0)
    for (n = t.data[t.index] = Array(e), r = 0; r < e; r++)
      n[r] = eN;
  return t.index++, n;
}
function $r(e, t) {
  return typeof t == "function" ? t(e) : t;
}
function df(e) {
  var t = ct();
  return Kv(t, Ie, e);
}
function Kv(e, t, n) {
  var r = e.queue;
  if (r === null) throw Error(V(311));
  r.lastRenderedReducer = n;
  var a = e.baseQueue, i = r.pending;
  if (i !== null) {
    if (a !== null) {
      var o = a.next;
      a.next = i.next, i.next = o;
    }
    t.baseQueue = a = i, r.pending = null;
  }
  if (i = e.baseState, a === null) e.memoizedState = i;
  else {
    t = a.next;
    var s = o = null, l = null, c = t, u = !1;
    do {
      var f = c.lane & -536870913;
      if (f !== c.lane ? (Te & f) === f : (Hr & f) === f) {
        var d = c.revertLane;
        if (d === 0)
          l !== null && (l = l.next = {
            lane: 0,
            revertLane: 0,
            gesture: null,
            action: c.action,
            hasEagerState: c.hasEagerState,
            eagerState: c.eagerState,
            next: null
          }), f === As && (u = !0);
        else if ((Hr & d) === d) {
          c = c.next, d === As && (u = !0);
          continue;
        } else
          f = {
            lane: 0,
            revertLane: c.revertLane,
            gesture: null,
            action: c.action,
            hasEagerState: c.hasEagerState,
            eagerState: c.eagerState,
            next: null
          }, l === null ? (s = l = f, o = i) : l = l.next = f, ge.lanes |= d, Ja |= d;
        f = c.action, Ki && n(i, f), i = c.hasEagerState ? c.eagerState : n(i, f);
      } else
        d = {
          lane: f,
          revertLane: c.revertLane,
          gesture: c.gesture,
          action: c.action,
          hasEagerState: c.hasEagerState,
          eagerState: c.eagerState,
          next: null
        }, l === null ? (s = l = d, o = i) : l = l.next = d, ge.lanes |= f, Ja |= f;
      c = c.next;
    } while (c !== null && c !== t);
    if (l === null ? o = i : l.next = s, !wn(i, e.memoizedState) && (gt = !0, u && (n = Jo, n !== null)))
      throw n;
    e.memoizedState = i, e.baseState = o, e.baseQueue = l, r.lastRenderedState = i;
  }
  return a === null && (r.lanes = 0), [e.memoizedState, r.dispatch];
}
function Hh(e) {
  var t = ct(), n = t.queue;
  if (n === null) throw Error(V(311));
  n.lastRenderedReducer = e;
  var r = n.dispatch, a = n.pending, i = t.memoizedState;
  if (a !== null) {
    n.pending = null;
    var o = a = a.next;
    do
      i = e(i, o.action), o = o.next;
    while (o !== a);
    wn(i, t.memoizedState) || (gt = !0), t.memoizedState = i, t.baseQueue === null && (t.baseState = i), n.lastRenderedState = i;
  }
  return [i, r];
}
function jT(e, t, n) {
  var r = ge, a = ct(), i = Ae;
  if (i) {
    if (n === void 0) throw Error(V(407));
    n = n();
  } else n = t();
  var o = !wn(
    (Ie || a).memoizedState,
    n
  );
  if (o && (a.memoizedState = n, gt = !0), a = a.queue, Xv(FT.bind(null, r, a, e), [
    e
  ]), a.getSnapshot !== t || o || ht !== null && ht.memoizedState.tag & 1) {
    if (r.flags |= 2048, _s(
      9,
      { destroy: void 0 },
      IT.bind(
        null,
        r,
        a,
        n,
        t
      ),
      null
    ), Fe === null) throw Error(V(349));
    i || Hr & 127 || PT(r, t, n);
  }
  return n;
}
function PT(e, t, n) {
  e.flags |= 16384, e = { getSnapshot: t, value: n }, t = ge.updateQueue, t === null ? (t = Ud(), ge.updateQueue = t, t.stores = [e]) : (n = t.stores, n === null ? t.stores = [e] : n.push(e));
}
function IT(e, t, n, r) {
  t.value = n, t.getSnapshot = r, UT(t) && qT(e);
}
function FT(e, t, n) {
  return n(function() {
    UT(t) && qT(e);
  });
}
function UT(e) {
  var t = e.getSnapshot;
  e = e.value;
  try {
    var n = t();
    return !wn(e, n);
  } catch {
    return !0;
  }
}
function qT(e) {
  var t = so(e, 2);
  t !== null && an(t, e, 2);
}
function Rm(e) {
  var t = Vt();
  if (typeof e == "function") {
    var n = e;
    if (e = n(), Ki) {
      ka(!0);
      try {
        n();
      } finally {
        ka(!1);
      }
    }
  }
  return t.memoizedState = t.baseState = e, t.queue = {
    pending: null,
    lanes: 0,
    dispatch: null,
    lastRenderedReducer: $r,
    lastRenderedState: e
  }, t;
}
function BT(e, t, n, r) {
  return e.baseState = n, Kv(
    e,
    Ie,
    typeof r == "function" ? r : $r
  );
}
function gk(e, t, n, r, a) {
  if (Vd(e)) throw Error(V(485));
  if (e = t.action, e !== null) {
    var i = {
      payload: a,
      action: e,
      next: null,
      isTransition: !0,
      status: "pending",
      value: null,
      reason: null,
      listeners: [],
      then: function(o) {
        i.listeners.push(o);
      }
    };
    fe.T !== null ? n(!0) : i.isTransition = !1, r(i), n = t.pending, n === null ? (i.next = t.pending = i, VT(t, i)) : (i.next = n.next, t.pending = n.next = i);
  }
}
function VT(e, t) {
  var n = t.action, r = t.payload, a = e.state;
  if (t.isTransition) {
    var i = fe.T, o = {};
    fe.T = o;
    try {
      var s = n(a, r), l = fe.S;
      l !== null && l(o, s), T0(e, t, s);
    } catch (c) {
      _m(e, t, c);
    } finally {
      i !== null && o.types !== null && (i.types = o.types), fe.T = i;
    }
  } else
    try {
      i = n(a, r), T0(e, t, i);
    } catch (c) {
      _m(e, t, c);
    }
}
function T0(e, t, n) {
  n !== null && typeof n == "object" && typeof n.then == "function" ? n.then(
    function(r) {
      C0(e, t, r);
    },
    function(r) {
      return _m(e, t, r);
    }
  ) : C0(e, t, n);
}
function C0(e, t, n) {
  t.status = "fulfilled", t.value = n, QT(t), e.state = n, t = e.pending, t !== null && (n = t.next, n === t ? e.pending = null : (n = n.next, t.next = n, VT(e, n)));
}
function _m(e, t, n) {
  var r = e.pending;
  if (e.pending = null, r !== null) {
    r = r.next;
    do
      t.status = "rejected", t.reason = n, QT(t), t = t.next;
    while (t !== r);
  }
  e.action = null;
}
function QT(e) {
  e = e.listeners;
  for (var t = 0; t < e.length; t++) (0, e[t])();
}
function HT(e, t) {
  return t;
}
function O0(e, t) {
  if (Ae) {
    var n = Fe.formState;
    if (n !== null) {
      e: {
        var r = ge;
        if (Ae) {
          if (Ye) {
            t: {
              for (var a = Ye, i = Nn; a.nodeType !== 8; ) {
                if (!i) {
                  a = null;
                  break t;
                }
                if (a = Mn(
                  a.nextSibling
                ), a === null) {
                  a = null;
                  break t;
                }
              }
              i = a.data, a = i === "F!" || i === "F" ? a : null;
            }
            if (a) {
              Ye = Mn(
                a.nextSibling
              ), r = a.data === "F!";
              break e;
            }
          }
          Wa(r);
        }
        r = !1;
      }
      r && (t = n[0]);
    }
  }
  return n = Vt(), n.memoizedState = n.baseState = t, r = {
    pending: null,
    lanes: 0,
    dispatch: null,
    lastRenderedReducer: HT,
    lastRenderedState: t
  }, n.queue = r, n = sC.bind(
    null,
    ge,
    r
  ), r.dispatch = n, r = Rm(!1), i = ey.bind(
    null,
    ge,
    !1,
    r.queue
  ), r = Vt(), a = {
    state: t,
    dispatch: null,
    action: e,
    pending: null
  }, r.queue = a, n = gk.bind(
    null,
    ge,
    a,
    i,
    n
  ), a.dispatch = n, r.memoizedState = e, [t, n, !1];
}
function A0(e) {
  var t = ct();
  return $T(t, Ie, e);
}
function $T(e, t, n) {
  if (t = Kv(
    e,
    t,
    HT
  )[0], e = df($r)[0], typeof t == "object" && t !== null && typeof t.then == "function")
    try {
      var r = tu(t);
    } catch (o) {
      throw o === Gs ? Fd : o;
    }
  else r = t;
  t = ct();
  var a = t.queue, i = a.dispatch;
  return n !== t.memoizedState && (ge.flags |= 2048, _s(
    9,
    { destroy: void 0 },
    vk.bind(null, a, n),
    null
  )), [r, i, e];
}
function vk(e, t) {
  e.action = t;
}
function R0(e) {
  var t = ct(), n = Ie;
  if (n !== null)
    return $T(t, n, e);
  ct(), t = t.memoizedState, n = ct();
  var r = n.queue.dispatch;
  return n.memoizedState = e, [t, r, !1];
}
function _s(e, t, n, r) {
  return e = { tag: e, create: n, deps: r, inst: t, next: null }, t = ge.updateQueue, t === null && (t = Ud(), ge.updateQueue = t), n = t.lastEffect, n === null ? t.lastEffect = e.next = e : (r = n.next, n.next = e, e.next = r, t.lastEffect = e), e;
}
function GT() {
  return ct().memoizedState;
}
function hf(e, t, n, r) {
  var a = Vt();
  ge.flags |= e, a.memoizedState = _s(
    1 | t,
    { destroy: void 0 },
    n,
    r === void 0 ? null : r
  );
}
function Bd(e, t, n, r) {
  var a = ct();
  r = r === void 0 ? null : r;
  var i = a.memoizedState.inst;
  Ie !== null && r !== null && Vv(r, Ie.memoizedState.deps) ? a.memoizedState = _s(t, i, n, r) : (ge.flags |= e, a.memoizedState = _s(
    1 | t,
    i,
    n,
    r
  ));
}
function _0(e, t) {
  hf(8390656, 8, e, t);
}
function Xv(e, t) {
  Bd(2048, 8, e, t);
}
function yk(e) {
  ge.flags |= 4;
  var t = ge.updateQueue;
  if (t === null)
    t = Ud(), ge.updateQueue = t, t.events = [e];
  else {
    var n = t.events;
    n === null ? t.events = [e] : n.push(e);
  }
}
function YT(e) {
  var t = ct().memoizedState;
  return yk({ ref: t, nextImpl: e }), function() {
    if (_e & 2) throw Error(V(440));
    return t.impl.apply(void 0, arguments);
  };
}
function KT(e, t) {
  return Bd(4, 2, e, t);
}
function XT(e, t) {
  return Bd(4, 4, e, t);
}
function WT(e, t) {
  if (typeof t == "function") {
    e = e();
    var n = t(e);
    return function() {
      typeof n == "function" ? n() : t(null);
    };
  }
  if (t != null)
    return e = e(), t.current = e, function() {
      t.current = null;
    };
}
function ZT(e, t, n) {
  n = n != null ? n.concat([e]) : null, Bd(4, 4, WT.bind(null, t, e), n);
}
function Wv() {
}
function JT(e, t) {
  var n = ct();
  t = t === void 0 ? null : t;
  var r = n.memoizedState;
  return t !== null && Vv(t, r[1]) ? r[0] : (n.memoizedState = [e, t], e);
}
function eC(e, t) {
  var n = ct();
  t = t === void 0 ? null : t;
  var r = n.memoizedState;
  if (t !== null && Vv(t, r[1]))
    return r[0];
  if (r = e(), Ki) {
    ka(!0);
    try {
      e();
    } finally {
      ka(!1);
    }
  }
  return n.memoizedState = [r, t], r;
}
function Zv(e, t, n) {
  return n === void 0 || Hr & 1073741824 && !(Te & 261930) ? e.memoizedState = t : (e.memoizedState = n, e = BC(), ge.lanes |= e, Ja |= e, n);
}
function tC(e, t, n, r) {
  return wn(n, t) ? n : Rs.current !== null ? (e = Zv(e, n, r), wn(e, t) || (gt = !0), e) : !(Hr & 42) || Hr & 1073741824 && !(Te & 261930) ? (gt = !0, e.memoizedState = n) : (e = BC(), ge.lanes |= e, Ja |= e, t);
}
function nC(e, t, n, r, a) {
  var i = De.p;
  De.p = i !== 0 && 8 > i ? i : 8;
  var o = fe.T, s = {};
  fe.T = s, ey(e, !1, t, n);
  try {
    var l = a(), c = fe.S;
    if (c !== null && c(s, l), l !== null && typeof l == "object" && typeof l.then == "function") {
      var u = hk(
        l,
        r
      );
      Zl(
        e,
        t,
        u,
        yn(e)
      );
    } else
      Zl(
        e,
        t,
        r,
        yn(e)
      );
  } catch (f) {
    Zl(
      e,
      t,
      { then: function() {
      }, status: "rejected", reason: f },
      yn()
    );
  } finally {
    De.p = i, o !== null && s.types !== null && (o.types = s.types), fe.T = o;
  }
}
function bk() {
}
function Dm(e, t, n, r) {
  if (e.tag !== 5) throw Error(V(476));
  var a = rC(e).queue;
  nC(
    e,
    a,
    t,
    Ui,
    n === null ? bk : function() {
      return aC(e), n(r);
    }
  );
}
function rC(e) {
  var t = e.memoizedState;
  if (t !== null) return t;
  t = {
    memoizedState: Ui,
    baseState: Ui,
    baseQueue: null,
    queue: {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: $r,
      lastRenderedState: Ui
    },
    next: null
  };
  var n = {};
  return t.next = {
    memoizedState: n,
    baseState: n,
    baseQueue: null,
    queue: {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: $r,
      lastRenderedState: n
    },
    next: null
  }, e.memoizedState = t, e = e.alternate, e !== null && (e.memoizedState = t), t;
}
function aC(e) {
  var t = rC(e);
  t.next === null && (t = e.alternate.memoizedState), Zl(
    e,
    t.next.queue,
    {},
    yn()
  );
}
function Jv() {
  return Pt(Ec);
}
function iC() {
  return ct().memoizedState;
}
function oC() {
  return ct().memoizedState;
}
function wk(e) {
  for (var t = e.return; t !== null; ) {
    switch (t.tag) {
      case 24:
      case 3:
        var n = yn();
        e = Ua(n);
        var r = qa(t, e, n);
        r !== null && (an(r, t, n), Kl(r, t, n)), t = { cache: Iv() }, e.payload = t;
        return;
    }
    t = t.return;
  }
}
function xk(e, t, n) {
  var r = yn();
  n = {
    lane: r,
    revertLane: 0,
    gesture: null,
    action: n,
    hasEagerState: !1,
    eagerState: null,
    next: null
  }, Vd(e) ? lC(t, n) : (n = Lv(e, t, n, r), n !== null && (an(n, e, r), cC(n, t, r)));
}
function sC(e, t, n) {
  var r = yn();
  Zl(e, t, n, r);
}
function Zl(e, t, n, r) {
  var a = {
    lane: r,
    revertLane: 0,
    gesture: null,
    action: n,
    hasEagerState: !1,
    eagerState: null,
    next: null
  };
  if (Vd(e)) lC(t, a);
  else {
    var i = e.alternate;
    if (e.lanes === 0 && (i === null || i.lanes === 0) && (i = t.lastRenderedReducer, i !== null))
      try {
        var o = t.lastRenderedState, s = i(o, n);
        if (a.hasEagerState = !0, a.eagerState = s, wn(s, o))
          return Id(e, t, a, 0), Fe === null && Pd(), !1;
      } catch {
      } finally {
      }
    if (n = Lv(e, t, a, r), n !== null)
      return an(n, e, r), cC(n, t, r), !0;
  }
  return !1;
}
function ey(e, t, n, r) {
  if (r = {
    lane: 2,
    revertLane: cy(),
    gesture: null,
    action: r,
    hasEagerState: !1,
    eagerState: null,
    next: null
  }, Vd(e)) {
    if (t) throw Error(V(479));
  } else
    t = Lv(
      e,
      n,
      r,
      2
    ), t !== null && an(t, e, 2);
}
function Vd(e) {
  var t = e.alternate;
  return e === ge || t !== null && t === ge;
}
function lC(e, t) {
  ts = Gf = !0;
  var n = e.pending;
  n === null ? t.next = t : (t.next = n.next, n.next = t), e.pending = t;
}
function cC(e, t, n) {
  if (n & 4194048) {
    var r = t.lanes;
    r &= e.pendingLanes, n |= r, t.lanes = n, YS(e, n);
  }
}
var bc = {
  readContext: Pt,
  use: qd,
  useCallback: tt,
  useContext: tt,
  useEffect: tt,
  useImperativeHandle: tt,
  useLayoutEffect: tt,
  useInsertionEffect: tt,
  useMemo: tt,
  useReducer: tt,
  useRef: tt,
  useState: tt,
  useDebugValue: tt,
  useDeferredValue: tt,
  useTransition: tt,
  useSyncExternalStore: tt,
  useId: tt,
  useHostTransitionStatus: tt,
  useFormState: tt,
  useActionState: tt,
  useOptimistic: tt,
  useMemoCache: tt,
  useCacheRefresh: tt
};
bc.useEffectEvent = tt;
var uC = {
  readContext: Pt,
  use: qd,
  useCallback: function(e, t) {
    return Vt().memoizedState = [
      e,
      t === void 0 ? null : t
    ], e;
  },
  useContext: Pt,
  useEffect: _0,
  useImperativeHandle: function(e, t, n) {
    n = n != null ? n.concat([e]) : null, hf(
      4194308,
      4,
      WT.bind(null, t, e),
      n
    );
  },
  useLayoutEffect: function(e, t) {
    return hf(4194308, 4, e, t);
  },
  useInsertionEffect: function(e, t) {
    hf(4, 2, e, t);
  },
  useMemo: function(e, t) {
    var n = Vt();
    t = t === void 0 ? null : t;
    var r = e();
    if (Ki) {
      ka(!0);
      try {
        e();
      } finally {
        ka(!1);
      }
    }
    return n.memoizedState = [r, t], r;
  },
  useReducer: function(e, t, n) {
    var r = Vt();
    if (n !== void 0) {
      var a = n(t);
      if (Ki) {
        ka(!0);
        try {
          n(t);
        } finally {
          ka(!1);
        }
      }
    } else a = t;
    return r.memoizedState = r.baseState = a, e = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: e,
      lastRenderedState: a
    }, r.queue = e, e = e.dispatch = xk.bind(
      null,
      ge,
      e
    ), [r.memoizedState, e];
  },
  useRef: function(e) {
    var t = Vt();
    return e = { current: e }, t.memoizedState = e;
  },
  useState: function(e) {
    e = Rm(e);
    var t = e.queue, n = sC.bind(null, ge, t);
    return t.dispatch = n, [e.memoizedState, n];
  },
  useDebugValue: Wv,
  useDeferredValue: function(e, t) {
    var n = Vt();
    return Zv(n, e, t);
  },
  useTransition: function() {
    var e = Rm(!1);
    return e = nC.bind(
      null,
      ge,
      e.queue,
      !0,
      !1
    ), Vt().memoizedState = e, [!1, e];
  },
  useSyncExternalStore: function(e, t, n) {
    var r = ge, a = Vt();
    if (Ae) {
      if (n === void 0)
        throw Error(V(407));
      n = n();
    } else {
      if (n = t(), Fe === null)
        throw Error(V(349));
      Te & 127 || PT(r, t, n);
    }
    a.memoizedState = n;
    var i = { value: n, getSnapshot: t };
    return a.queue = i, _0(FT.bind(null, r, i, e), [
      e
    ]), r.flags |= 2048, _s(
      9,
      { destroy: void 0 },
      IT.bind(
        null,
        r,
        i,
        n,
        t
      ),
      null
    ), n;
  },
  useId: function() {
    var e = Vt(), t = Fe.identifierPrefix;
    if (Ae) {
      var n = tr, r = er;
      n = (r & ~(1 << 32 - vn(r) - 1)).toString(32) + n, t = "_" + t + "R_" + n, n = Yf++, 0 < n && (t += "H" + n.toString(32)), t += "_";
    } else
      n = pk++, t = "_" + t + "r_" + n.toString(32) + "_";
    return e.memoizedState = t;
  },
  useHostTransitionStatus: Jv,
  useFormState: O0,
  useActionState: O0,
  useOptimistic: function(e) {
    var t = Vt();
    t.memoizedState = t.baseState = e;
    var n = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: null,
      lastRenderedState: null
    };
    return t.queue = n, t = ey.bind(
      null,
      ge,
      !0,
      n
    ), n.dispatch = t, [e, t];
  },
  useMemoCache: Yv,
  useCacheRefresh: function() {
    return Vt().memoizedState = wk.bind(
      null,
      ge
    );
  },
  useEffectEvent: function(e) {
    var t = Vt(), n = { impl: e };
    return t.memoizedState = n, function() {
      if (_e & 2)
        throw Error(V(440));
      return n.impl.apply(void 0, arguments);
    };
  }
}, ty = {
  readContext: Pt,
  use: qd,
  useCallback: JT,
  useContext: Pt,
  useEffect: Xv,
  useImperativeHandle: ZT,
  useInsertionEffect: KT,
  useLayoutEffect: XT,
  useMemo: eC,
  useReducer: df,
  useRef: GT,
  useState: function() {
    return df($r);
  },
  useDebugValue: Wv,
  useDeferredValue: function(e, t) {
    var n = ct();
    return tC(
      n,
      Ie.memoizedState,
      e,
      t
    );
  },
  useTransition: function() {
    var e = df($r)[0], t = ct().memoizedState;
    return [
      typeof e == "boolean" ? e : tu(e),
      t
    ];
  },
  useSyncExternalStore: jT,
  useId: iC,
  useHostTransitionStatus: Jv,
  useFormState: A0,
  useActionState: A0,
  useOptimistic: function(e, t) {
    var n = ct();
    return BT(n, Ie, e, t);
  },
  useMemoCache: Yv,
  useCacheRefresh: oC
};
ty.useEffectEvent = YT;
var fC = {
  readContext: Pt,
  use: qd,
  useCallback: JT,
  useContext: Pt,
  useEffect: Xv,
  useImperativeHandle: ZT,
  useInsertionEffect: KT,
  useLayoutEffect: XT,
  useMemo: eC,
  useReducer: Hh,
  useRef: GT,
  useState: function() {
    return Hh($r);
  },
  useDebugValue: Wv,
  useDeferredValue: function(e, t) {
    var n = ct();
    return Ie === null ? Zv(n, e, t) : tC(
      n,
      Ie.memoizedState,
      e,
      t
    );
  },
  useTransition: function() {
    var e = Hh($r)[0], t = ct().memoizedState;
    return [
      typeof e == "boolean" ? e : tu(e),
      t
    ];
  },
  useSyncExternalStore: jT,
  useId: iC,
  useHostTransitionStatus: Jv,
  useFormState: R0,
  useActionState: R0,
  useOptimistic: function(e, t) {
    var n = ct();
    return Ie !== null ? BT(n, Ie, e, t) : (n.baseState = e, [e, n.queue.dispatch]);
  },
  useMemoCache: Yv,
  useCacheRefresh: oC
};
fC.useEffectEvent = YT;
function $h(e, t, n, r) {
  t = e.memoizedState, n = n(r, t), n = n == null ? t : Xe({}, t, n), e.memoizedState = n, e.lanes === 0 && (e.updateQueue.baseState = n);
}
var Nm = {
  enqueueSetState: function(e, t, n) {
    e = e._reactInternals;
    var r = yn(), a = Ua(r);
    a.payload = t, n != null && (a.callback = n), t = qa(e, a, r), t !== null && (an(t, e, r), Kl(t, e, r));
  },
  enqueueReplaceState: function(e, t, n) {
    e = e._reactInternals;
    var r = yn(), a = Ua(r);
    a.tag = 1, a.payload = t, n != null && (a.callback = n), t = qa(e, a, r), t !== null && (an(t, e, r), Kl(t, e, r));
  },
  enqueueForceUpdate: function(e, t) {
    e = e._reactInternals;
    var n = yn(), r = Ua(n);
    r.tag = 2, t != null && (r.callback = t), t = qa(e, r, n), t !== null && (an(t, e, n), Kl(t, e, n));
  }
};
function D0(e, t, n, r, a, i, o) {
  return e = e.stateNode, typeof e.shouldComponentUpdate == "function" ? e.shouldComponentUpdate(r, i, o) : t.prototype && t.prototype.isPureReactComponent ? !pc(n, r) || !pc(a, i) : !0;
}
function N0(e, t, n, r) {
  e = t.state, typeof t.componentWillReceiveProps == "function" && t.componentWillReceiveProps(n, r), typeof t.UNSAFE_componentWillReceiveProps == "function" && t.UNSAFE_componentWillReceiveProps(n, r), t.state !== e && Nm.enqueueReplaceState(t, t.state, null);
}
function Xi(e, t) {
  var n = t;
  if ("ref" in t) {
    n = {};
    for (var r in t)
      r !== "ref" && (n[r] = t[r]);
  }
  if (e = e.defaultProps) {
    n === t && (n = Xe({}, n));
    for (var a in e)
      n[a] === void 0 && (n[a] = e[a]);
  }
  return n;
}
function dC(e) {
  Uf(e);
}
function hC(e) {
  console.error(e);
}
function pC(e) {
  Uf(e);
}
function Kf(e, t) {
  try {
    var n = e.onUncaughtError;
    n(t.value, { componentStack: t.stack });
  } catch (r) {
    setTimeout(function() {
      throw r;
    });
  }
}
function k0(e, t, n) {
  try {
    var r = e.onCaughtError;
    r(n.value, {
      componentStack: n.stack,
      errorBoundary: t.tag === 1 ? t.stateNode : null
    });
  } catch (a) {
    setTimeout(function() {
      throw a;
    });
  }
}
function km(e, t, n) {
  return n = Ua(n), n.tag = 3, n.payload = { element: null }, n.callback = function() {
    Kf(e, t);
  }, n;
}
function mC(e) {
  return e = Ua(e), e.tag = 3, e;
}
function gC(e, t, n, r) {
  var a = n.type.getDerivedStateFromError;
  if (typeof a == "function") {
    var i = r.value;
    e.payload = function() {
      return a(i);
    }, e.callback = function() {
      k0(t, n, r);
    };
  }
  var o = n.stateNode;
  o !== null && typeof o.componentDidCatch == "function" && (e.callback = function() {
    k0(t, n, r), typeof a != "function" && (Ba === null ? Ba = /* @__PURE__ */ new Set([this]) : Ba.add(this));
    var s = r.stack;
    this.componentDidCatch(r.value, {
      componentStack: s !== null ? s : ""
    });
  });
}
function Ek(e, t, n, r, a) {
  if (n.flags |= 32768, r !== null && typeof r == "object" && typeof r.then == "function") {
    if (t = n.alternate, t !== null && $s(
      t,
      n,
      a,
      !0
    ), n = xn.current, n !== null) {
      switch (n.tag) {
        case 31:
        case 13:
          return kn === null ? ed() : n.alternate === null && rt === 0 && (rt = 3), n.flags &= -257, n.flags |= 65536, n.lanes = a, r === Qf ? n.flags |= 16384 : (t = n.updateQueue, t === null ? n.updateQueue = /* @__PURE__ */ new Set([r]) : t.add(r), rp(e, r, a)), !1;
        case 22:
          return n.flags |= 65536, r === Qf ? n.flags |= 16384 : (t = n.updateQueue, t === null ? (t = {
            transitions: null,
            markerInstances: null,
            retryQueue: /* @__PURE__ */ new Set([r])
          }, n.updateQueue = t) : (n = t.retryQueue, n === null ? t.retryQueue = /* @__PURE__ */ new Set([r]) : n.add(r)), rp(e, r, a)), !1;
      }
      throw Error(V(435, n.tag));
    }
    return rp(e, r, a), ed(), !1;
  }
  if (Ae)
    return t = xn.current, t !== null ? (!(t.flags & 65536) && (t.flags |= 256), t.flags |= 65536, t.lanes = a, r !== bm && (e = Error(V(422), { cause: r }), gc(Dn(e, n)))) : (r !== bm && (t = Error(V(423), {
      cause: r
    }), gc(
      Dn(t, n)
    )), e = e.current.alternate, e.flags |= 65536, a &= -a, e.lanes |= a, r = Dn(r, n), a = km(
      e.stateNode,
      r,
      a
    ), Qh(e, a), rt !== 4 && (rt = 2)), !1;
  var i = Error(V(520), { cause: r });
  if (i = Dn(i, n), tc === null ? tc = [i] : tc.push(i), rt !== 4 && (rt = 2), t === null) return !0;
  r = Dn(r, n), n = t;
  do {
    switch (n.tag) {
      case 3:
        return n.flags |= 65536, e = a & -a, n.lanes |= e, e = km(n.stateNode, r, e), Qh(n, e), !1;
      case 1:
        if (t = n.type, i = n.stateNode, (n.flags & 128) === 0 && (typeof t.getDerivedStateFromError == "function" || i !== null && typeof i.componentDidCatch == "function" && (Ba === null || !Ba.has(i))))
          return n.flags |= 65536, a &= -a, n.lanes |= a, a = mC(a), gC(
            a,
            e,
            n,
            r
          ), Qh(n, a), !1;
    }
    n = n.return;
  } while (n !== null);
  return !1;
}
var ny = Error(V(461)), gt = !1;
function Mt(e, t, n, r) {
  t.child = e === null ? DT(t, null, n, r) : Yi(
    t,
    e.child,
    n,
    r
  );
}
function M0(e, t, n, r, a) {
  n = n.render;
  var i = t.ref;
  if ("ref" in r) {
    var o = {};
    for (var s in r)
      s !== "ref" && (o[s] = r[s]);
  } else o = r;
  return Gi(t), r = Qv(
    e,
    t,
    n,
    o,
    i,
    a
  ), s = Hv(), e !== null && !gt ? ($v(e, t, a), Gr(e, t, a)) : (Ae && s && jv(t), t.flags |= 1, Mt(e, t, r, a), t.child);
}
function L0(e, t, n, r, a) {
  if (e === null) {
    var i = n.type;
    return typeof i == "function" && !zv(i) && i.defaultProps === void 0 && n.compare === null ? (t.tag = 15, t.type = i, vC(
      e,
      t,
      i,
      r,
      a
    )) : (e = uf(
      n.type,
      null,
      r,
      t,
      t.mode,
      a
    ), e.ref = t.ref, e.return = t, t.child = e);
  }
  if (i = e.child, !ry(e, a)) {
    var o = i.memoizedProps;
    if (n = n.compare, n = n !== null ? n : pc, n(o, r) && e.ref === t.ref)
      return Gr(e, t, a);
  }
  return t.flags |= 1, e = qr(i, r), e.ref = t.ref, e.return = t, t.child = e;
}
function vC(e, t, n, r, a) {
  if (e !== null) {
    var i = e.memoizedProps;
    if (pc(i, r) && e.ref === t.ref)
      if (gt = !1, t.pendingProps = r = i, ry(e, a))
        e.flags & 131072 && (gt = !0);
      else
        return t.lanes = e.lanes, Gr(e, t, a);
  }
  return Mm(
    e,
    t,
    n,
    r,
    a
  );
}
function yC(e, t, n, r) {
  var a = r.children, i = e !== null ? e.memoizedState : null;
  if (e === null && t.stateNode === null && (t.stateNode = {
    _visibility: 1,
    _pendingMarkers: null,
    _retryCache: null,
    _transitions: null
  }), r.mode === "hidden") {
    if (t.flags & 128) {
      if (i = i !== null ? i.baseLanes | n : n, e !== null) {
        for (r = t.child = e.child, a = 0; r !== null; )
          a = a | r.lanes | r.childLanes, r = r.sibling;
        r = a & ~i;
      } else r = 0, t.child = null;
      return z0(
        e,
        t,
        i,
        n,
        r
      );
    }
    if (n & 536870912)
      t.memoizedState = { baseLanes: 0, cachePool: null }, e !== null && ff(
        t,
        i !== null ? i.cachePool : null
      ), i !== null ? S0(t, i) : Om(), MT(t);
    else
      return r = t.lanes = 536870912, z0(
        e,
        t,
        i !== null ? i.baseLanes | n : n,
        n,
        r
      );
  } else
    i !== null ? (ff(t, i.cachePool), S0(t, i), wa(), t.memoizedState = null) : (e !== null && ff(t, null), Om(), wa());
  return Mt(e, t, a, n), t.child;
}
function zl(e, t) {
  return e !== null && e.tag === 22 || t.stateNode !== null || (t.stateNode = {
    _visibility: 1,
    _pendingMarkers: null,
    _retryCache: null,
    _transitions: null
  }), t.sibling;
}
function z0(e, t, n, r, a) {
  var i = Fv();
  return i = i === null ? null : { parent: mt._currentValue, pool: i }, t.memoizedState = {
    baseLanes: n,
    cachePool: i
  }, e !== null && ff(t, null), Om(), MT(t), e !== null && $s(e, t, r, !0), t.childLanes = a, null;
}
function pf(e, t) {
  return t = Xf(
    { mode: t.mode, children: t.children },
    e.mode
  ), t.ref = e.ref, e.child = t, t.return = e, t;
}
function j0(e, t, n) {
  return Yi(t, e.child, null, n), e = pf(t, t.pendingProps), e.flags |= 2, fn(t), t.memoizedState = null, e;
}
function Sk(e, t, n) {
  var r = t.pendingProps, a = (t.flags & 128) !== 0;
  if (t.flags &= -129, e === null) {
    if (Ae) {
      if (r.mode === "hidden")
        return e = pf(t, r), t.lanes = 536870912, zl(null, e);
      if (Am(t), (e = Ye) ? (e = uO(
        e,
        Nn
      ), e = e !== null && e.data === "&" ? e : null, e !== null && (t.memoizedState = {
        dehydrated: e,
        treeContext: Xa !== null ? { id: er, overflow: tr } : null,
        retryLane: 536870912,
        hydrationErrors: null
      }, n = ST(e), n.return = t, t.child = n, jt = t, Ye = null)) : e = null, e === null) throw Wa(t);
      return t.lanes = 536870912, null;
    }
    return pf(t, r);
  }
  var i = e.memoizedState;
  if (i !== null) {
    var o = i.dehydrated;
    if (Am(t), a)
      if (t.flags & 256)
        t.flags &= -257, t = j0(
          e,
          t,
          n
        );
      else if (t.memoizedState !== null)
        t.child = e.child, t.flags |= 128, t = null;
      else throw Error(V(558));
    else if (gt || $s(e, t, n, !1), a = (n & e.childLanes) !== 0, gt || a) {
      if (r = Fe, r !== null && (o = KS(r, n), o !== 0 && o !== i.retryLane))
        throw i.retryLane = o, so(e, o), an(r, e, o), ny;
      ed(), t = j0(
        e,
        t,
        n
      );
    } else
      e = i.treeContext, Ye = Mn(o.nextSibling), jt = t, Ae = !0, Fa = null, Nn = !1, e !== null && CT(t, e), t = pf(t, r), t.flags |= 4096;
    return t;
  }
  return e = qr(e.child, {
    mode: r.mode,
    children: r.children
  }), e.ref = t.ref, t.child = e, e.return = t, e;
}
function mf(e, t) {
  var n = t.ref;
  if (n === null)
    e !== null && e.ref !== null && (t.flags |= 4194816);
  else {
    if (typeof n != "function" && typeof n != "object")
      throw Error(V(284));
    (e === null || e.ref !== n) && (t.flags |= 4194816);
  }
}
function Mm(e, t, n, r, a) {
  return Gi(t), n = Qv(
    e,
    t,
    n,
    r,
    void 0,
    a
  ), r = Hv(), e !== null && !gt ? ($v(e, t, a), Gr(e, t, a)) : (Ae && r && jv(t), t.flags |= 1, Mt(e, t, n, a), t.child);
}
function P0(e, t, n, r, a, i) {
  return Gi(t), t.updateQueue = null, n = zT(
    t,
    r,
    n,
    a
  ), LT(e), r = Hv(), e !== null && !gt ? ($v(e, t, i), Gr(e, t, i)) : (Ae && r && jv(t), t.flags |= 1, Mt(e, t, n, i), t.child);
}
function I0(e, t, n, r, a) {
  if (Gi(t), t.stateNode === null) {
    var i = Uo, o = n.contextType;
    typeof o == "object" && o !== null && (i = Pt(o)), i = new n(r, i), t.memoizedState = i.state !== null && i.state !== void 0 ? i.state : null, i.updater = Nm, t.stateNode = i, i._reactInternals = t, i = t.stateNode, i.props = r, i.state = t.memoizedState, i.refs = {}, qv(t), o = n.contextType, i.context = typeof o == "object" && o !== null ? Pt(o) : Uo, i.state = t.memoizedState, o = n.getDerivedStateFromProps, typeof o == "function" && ($h(
      t,
      n,
      o,
      r
    ), i.state = t.memoizedState), typeof n.getDerivedStateFromProps == "function" || typeof i.getSnapshotBeforeUpdate == "function" || typeof i.UNSAFE_componentWillMount != "function" && typeof i.componentWillMount != "function" || (o = i.state, typeof i.componentWillMount == "function" && i.componentWillMount(), typeof i.UNSAFE_componentWillMount == "function" && i.UNSAFE_componentWillMount(), o !== i.state && Nm.enqueueReplaceState(i, i.state, null), Wl(t, r, i, a), Xl(), i.state = t.memoizedState), typeof i.componentDidMount == "function" && (t.flags |= 4194308), r = !0;
  } else if (e === null) {
    i = t.stateNode;
    var s = t.memoizedProps, l = Xi(n, s);
    i.props = l;
    var c = i.context, u = n.contextType;
    o = Uo, typeof u == "object" && u !== null && (o = Pt(u));
    var f = n.getDerivedStateFromProps;
    u = typeof f == "function" || typeof i.getSnapshotBeforeUpdate == "function", s = t.pendingProps !== s, u || typeof i.UNSAFE_componentWillReceiveProps != "function" && typeof i.componentWillReceiveProps != "function" || (s || c !== o) && N0(
      t,
      i,
      r,
      o
    ), pa = !1;
    var d = t.memoizedState;
    i.state = d, Wl(t, r, i, a), Xl(), c = t.memoizedState, s || d !== c || pa ? (typeof f == "function" && ($h(
      t,
      n,
      f,
      r
    ), c = t.memoizedState), (l = pa || D0(
      t,
      n,
      l,
      r,
      d,
      c,
      o
    )) ? (u || typeof i.UNSAFE_componentWillMount != "function" && typeof i.componentWillMount != "function" || (typeof i.componentWillMount == "function" && i.componentWillMount(), typeof i.UNSAFE_componentWillMount == "function" && i.UNSAFE_componentWillMount()), typeof i.componentDidMount == "function" && (t.flags |= 4194308)) : (typeof i.componentDidMount == "function" && (t.flags |= 4194308), t.memoizedProps = r, t.memoizedState = c), i.props = r, i.state = c, i.context = o, r = l) : (typeof i.componentDidMount == "function" && (t.flags |= 4194308), r = !1);
  } else {
    i = t.stateNode, Tm(e, t), o = t.memoizedProps, u = Xi(n, o), i.props = u, f = t.pendingProps, d = i.context, c = n.contextType, l = Uo, typeof c == "object" && c !== null && (l = Pt(c)), s = n.getDerivedStateFromProps, (c = typeof s == "function" || typeof i.getSnapshotBeforeUpdate == "function") || typeof i.UNSAFE_componentWillReceiveProps != "function" && typeof i.componentWillReceiveProps != "function" || (o !== f || d !== l) && N0(
      t,
      i,
      r,
      l
    ), pa = !1, d = t.memoizedState, i.state = d, Wl(t, r, i, a), Xl();
    var h = t.memoizedState;
    o !== f || d !== h || pa || e !== null && e.dependencies !== null && Vf(e.dependencies) ? (typeof s == "function" && ($h(
      t,
      n,
      s,
      r
    ), h = t.memoizedState), (u = pa || D0(
      t,
      n,
      u,
      r,
      d,
      h,
      l
    ) || e !== null && e.dependencies !== null && Vf(e.dependencies)) ? (c || typeof i.UNSAFE_componentWillUpdate != "function" && typeof i.componentWillUpdate != "function" || (typeof i.componentWillUpdate == "function" && i.componentWillUpdate(r, h, l), typeof i.UNSAFE_componentWillUpdate == "function" && i.UNSAFE_componentWillUpdate(
      r,
      h,
      l
    )), typeof i.componentDidUpdate == "function" && (t.flags |= 4), typeof i.getSnapshotBeforeUpdate == "function" && (t.flags |= 1024)) : (typeof i.componentDidUpdate != "function" || o === e.memoizedProps && d === e.memoizedState || (t.flags |= 4), typeof i.getSnapshotBeforeUpdate != "function" || o === e.memoizedProps && d === e.memoizedState || (t.flags |= 1024), t.memoizedProps = r, t.memoizedState = h), i.props = r, i.state = h, i.context = l, r = u) : (typeof i.componentDidUpdate != "function" || o === e.memoizedProps && d === e.memoizedState || (t.flags |= 4), typeof i.getSnapshotBeforeUpdate != "function" || o === e.memoizedProps && d === e.memoizedState || (t.flags |= 1024), r = !1);
  }
  return i = r, mf(e, t), r = (t.flags & 128) !== 0, i || r ? (i = t.stateNode, n = r && typeof n.getDerivedStateFromError != "function" ? null : i.render(), t.flags |= 1, e !== null && r ? (t.child = Yi(
    t,
    e.child,
    null,
    a
  ), t.child = Yi(
    t,
    null,
    n,
    a
  )) : Mt(e, t, n, a), t.memoizedState = i.state, e = t.child) : e = Gr(
    e,
    t,
    a
  ), e;
}
function F0(e, t, n, r) {
  return $i(), t.flags |= 256, Mt(e, t, n, r), t.child;
}
var Gh = {
  dehydrated: null,
  treeContext: null,
  retryLane: 0,
  hydrationErrors: null
};
function Yh(e) {
  return { baseLanes: e, cachePool: AT() };
}
function Kh(e, t, n) {
  return e = e !== null ? e.childLanes & ~n : 0, t && (e |= pn), e;
}
function bC(e, t, n) {
  var r = t.pendingProps, a = !1, i = (t.flags & 128) !== 0, o;
  if ((o = i) || (o = e !== null && e.memoizedState === null ? !1 : (lt.current & 2) !== 0), o && (a = !0, t.flags &= -129), o = (t.flags & 32) !== 0, t.flags &= -33, e === null) {
    if (Ae) {
      if (a ? ba(t) : wa(), (e = Ye) ? (e = uO(
        e,
        Nn
      ), e = e !== null && e.data !== "&" ? e : null, e !== null && (t.memoizedState = {
        dehydrated: e,
        treeContext: Xa !== null ? { id: er, overflow: tr } : null,
        retryLane: 536870912,
        hydrationErrors: null
      }, n = ST(e), n.return = t, t.child = n, jt = t, Ye = null)) : e = null, e === null) throw Wa(t);
      return Gm(e) ? t.lanes = 32 : t.lanes = 536870912, null;
    }
    var s = r.children;
    return r = r.fallback, a ? (wa(), a = t.mode, s = Xf(
      { mode: "hidden", children: s },
      a
    ), r = qi(
      r,
      a,
      n,
      null
    ), s.return = t, r.return = t, s.sibling = r, t.child = s, r = t.child, r.memoizedState = Yh(n), r.childLanes = Kh(
      e,
      o,
      n
    ), t.memoizedState = Gh, zl(null, r)) : (ba(t), Lm(t, s));
  }
  var l = e.memoizedState;
  if (l !== null && (s = l.dehydrated, s !== null)) {
    if (i)
      t.flags & 256 ? (ba(t), t.flags &= -257, t = Xh(
        e,
        t,
        n
      )) : t.memoizedState !== null ? (wa(), t.child = e.child, t.flags |= 128, t = null) : (wa(), s = r.fallback, a = t.mode, r = Xf(
        { mode: "visible", children: r.children },
        a
      ), s = qi(
        s,
        a,
        n,
        null
      ), s.flags |= 2, r.return = t, s.return = t, r.sibling = s, t.child = r, Yi(
        t,
        e.child,
        null,
        n
      ), r = t.child, r.memoizedState = Yh(n), r.childLanes = Kh(
        e,
        o,
        n
      ), t.memoizedState = Gh, t = zl(null, r));
    else if (ba(t), Gm(s)) {
      if (o = s.nextSibling && s.nextSibling.dataset, o) var c = o.dgst;
      o = c, r = Error(V(419)), r.stack = "", r.digest = o, gc({ value: r, source: null, stack: null }), t = Xh(
        e,
        t,
        n
      );
    } else if (gt || $s(e, t, n, !1), o = (n & e.childLanes) !== 0, gt || o) {
      if (o = Fe, o !== null && (r = KS(o, n), r !== 0 && r !== l.retryLane))
        throw l.retryLane = r, so(e, r), an(o, e, r), ny;
      $m(s) || ed(), t = Xh(
        e,
        t,
        n
      );
    } else
      $m(s) ? (t.flags |= 192, t.child = e.child, t = null) : (e = l.treeContext, Ye = Mn(
        s.nextSibling
      ), jt = t, Ae = !0, Fa = null, Nn = !1, e !== null && CT(t, e), t = Lm(
        t,
        r.children
      ), t.flags |= 4096);
    return t;
  }
  return a ? (wa(), s = r.fallback, a = t.mode, l = e.child, c = l.sibling, r = qr(l, {
    mode: "hidden",
    children: r.children
  }), r.subtreeFlags = l.subtreeFlags & 65011712, c !== null ? s = qr(
    c,
    s
  ) : (s = qi(
    s,
    a,
    n,
    null
  ), s.flags |= 2), s.return = t, r.return = t, r.sibling = s, t.child = r, zl(null, r), r = t.child, s = e.child.memoizedState, s === null ? s = Yh(n) : (a = s.cachePool, a !== null ? (l = mt._currentValue, a = a.parent !== l ? { parent: l, pool: l } : a) : a = AT(), s = {
    baseLanes: s.baseLanes | n,
    cachePool: a
  }), r.memoizedState = s, r.childLanes = Kh(
    e,
    o,
    n
  ), t.memoizedState = Gh, zl(e.child, r)) : (ba(t), n = e.child, e = n.sibling, n = qr(n, {
    mode: "visible",
    children: r.children
  }), n.return = t, n.sibling = null, e !== null && (o = t.deletions, o === null ? (t.deletions = [e], t.flags |= 16) : o.push(e)), t.child = n, t.memoizedState = null, n);
}
function Lm(e, t) {
  return t = Xf(
    { mode: "visible", children: t },
    e.mode
  ), t.return = e, e.child = t;
}
function Xf(e, t) {
  return e = hn(22, e, null, t), e.lanes = 0, e;
}
function Xh(e, t, n) {
  return Yi(t, e.child, null, n), e = Lm(
    t,
    t.pendingProps.children
  ), e.flags |= 2, t.memoizedState = null, e;
}
function U0(e, t, n) {
  e.lanes |= t;
  var r = e.alternate;
  r !== null && (r.lanes |= t), xm(e.return, t, n);
}
function Wh(e, t, n, r, a, i) {
  var o = e.memoizedState;
  o === null ? e.memoizedState = {
    isBackwards: t,
    rendering: null,
    renderingStartTime: 0,
    last: r,
    tail: n,
    tailMode: a,
    treeForkCount: i
  } : (o.isBackwards = t, o.rendering = null, o.renderingStartTime = 0, o.last = r, o.tail = n, o.tailMode = a, o.treeForkCount = i);
}
function wC(e, t, n) {
  var r = t.pendingProps, a = r.revealOrder, i = r.tail;
  r = r.children;
  var o = lt.current, s = (o & 2) !== 0;
  if (s ? (o = o & 1 | 2, t.flags |= 128) : o &= 1, Be(lt, o), Mt(e, t, r, n), r = Ae ? mc : 0, !s && e !== null && e.flags & 128)
    e: for (e = t.child; e !== null; ) {
      if (e.tag === 13)
        e.memoizedState !== null && U0(e, n, t);
      else if (e.tag === 19)
        U0(e, n, t);
      else if (e.child !== null) {
        e.child.return = e, e = e.child;
        continue;
      }
      if (e === t) break e;
      for (; e.sibling === null; ) {
        if (e.return === null || e.return === t)
          break e;
        e = e.return;
      }
      e.sibling.return = e.return, e = e.sibling;
    }
  switch (a) {
    case "forwards":
      for (n = t.child, a = null; n !== null; )
        e = n.alternate, e !== null && $f(e) === null && (a = n), n = n.sibling;
      n = a, n === null ? (a = t.child, t.child = null) : (a = n.sibling, n.sibling = null), Wh(
        t,
        !1,
        a,
        n,
        i,
        r
      );
      break;
    case "backwards":
    case "unstable_legacy-backwards":
      for (n = null, a = t.child, t.child = null; a !== null; ) {
        if (e = a.alternate, e !== null && $f(e) === null) {
          t.child = a;
          break;
        }
        e = a.sibling, a.sibling = n, n = a, a = e;
      }
      Wh(
        t,
        !0,
        n,
        null,
        i,
        r
      );
      break;
    case "together":
      Wh(
        t,
        !1,
        null,
        null,
        void 0,
        r
      );
      break;
    default:
      t.memoizedState = null;
  }
  return t.child;
}
function Gr(e, t, n) {
  if (e !== null && (t.dependencies = e.dependencies), Ja |= t.lanes, !(n & t.childLanes))
    if (e !== null) {
      if ($s(
        e,
        t,
        n,
        !1
      ), (n & t.childLanes) === 0)
        return null;
    } else return null;
  if (e !== null && t.child !== e.child)
    throw Error(V(153));
  if (t.child !== null) {
    for (e = t.child, n = qr(e, e.pendingProps), t.child = n, n.return = t; e.sibling !== null; )
      e = e.sibling, n = n.sibling = qr(e, e.pendingProps), n.return = t;
    n.sibling = null;
  }
  return t.child;
}
function ry(e, t) {
  return e.lanes & t ? !0 : (e = e.dependencies, !!(e !== null && Vf(e)));
}
function Tk(e, t, n) {
  switch (t.tag) {
    case 3:
      jf(t, t.stateNode.containerInfo), ya(t, mt, e.memoizedState.cache), $i();
      break;
    case 27:
    case 5:
      lm(t);
      break;
    case 4:
      jf(t, t.stateNode.containerInfo);
      break;
    case 10:
      ya(
        t,
        t.type,
        t.memoizedProps.value
      );
      break;
    case 31:
      if (t.memoizedState !== null)
        return t.flags |= 128, Am(t), null;
      break;
    case 13:
      var r = t.memoizedState;
      if (r !== null)
        return r.dehydrated !== null ? (ba(t), t.flags |= 128, null) : n & t.child.childLanes ? bC(e, t, n) : (ba(t), e = Gr(
          e,
          t,
          n
        ), e !== null ? e.sibling : null);
      ba(t);
      break;
    case 19:
      var a = (e.flags & 128) !== 0;
      if (r = (n & t.childLanes) !== 0, r || ($s(
        e,
        t,
        n,
        !1
      ), r = (n & t.childLanes) !== 0), a) {
        if (r)
          return wC(
            e,
            t,
            n
          );
        t.flags |= 128;
      }
      if (a = t.memoizedState, a !== null && (a.rendering = null, a.tail = null, a.lastEffect = null), Be(lt, lt.current), r) break;
      return null;
    case 22:
      return t.lanes = 0, yC(
        e,
        t,
        n,
        t.pendingProps
      );
    case 24:
      ya(t, mt, e.memoizedState.cache);
  }
  return Gr(e, t, n);
}
function xC(e, t, n) {
  if (e !== null)
    if (e.memoizedProps !== t.pendingProps)
      gt = !0;
    else {
      if (!ry(e, n) && !(t.flags & 128))
        return gt = !1, Tk(
          e,
          t,
          n
        );
      gt = !!(e.flags & 131072);
    }
  else
    gt = !1, Ae && t.flags & 1048576 && TT(t, mc, t.index);
  switch (t.lanes = 0, t.tag) {
    case 16:
      e: {
        var r = t.pendingProps;
        if (e = xi(t.elementType), t.type = e, typeof e == "function")
          zv(e) ? (r = Xi(e, r), t.tag = 1, t = I0(
            null,
            t,
            e,
            r,
            n
          )) : (t.tag = 0, t = Mm(
            null,
            t,
            e,
            r,
            n
          ));
        else {
          if (e != null) {
            var a = e.$$typeof;
            if (a === xv) {
              t.tag = 11, t = M0(
                null,
                t,
                e,
                r,
                n
              );
              break e;
            } else if (a === Ev) {
              t.tag = 14, t = L0(
                null,
                t,
                e,
                r,
                n
              );
              break e;
            }
          }
          throw t = om(e) || e, Error(V(306, t, ""));
        }
      }
      return t;
    case 0:
      return Mm(
        e,
        t,
        t.type,
        t.pendingProps,
        n
      );
    case 1:
      return r = t.type, a = Xi(
        r,
        t.pendingProps
      ), I0(
        e,
        t,
        r,
        a,
        n
      );
    case 3:
      e: {
        if (jf(
          t,
          t.stateNode.containerInfo
        ), e === null) throw Error(V(387));
        r = t.pendingProps;
        var i = t.memoizedState;
        a = i.element, Tm(e, t), Wl(t, r, null, n);
        var o = t.memoizedState;
        if (r = o.cache, ya(t, mt, r), r !== i.cache && Em(
          t,
          [mt],
          n,
          !0
        ), Xl(), r = o.element, i.isDehydrated)
          if (i = {
            element: r,
            isDehydrated: !1,
            cache: o.cache
          }, t.updateQueue.baseState = i, t.memoizedState = i, t.flags & 256) {
            t = F0(
              e,
              t,
              r,
              n
            );
            break e;
          } else if (r !== a) {
            a = Dn(
              Error(V(424)),
              t
            ), gc(a), t = F0(
              e,
              t,
              r,
              n
            );
            break e;
          } else {
            switch (e = t.stateNode.containerInfo, e.nodeType) {
              case 9:
                e = e.body;
                break;
              default:
                e = e.nodeName === "HTML" ? e.ownerDocument.body : e;
            }
            for (Ye = Mn(e.firstChild), jt = t, Ae = !0, Fa = null, Nn = !0, n = DT(
              t,
              null,
              r,
              n
            ), t.child = n; n; )
              n.flags = n.flags & -3 | 4096, n = n.sibling;
          }
        else {
          if ($i(), r === a) {
            t = Gr(
              e,
              t,
              n
            );
            break e;
          }
          Mt(e, t, r, n);
        }
        t = t.child;
      }
      return t;
    case 26:
      return mf(e, t), e === null ? (n = ow(
        t.type,
        null,
        t.pendingProps,
        null
      )) ? t.memoizedState = n : Ae || (n = t.type, e = t.pendingProps, r = ad(
        Ia.current
      ).createElement(n), r[zt] = t, r[on] = e, It(r, n, e), _t(r), t.stateNode = r) : t.memoizedState = ow(
        t.type,
        e.memoizedProps,
        t.pendingProps,
        e.memoizedState
      ), null;
    case 27:
      return lm(t), e === null && Ae && (r = t.stateNode = fO(
        t.type,
        t.pendingProps,
        Ia.current
      ), jt = t, Nn = !0, a = Ye, ui(t.type) ? (Ym = a, Ye = Mn(r.firstChild)) : Ye = a), Mt(
        e,
        t,
        t.pendingProps.children,
        n
      ), mf(e, t), e === null && (t.flags |= 4194304), t.child;
    case 5:
      return e === null && Ae && ((a = r = Ye) && (r = eM(
        r,
        t.type,
        t.pendingProps,
        Nn
      ), r !== null ? (t.stateNode = r, jt = t, Ye = Mn(r.firstChild), Nn = !1, a = !0) : a = !1), a || Wa(t)), lm(t), a = t.type, i = t.pendingProps, o = e !== null ? e.memoizedProps : null, r = i.children, Qm(a, i) ? r = null : o !== null && Qm(a, o) && (t.flags |= 32), t.memoizedState !== null && (a = Qv(
        e,
        t,
        mk,
        null,
        null,
        n
      ), Ec._currentValue = a), mf(e, t), Mt(e, t, r, n), t.child;
    case 6:
      return e === null && Ae && ((e = n = Ye) && (n = tM(
        n,
        t.pendingProps,
        Nn
      ), n !== null ? (t.stateNode = n, jt = t, Ye = null, e = !0) : e = !1), e || Wa(t)), null;
    case 13:
      return bC(e, t, n);
    case 4:
      return jf(
        t,
        t.stateNode.containerInfo
      ), r = t.pendingProps, e === null ? t.child = Yi(
        t,
        null,
        r,
        n
      ) : Mt(e, t, r, n), t.child;
    case 11:
      return M0(
        e,
        t,
        t.type,
        t.pendingProps,
        n
      );
    case 7:
      return Mt(
        e,
        t,
        t.pendingProps,
        n
      ), t.child;
    case 8:
      return Mt(
        e,
        t,
        t.pendingProps.children,
        n
      ), t.child;
    case 12:
      return Mt(
        e,
        t,
        t.pendingProps.children,
        n
      ), t.child;
    case 10:
      return r = t.pendingProps, ya(t, t.type, r.value), Mt(e, t, r.children, n), t.child;
    case 9:
      return a = t.type._context, r = t.pendingProps.children, Gi(t), a = Pt(a), r = r(a), t.flags |= 1, Mt(e, t, r, n), t.child;
    case 14:
      return L0(
        e,
        t,
        t.type,
        t.pendingProps,
        n
      );
    case 15:
      return vC(
        e,
        t,
        t.type,
        t.pendingProps,
        n
      );
    case 19:
      return wC(e, t, n);
    case 31:
      return Sk(e, t, n);
    case 22:
      return yC(
        e,
        t,
        n,
        t.pendingProps
      );
    case 24:
      return Gi(t), r = Pt(mt), e === null ? (a = Fv(), a === null && (a = Fe, i = Iv(), a.pooledCache = i, i.refCount++, i !== null && (a.pooledCacheLanes |= n), a = i), t.memoizedState = { parent: r, cache: a }, qv(t), ya(t, mt, a)) : (e.lanes & n && (Tm(e, t), Wl(t, null, null, n), Xl()), a = e.memoizedState, i = t.memoizedState, a.parent !== r ? (a = { parent: r, cache: r }, t.memoizedState = a, t.lanes === 0 && (t.memoizedState = t.updateQueue.baseState = a), ya(t, mt, r)) : (r = i.cache, ya(t, mt, r), r !== a.cache && Em(
        t,
        [mt],
        n,
        !0
      ))), Mt(
        e,
        t,
        t.pendingProps.children,
        n
      ), t.child;
    case 29:
      throw t.pendingProps;
  }
  throw Error(V(156, t.tag));
}
function Cr(e) {
  e.flags |= 4;
}
function Zh(e, t, n, r, a) {
  if ((t = (e.mode & 32) !== 0) && (t = !1), t) {
    if (e.flags |= 16777216, (a & 335544128) === a)
      if (e.stateNode.complete) e.flags |= 8192;
      else if (HC()) e.flags |= 8192;
      else
        throw Vi = Qf, Uv;
  } else e.flags &= -16777217;
}
function q0(e, t) {
  if (t.type !== "stylesheet" || t.state.loading & 4)
    e.flags &= -16777217;
  else if (e.flags |= 16777216, !pO(t))
    if (HC()) e.flags |= 8192;
    else
      throw Vi = Qf, Uv;
}
function Pu(e, t) {
  t !== null && (e.flags |= 4), e.flags & 16384 && (t = e.tag !== 22 ? $S() : 536870912, e.lanes |= t, Ds |= t);
}
function ml(e, t) {
  if (!Ae)
    switch (e.tailMode) {
      case "hidden":
        t = e.tail;
        for (var n = null; t !== null; )
          t.alternate !== null && (n = t), t = t.sibling;
        n === null ? e.tail = null : n.sibling = null;
        break;
      case "collapsed":
        n = e.tail;
        for (var r = null; n !== null; )
          n.alternate !== null && (r = n), n = n.sibling;
        r === null ? t || e.tail === null ? e.tail = null : e.tail.sibling = null : r.sibling = null;
    }
}
function He(e) {
  var t = e.alternate !== null && e.alternate.child === e.child, n = 0, r = 0;
  if (t)
    for (var a = e.child; a !== null; )
      n |= a.lanes | a.childLanes, r |= a.subtreeFlags & 65011712, r |= a.flags & 65011712, a.return = e, a = a.sibling;
  else
    for (a = e.child; a !== null; )
      n |= a.lanes | a.childLanes, r |= a.subtreeFlags, r |= a.flags, a.return = e, a = a.sibling;
  return e.subtreeFlags |= r, e.childLanes = n, t;
}
function Ck(e, t, n) {
  var r = t.pendingProps;
  switch (Pv(t), t.tag) {
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return He(t), null;
    case 1:
      return He(t), null;
    case 3:
      return n = t.stateNode, r = null, e !== null && (r = e.memoizedState.cache), t.memoizedState.cache !== r && (t.flags |= 2048), Br(mt), Ts(), n.pendingContext && (n.context = n.pendingContext, n.pendingContext = null), (e === null || e.child === null) && (mo(t) ? Cr(t) : e === null || e.memoizedState.isDehydrated && !(t.flags & 256) || (t.flags |= 1024, Vh())), He(t), null;
    case 26:
      var a = t.type, i = t.memoizedState;
      return e === null ? (Cr(t), i !== null ? (He(t), q0(t, i)) : (He(t), Zh(
        t,
        a,
        null,
        r,
        n
      ))) : i ? i !== e.memoizedState ? (Cr(t), He(t), q0(t, i)) : (He(t), t.flags &= -16777217) : (e = e.memoizedProps, e !== r && Cr(t), He(t), Zh(
        t,
        a,
        e,
        r,
        n
      )), null;
    case 27:
      if (Pf(t), n = Ia.current, a = t.type, e !== null && t.stateNode != null)
        e.memoizedProps !== r && Cr(t);
      else {
        if (!r) {
          if (t.stateNode === null)
            throw Error(V(166));
          return He(t), null;
        }
        e = ir.current, mo(t) ? g0(t) : (e = fO(a, r, n), t.stateNode = e, Cr(t));
      }
      return He(t), null;
    case 5:
      if (Pf(t), a = t.type, e !== null && t.stateNode != null)
        e.memoizedProps !== r && Cr(t);
      else {
        if (!r) {
          if (t.stateNode === null)
            throw Error(V(166));
          return He(t), null;
        }
        if (i = ir.current, mo(t))
          g0(t);
        else {
          var o = ad(
            Ia.current
          );
          switch (i) {
            case 1:
              i = o.createElementNS(
                "http://www.w3.org/2000/svg",
                a
              );
              break;
            case 2:
              i = o.createElementNS(
                "http://www.w3.org/1998/Math/MathML",
                a
              );
              break;
            default:
              switch (a) {
                case "svg":
                  i = o.createElementNS(
                    "http://www.w3.org/2000/svg",
                    a
                  );
                  break;
                case "math":
                  i = o.createElementNS(
                    "http://www.w3.org/1998/Math/MathML",
                    a
                  );
                  break;
                case "script":
                  i = o.createElement("div"), i.innerHTML = "<script><\/script>", i = i.removeChild(
                    i.firstChild
                  );
                  break;
                case "select":
                  i = typeof r.is == "string" ? o.createElement("select", {
                    is: r.is
                  }) : o.createElement("select"), r.multiple ? i.multiple = !0 : r.size && (i.size = r.size);
                  break;
                default:
                  i = typeof r.is == "string" ? o.createElement(a, { is: r.is }) : o.createElement(a);
              }
          }
          i[zt] = t, i[on] = r;
          e: for (o = t.child; o !== null; ) {
            if (o.tag === 5 || o.tag === 6)
              i.appendChild(o.stateNode);
            else if (o.tag !== 4 && o.tag !== 27 && o.child !== null) {
              o.child.return = o, o = o.child;
              continue;
            }
            if (o === t) break e;
            for (; o.sibling === null; ) {
              if (o.return === null || o.return === t)
                break e;
              o = o.return;
            }
            o.sibling.return = o.return, o = o.sibling;
          }
          t.stateNode = i;
          e: switch (It(i, a, r), a) {
            case "button":
            case "input":
            case "select":
            case "textarea":
              r = !!r.autoFocus;
              break e;
            case "img":
              r = !0;
              break e;
            default:
              r = !1;
          }
          r && Cr(t);
        }
      }
      return He(t), Zh(
        t,
        t.type,
        e === null ? null : e.memoizedProps,
        t.pendingProps,
        n
      ), null;
    case 6:
      if (e && t.stateNode != null)
        e.memoizedProps !== r && Cr(t);
      else {
        if (typeof r != "string" && t.stateNode === null)
          throw Error(V(166));
        if (e = Ia.current, mo(t)) {
          if (e = t.stateNode, n = t.memoizedProps, r = null, a = jt, a !== null)
            switch (a.tag) {
              case 27:
              case 5:
                r = a.memoizedProps;
            }
          e[zt] = t, e = !!(e.nodeValue === n || r !== null && r.suppressHydrationWarning === !0 || sO(e.nodeValue, n)), e || Wa(t, !0);
        } else
          e = ad(e).createTextNode(
            r
          ), e[zt] = t, t.stateNode = e;
      }
      return He(t), null;
    case 31:
      if (n = t.memoizedState, e === null || e.memoizedState !== null) {
        if (r = mo(t), n !== null) {
          if (e === null) {
            if (!r) throw Error(V(318));
            if (e = t.memoizedState, e = e !== null ? e.dehydrated : null, !e) throw Error(V(557));
            e[zt] = t;
          } else
            $i(), !(t.flags & 128) && (t.memoizedState = null), t.flags |= 4;
          He(t), e = !1;
        } else
          n = Vh(), e !== null && e.memoizedState !== null && (e.memoizedState.hydrationErrors = n), e = !0;
        if (!e)
          return t.flags & 256 ? (fn(t), t) : (fn(t), null);
        if (t.flags & 128)
          throw Error(V(558));
      }
      return He(t), null;
    case 13:
      if (r = t.memoizedState, e === null || e.memoizedState !== null && e.memoizedState.dehydrated !== null) {
        if (a = mo(t), r !== null && r.dehydrated !== null) {
          if (e === null) {
            if (!a) throw Error(V(318));
            if (a = t.memoizedState, a = a !== null ? a.dehydrated : null, !a) throw Error(V(317));
            a[zt] = t;
          } else
            $i(), !(t.flags & 128) && (t.memoizedState = null), t.flags |= 4;
          He(t), a = !1;
        } else
          a = Vh(), e !== null && e.memoizedState !== null && (e.memoizedState.hydrationErrors = a), a = !0;
        if (!a)
          return t.flags & 256 ? (fn(t), t) : (fn(t), null);
      }
      return fn(t), t.flags & 128 ? (t.lanes = n, t) : (n = r !== null, e = e !== null && e.memoizedState !== null, n && (r = t.child, a = null, r.alternate !== null && r.alternate.memoizedState !== null && r.alternate.memoizedState.cachePool !== null && (a = r.alternate.memoizedState.cachePool.pool), i = null, r.memoizedState !== null && r.memoizedState.cachePool !== null && (i = r.memoizedState.cachePool.pool), i !== a && (r.flags |= 2048)), n !== e && n && (t.child.flags |= 8192), Pu(t, t.updateQueue), He(t), null);
    case 4:
      return Ts(), e === null && uy(t.stateNode.containerInfo), He(t), null;
    case 10:
      return Br(t.type), He(t), null;
    case 19:
      if (Dt(lt), r = t.memoizedState, r === null) return He(t), null;
      if (a = (t.flags & 128) !== 0, i = r.rendering, i === null)
        if (a) ml(r, !1);
        else {
          if (rt !== 0 || e !== null && e.flags & 128)
            for (e = t.child; e !== null; ) {
              if (i = $f(e), i !== null) {
                for (t.flags |= 128, ml(r, !1), e = i.updateQueue, t.updateQueue = e, Pu(t, e), t.subtreeFlags = 0, e = n, n = t.child; n !== null; )
                  ET(n, e), n = n.sibling;
                return Be(
                  lt,
                  lt.current & 1 | 2
                ), Ae && Lr(t, r.treeForkCount), t.child;
              }
              e = e.sibling;
            }
          r.tail !== null && mn() > Zf && (t.flags |= 128, a = !0, ml(r, !1), t.lanes = 4194304);
        }
      else {
        if (!a)
          if (e = $f(i), e !== null) {
            if (t.flags |= 128, a = !0, e = e.updateQueue, t.updateQueue = e, Pu(t, e), ml(r, !0), r.tail === null && r.tailMode === "hidden" && !i.alternate && !Ae)
              return He(t), null;
          } else
            2 * mn() - r.renderingStartTime > Zf && n !== 536870912 && (t.flags |= 128, a = !0, ml(r, !1), t.lanes = 4194304);
        r.isBackwards ? (i.sibling = t.child, t.child = i) : (e = r.last, e !== null ? e.sibling = i : t.child = i, r.last = i);
      }
      return r.tail !== null ? (e = r.tail, r.rendering = e, r.tail = e.sibling, r.renderingStartTime = mn(), e.sibling = null, n = lt.current, Be(
        lt,
        a ? n & 1 | 2 : n & 1
      ), Ae && Lr(t, r.treeForkCount), e) : (He(t), null);
    case 22:
    case 23:
      return fn(t), Bv(), r = t.memoizedState !== null, e !== null ? e.memoizedState !== null !== r && (t.flags |= 8192) : r && (t.flags |= 8192), r ? n & 536870912 && !(t.flags & 128) && (He(t), t.subtreeFlags & 6 && (t.flags |= 8192)) : He(t), n = t.updateQueue, n !== null && Pu(t, n.retryQueue), n = null, e !== null && e.memoizedState !== null && e.memoizedState.cachePool !== null && (n = e.memoizedState.cachePool.pool), r = null, t.memoizedState !== null && t.memoizedState.cachePool !== null && (r = t.memoizedState.cachePool.pool), r !== n && (t.flags |= 2048), e !== null && Dt(Bi), null;
    case 24:
      return n = null, e !== null && (n = e.memoizedState.cache), t.memoizedState.cache !== n && (t.flags |= 2048), Br(mt), He(t), null;
    case 25:
      return null;
    case 30:
      return null;
  }
  throw Error(V(156, t.tag));
}
function Ok(e, t) {
  switch (Pv(t), t.tag) {
    case 1:
      return e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null;
    case 3:
      return Br(mt), Ts(), e = t.flags, e & 65536 && !(e & 128) ? (t.flags = e & -65537 | 128, t) : null;
    case 26:
    case 27:
    case 5:
      return Pf(t), null;
    case 31:
      if (t.memoizedState !== null) {
        if (fn(t), t.alternate === null)
          throw Error(V(340));
        $i();
      }
      return e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null;
    case 13:
      if (fn(t), e = t.memoizedState, e !== null && e.dehydrated !== null) {
        if (t.alternate === null)
          throw Error(V(340));
        $i();
      }
      return e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null;
    case 19:
      return Dt(lt), null;
    case 4:
      return Ts(), null;
    case 10:
      return Br(t.type), null;
    case 22:
    case 23:
      return fn(t), Bv(), e !== null && Dt(Bi), e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null;
    case 24:
      return Br(mt), null;
    case 25:
      return null;
    default:
      return null;
  }
}
function EC(e, t) {
  switch (Pv(t), t.tag) {
    case 3:
      Br(mt), Ts();
      break;
    case 26:
    case 27:
    case 5:
      Pf(t);
      break;
    case 4:
      Ts();
      break;
    case 31:
      t.memoizedState !== null && fn(t);
      break;
    case 13:
      fn(t);
      break;
    case 19:
      Dt(lt);
      break;
    case 10:
      Br(t.type);
      break;
    case 22:
    case 23:
      fn(t), Bv(), e !== null && Dt(Bi);
      break;
    case 24:
      Br(mt);
  }
}
function nu(e, t) {
  try {
    var n = t.updateQueue, r = n !== null ? n.lastEffect : null;
    if (r !== null) {
      var a = r.next;
      n = a;
      do {
        if ((n.tag & e) === e) {
          r = void 0;
          var i = n.create, o = n.inst;
          r = i(), o.destroy = r;
        }
        n = n.next;
      } while (n !== a);
    }
  } catch (s) {
    je(t, t.return, s);
  }
}
function Za(e, t, n) {
  try {
    var r = t.updateQueue, a = r !== null ? r.lastEffect : null;
    if (a !== null) {
      var i = a.next;
      r = i;
      do {
        if ((r.tag & e) === e) {
          var o = r.inst, s = o.destroy;
          if (s !== void 0) {
            o.destroy = void 0, a = t;
            var l = n, c = s;
            try {
              c();
            } catch (u) {
              je(
                a,
                l,
                u
              );
            }
          }
        }
        r = r.next;
      } while (r !== i);
    }
  } catch (u) {
    je(t, t.return, u);
  }
}
function SC(e) {
  var t = e.updateQueue;
  if (t !== null) {
    var n = e.stateNode;
    try {
      kT(t, n);
    } catch (r) {
      je(e, e.return, r);
    }
  }
}
function TC(e, t, n) {
  n.props = Xi(
    e.type,
    e.memoizedProps
  ), n.state = e.memoizedState;
  try {
    n.componentWillUnmount();
  } catch (r) {
    je(e, t, r);
  }
}
function Jl(e, t) {
  try {
    var n = e.ref;
    if (n !== null) {
      switch (e.tag) {
        case 26:
        case 27:
        case 5:
          var r = e.stateNode;
          break;
        case 30:
          r = e.stateNode;
          break;
        default:
          r = e.stateNode;
      }
      typeof n == "function" ? e.refCleanup = n(r) : n.current = r;
    }
  } catch (a) {
    je(e, t, a);
  }
}
function nr(e, t) {
  var n = e.ref, r = e.refCleanup;
  if (n !== null)
    if (typeof r == "function")
      try {
        r();
      } catch (a) {
        je(e, t, a);
      } finally {
        e.refCleanup = null, e = e.alternate, e != null && (e.refCleanup = null);
      }
    else if (typeof n == "function")
      try {
        n(null);
      } catch (a) {
        je(e, t, a);
      }
    else n.current = null;
}
function CC(e) {
  var t = e.type, n = e.memoizedProps, r = e.stateNode;
  try {
    e: switch (t) {
      case "button":
      case "input":
      case "select":
      case "textarea":
        n.autoFocus && r.focus();
        break e;
      case "img":
        n.src ? r.src = n.src : n.srcSet && (r.srcset = n.srcSet);
    }
  } catch (a) {
    je(e, e.return, a);
  }
}
function Jh(e, t, n) {
  try {
    var r = e.stateNode;
    Yk(r, e.type, n, t), r[on] = t;
  } catch (a) {
    je(e, e.return, a);
  }
}
function OC(e) {
  return e.tag === 5 || e.tag === 3 || e.tag === 26 || e.tag === 27 && ui(e.type) || e.tag === 4;
}
function ep(e) {
  e: for (; ; ) {
    for (; e.sibling === null; ) {
      if (e.return === null || OC(e.return)) return null;
      e = e.return;
    }
    for (e.sibling.return = e.return, e = e.sibling; e.tag !== 5 && e.tag !== 6 && e.tag !== 18; ) {
      if (e.tag === 27 && ui(e.type) || e.flags & 2 || e.child === null || e.tag === 4) continue e;
      e.child.return = e, e = e.child;
    }
    if (!(e.flags & 2)) return e.stateNode;
  }
}
function zm(e, t, n) {
  var r = e.tag;
  if (r === 5 || r === 6)
    e = e.stateNode, t ? (n.nodeType === 9 ? n.body : n.nodeName === "HTML" ? n.ownerDocument.body : n).insertBefore(e, t) : (t = n.nodeType === 9 ? n.body : n.nodeName === "HTML" ? n.ownerDocument.body : n, t.appendChild(e), n = n._reactRootContainer, n != null || t.onclick !== null || (t.onclick = Fr));
  else if (r !== 4 && (r === 27 && ui(e.type) && (n = e.stateNode, t = null), e = e.child, e !== null))
    for (zm(e, t, n), e = e.sibling; e !== null; )
      zm(e, t, n), e = e.sibling;
}
function Wf(e, t, n) {
  var r = e.tag;
  if (r === 5 || r === 6)
    e = e.stateNode, t ? n.insertBefore(e, t) : n.appendChild(e);
  else if (r !== 4 && (r === 27 && ui(e.type) && (n = e.stateNode), e = e.child, e !== null))
    for (Wf(e, t, n), e = e.sibling; e !== null; )
      Wf(e, t, n), e = e.sibling;
}
function AC(e) {
  var t = e.stateNode, n = e.memoizedProps;
  try {
    for (var r = e.type, a = t.attributes; a.length; )
      t.removeAttributeNode(a[0]);
    It(t, r, n), t[zt] = e, t[on] = n;
  } catch (i) {
    je(e, e.return, i);
  }
}
var Pr = !1, pt = !1, tp = !1, B0 = typeof WeakSet == "function" ? WeakSet : Set, Rt = null;
function Ak(e, t) {
  if (e = e.containerInfo, Bm = ld, e = pT(e), kv(e)) {
    if ("selectionStart" in e)
      var n = {
        start: e.selectionStart,
        end: e.selectionEnd
      };
    else
      e: {
        n = (n = e.ownerDocument) && n.defaultView || window;
        var r = n.getSelection && n.getSelection();
        if (r && r.rangeCount !== 0) {
          n = r.anchorNode;
          var a = r.anchorOffset, i = r.focusNode;
          r = r.focusOffset;
          try {
            n.nodeType, i.nodeType;
          } catch {
            n = null;
            break e;
          }
          var o = 0, s = -1, l = -1, c = 0, u = 0, f = e, d = null;
          t: for (; ; ) {
            for (var h; f !== n || a !== 0 && f.nodeType !== 3 || (s = o + a), f !== i || r !== 0 && f.nodeType !== 3 || (l = o + r), f.nodeType === 3 && (o += f.nodeValue.length), (h = f.firstChild) !== null; )
              d = f, f = h;
            for (; ; ) {
              if (f === e) break t;
              if (d === n && ++c === a && (s = o), d === i && ++u === r && (l = o), (h = f.nextSibling) !== null) break;
              f = d, d = f.parentNode;
            }
            f = h;
          }
          n = s === -1 || l === -1 ? null : { start: s, end: l };
        } else n = null;
      }
    n = n || { start: 0, end: 0 };
  } else n = null;
  for (Vm = { focusedElem: e, selectionRange: n }, ld = !1, Rt = t; Rt !== null; )
    if (t = Rt, e = t.child, (t.subtreeFlags & 1028) !== 0 && e !== null)
      e.return = t, Rt = e;
    else
      for (; Rt !== null; ) {
        switch (t = Rt, i = t.alternate, e = t.flags, t.tag) {
          case 0:
            if (e & 4 && (e = t.updateQueue, e = e !== null ? e.events : null, e !== null))
              for (n = 0; n < e.length; n++)
                a = e[n], a.ref.impl = a.nextImpl;
            break;
          case 11:
          case 15:
            break;
          case 1:
            if (e & 1024 && i !== null) {
              e = void 0, n = t, a = i.memoizedProps, i = i.memoizedState, r = n.stateNode;
              try {
                var g = Xi(
                  n.type,
                  a
                );
                e = r.getSnapshotBeforeUpdate(
                  g,
                  i
                ), r.__reactInternalSnapshotBeforeUpdate = e;
              } catch (v) {
                je(
                  n,
                  n.return,
                  v
                );
              }
            }
            break;
          case 3:
            if (e & 1024) {
              if (e = t.stateNode.containerInfo, n = e.nodeType, n === 9)
                Hm(e);
              else if (n === 1)
                switch (e.nodeName) {
                  case "HEAD":
                  case "HTML":
                  case "BODY":
                    Hm(e);
                    break;
                  default:
                    e.textContent = "";
                }
            }
            break;
          case 5:
          case 26:
          case 27:
          case 6:
          case 4:
          case 17:
            break;
          default:
            if (e & 1024) throw Error(V(163));
        }
        if (e = t.sibling, e !== null) {
          e.return = t.return, Rt = e;
          break;
        }
        Rt = t.return;
      }
}
function RC(e, t, n) {
  var r = n.flags;
  switch (n.tag) {
    case 0:
    case 11:
    case 15:
      Ar(e, n), r & 4 && nu(5, n);
      break;
    case 1:
      if (Ar(e, n), r & 4)
        if (e = n.stateNode, t === null)
          try {
            e.componentDidMount();
          } catch (o) {
            je(n, n.return, o);
          }
        else {
          var a = Xi(
            n.type,
            t.memoizedProps
          );
          t = t.memoizedState;
          try {
            e.componentDidUpdate(
              a,
              t,
              e.__reactInternalSnapshotBeforeUpdate
            );
          } catch (o) {
            je(
              n,
              n.return,
              o
            );
          }
        }
      r & 64 && SC(n), r & 512 && Jl(n, n.return);
      break;
    case 3:
      if (Ar(e, n), r & 64 && (e = n.updateQueue, e !== null)) {
        if (t = null, n.child !== null)
          switch (n.child.tag) {
            case 27:
            case 5:
              t = n.child.stateNode;
              break;
            case 1:
              t = n.child.stateNode;
          }
        try {
          kT(e, t);
        } catch (o) {
          je(n, n.return, o);
        }
      }
      break;
    case 27:
      t === null && r & 4 && AC(n);
    case 26:
    case 5:
      Ar(e, n), t === null && r & 4 && CC(n), r & 512 && Jl(n, n.return);
      break;
    case 12:
      Ar(e, n);
      break;
    case 31:
      Ar(e, n), r & 4 && NC(e, n);
      break;
    case 13:
      Ar(e, n), r & 4 && kC(e, n), r & 64 && (e = n.memoizedState, e !== null && (e = e.dehydrated, e !== null && (n = jk.bind(
        null,
        n
      ), nM(e, n))));
      break;
    case 22:
      if (r = n.memoizedState !== null || Pr, !r) {
        t = t !== null && t.memoizedState !== null || pt, a = Pr;
        var i = pt;
        Pr = r, (pt = t) && !i ? Dr(
          e,
          n,
          (n.subtreeFlags & 8772) !== 0
        ) : Ar(e, n), Pr = a, pt = i;
      }
      break;
    case 30:
      break;
    default:
      Ar(e, n);
  }
}
function _C(e) {
  var t = e.alternate;
  t !== null && (e.alternate = null, _C(t)), e.child = null, e.deletions = null, e.sibling = null, e.tag === 5 && (t = e.stateNode, t !== null && Ov(t)), e.stateNode = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null;
}
var We = null, en = !1;
function Or(e, t, n) {
  for (n = n.child; n !== null; )
    DC(e, t, n), n = n.sibling;
}
function DC(e, t, n) {
  if (gn && typeof gn.onCommitFiberUnmount == "function")
    try {
      gn.onCommitFiberUnmount(Kc, n);
    } catch {
    }
  switch (n.tag) {
    case 26:
      pt || nr(n, t), Or(
        e,
        t,
        n
      ), n.memoizedState ? n.memoizedState.count-- : n.stateNode && (n = n.stateNode, n.parentNode.removeChild(n));
      break;
    case 27:
      pt || nr(n, t);
      var r = We, a = en;
      ui(n.type) && (We = n.stateNode, en = !1), Or(
        e,
        t,
        n
      ), rc(n.stateNode), We = r, en = a;
      break;
    case 5:
      pt || nr(n, t);
    case 6:
      if (r = We, a = en, We = null, Or(
        e,
        t,
        n
      ), We = r, en = a, We !== null)
        if (en)
          try {
            (We.nodeType === 9 ? We.body : We.nodeName === "HTML" ? We.ownerDocument.body : We).removeChild(n.stateNode);
          } catch (i) {
            je(
              n,
              t,
              i
            );
          }
        else
          try {
            We.removeChild(n.stateNode);
          } catch (i) {
            je(
              n,
              t,
              i
            );
          }
      break;
    case 18:
      We !== null && (en ? (e = We, tw(
        e.nodeType === 9 ? e.body : e.nodeName === "HTML" ? e.ownerDocument.body : e,
        n.stateNode
      ), Ls(e)) : tw(We, n.stateNode));
      break;
    case 4:
      r = We, a = en, We = n.stateNode.containerInfo, en = !0, Or(
        e,
        t,
        n
      ), We = r, en = a;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      Za(2, n, t), pt || Za(4, n, t), Or(
        e,
        t,
        n
      );
      break;
    case 1:
      pt || (nr(n, t), r = n.stateNode, typeof r.componentWillUnmount == "function" && TC(
        n,
        t,
        r
      )), Or(
        e,
        t,
        n
      );
      break;
    case 21:
      Or(
        e,
        t,
        n
      );
      break;
    case 22:
      pt = (r = pt) || n.memoizedState !== null, Or(
        e,
        t,
        n
      ), pt = r;
      break;
    default:
      Or(
        e,
        t,
        n
      );
  }
}
function NC(e, t) {
  if (t.memoizedState === null && (e = t.alternate, e !== null && (e = e.memoizedState, e !== null))) {
    e = e.dehydrated;
    try {
      Ls(e);
    } catch (n) {
      je(t, t.return, n);
    }
  }
}
function kC(e, t) {
  if (t.memoizedState === null && (e = t.alternate, e !== null && (e = e.memoizedState, e !== null && (e = e.dehydrated, e !== null))))
    try {
      Ls(e);
    } catch (n) {
      je(t, t.return, n);
    }
}
function Rk(e) {
  switch (e.tag) {
    case 31:
    case 13:
    case 19:
      var t = e.stateNode;
      return t === null && (t = e.stateNode = new B0()), t;
    case 22:
      return e = e.stateNode, t = e._retryCache, t === null && (t = e._retryCache = new B0()), t;
    default:
      throw Error(V(435, e.tag));
  }
}
function Iu(e, t) {
  var n = Rk(e);
  t.forEach(function(r) {
    if (!n.has(r)) {
      n.add(r);
      var a = Pk.bind(null, e, r);
      r.then(a, a);
    }
  });
}
function Xt(e, t) {
  var n = t.deletions;
  if (n !== null)
    for (var r = 0; r < n.length; r++) {
      var a = n[r], i = e, o = t, s = o;
      e: for (; s !== null; ) {
        switch (s.tag) {
          case 27:
            if (ui(s.type)) {
              We = s.stateNode, en = !1;
              break e;
            }
            break;
          case 5:
            We = s.stateNode, en = !1;
            break e;
          case 3:
          case 4:
            We = s.stateNode.containerInfo, en = !0;
            break e;
        }
        s = s.return;
      }
      if (We === null) throw Error(V(160));
      DC(i, o, a), We = null, en = !1, i = a.alternate, i !== null && (i.return = null), a.return = null;
    }
  if (t.subtreeFlags & 13886)
    for (t = t.child; t !== null; )
      MC(t, e), t = t.sibling;
}
var qn = null;
function MC(e, t) {
  var n = e.alternate, r = e.flags;
  switch (e.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      Xt(t, e), Wt(e), r & 4 && (Za(3, e, e.return), nu(3, e), Za(5, e, e.return));
      break;
    case 1:
      Xt(t, e), Wt(e), r & 512 && (pt || n === null || nr(n, n.return)), r & 64 && Pr && (e = e.updateQueue, e !== null && (r = e.callbacks, r !== null && (n = e.shared.hiddenCallbacks, e.shared.hiddenCallbacks = n === null ? r : n.concat(r))));
      break;
    case 26:
      var a = qn;
      if (Xt(t, e), Wt(e), r & 512 && (pt || n === null || nr(n, n.return)), r & 4) {
        var i = n !== null ? n.memoizedState : null;
        if (r = e.memoizedState, n === null)
          if (r === null)
            if (e.stateNode === null) {
              e: {
                r = e.type, n = e.memoizedProps, a = a.ownerDocument || a;
                t: switch (r) {
                  case "title":
                    i = a.getElementsByTagName("title")[0], (!i || i[Zc] || i[zt] || i.namespaceURI === "http://www.w3.org/2000/svg" || i.hasAttribute("itemprop")) && (i = a.createElement(r), a.head.insertBefore(
                      i,
                      a.querySelector("head > title")
                    )), It(i, r, n), i[zt] = e, _t(i), r = i;
                    break e;
                  case "link":
                    var o = lw(
                      "link",
                      "href",
                      a
                    ).get(r + (n.href || ""));
                    if (o) {
                      for (var s = 0; s < o.length; s++)
                        if (i = o[s], i.getAttribute("href") === (n.href == null || n.href === "" ? null : n.href) && i.getAttribute("rel") === (n.rel == null ? null : n.rel) && i.getAttribute("title") === (n.title == null ? null : n.title) && i.getAttribute("crossorigin") === (n.crossOrigin == null ? null : n.crossOrigin)) {
                          o.splice(s, 1);
                          break t;
                        }
                    }
                    i = a.createElement(r), It(i, r, n), a.head.appendChild(i);
                    break;
                  case "meta":
                    if (o = lw(
                      "meta",
                      "content",
                      a
                    ).get(r + (n.content || ""))) {
                      for (s = 0; s < o.length; s++)
                        if (i = o[s], i.getAttribute("content") === (n.content == null ? null : "" + n.content) && i.getAttribute("name") === (n.name == null ? null : n.name) && i.getAttribute("property") === (n.property == null ? null : n.property) && i.getAttribute("http-equiv") === (n.httpEquiv == null ? null : n.httpEquiv) && i.getAttribute("charset") === (n.charSet == null ? null : n.charSet)) {
                          o.splice(s, 1);
                          break t;
                        }
                    }
                    i = a.createElement(r), It(i, r, n), a.head.appendChild(i);
                    break;
                  default:
                    throw Error(V(468, r));
                }
                i[zt] = e, _t(i), r = i;
              }
              e.stateNode = r;
            } else
              cw(
                a,
                e.type,
                e.stateNode
              );
          else
            e.stateNode = sw(
              a,
              r,
              e.memoizedProps
            );
        else
          i !== r ? (i === null ? n.stateNode !== null && (n = n.stateNode, n.parentNode.removeChild(n)) : i.count--, r === null ? cw(
            a,
            e.type,
            e.stateNode
          ) : sw(
            a,
            r,
            e.memoizedProps
          )) : r === null && e.stateNode !== null && Jh(
            e,
            e.memoizedProps,
            n.memoizedProps
          );
      }
      break;
    case 27:
      Xt(t, e), Wt(e), r & 512 && (pt || n === null || nr(n, n.return)), n !== null && r & 4 && Jh(
        e,
        e.memoizedProps,
        n.memoizedProps
      );
      break;
    case 5:
      if (Xt(t, e), Wt(e), r & 512 && (pt || n === null || nr(n, n.return)), e.flags & 32) {
        a = e.stateNode;
        try {
          Os(a, "");
        } catch (g) {
          je(e, e.return, g);
        }
      }
      r & 4 && e.stateNode != null && (a = e.memoizedProps, Jh(
        e,
        a,
        n !== null ? n.memoizedProps : a
      )), r & 1024 && (tp = !0);
      break;
    case 6:
      if (Xt(t, e), Wt(e), r & 4) {
        if (e.stateNode === null)
          throw Error(V(162));
        r = e.memoizedProps, n = e.stateNode;
        try {
          n.nodeValue = r;
        } catch (g) {
          je(e, e.return, g);
        }
      }
      break;
    case 3:
      if (yf = null, a = qn, qn = id(t.containerInfo), Xt(t, e), qn = a, Wt(e), r & 4 && n !== null && n.memoizedState.isDehydrated)
        try {
          Ls(t.containerInfo);
        } catch (g) {
          je(e, e.return, g);
        }
      tp && (tp = !1, LC(e));
      break;
    case 4:
      r = qn, qn = id(
        e.stateNode.containerInfo
      ), Xt(t, e), Wt(e), qn = r;
      break;
    case 12:
      Xt(t, e), Wt(e);
      break;
    case 31:
      Xt(t, e), Wt(e), r & 4 && (r = e.updateQueue, r !== null && (e.updateQueue = null, Iu(e, r)));
      break;
    case 13:
      Xt(t, e), Wt(e), e.child.flags & 8192 && e.memoizedState !== null != (n !== null && n.memoizedState !== null) && (Qd = mn()), r & 4 && (r = e.updateQueue, r !== null && (e.updateQueue = null, Iu(e, r)));
      break;
    case 22:
      a = e.memoizedState !== null;
      var l = n !== null && n.memoizedState !== null, c = Pr, u = pt;
      if (Pr = c || a, pt = u || l, Xt(t, e), pt = u, Pr = c, Wt(e), r & 8192)
        e: for (t = e.stateNode, t._visibility = a ? t._visibility & -2 : t._visibility | 1, a && (n === null || l || Pr || pt || Ei(e)), n = null, t = e; ; ) {
          if (t.tag === 5 || t.tag === 26) {
            if (n === null) {
              l = n = t;
              try {
                if (i = l.stateNode, a)
                  o = i.style, typeof o.setProperty == "function" ? o.setProperty("display", "none", "important") : o.display = "none";
                else {
                  s = l.stateNode;
                  var f = l.memoizedProps.style, d = f != null && f.hasOwnProperty("display") ? f.display : null;
                  s.style.display = d == null || typeof d == "boolean" ? "" : ("" + d).trim();
                }
              } catch (g) {
                je(l, l.return, g);
              }
            }
          } else if (t.tag === 6) {
            if (n === null) {
              l = t;
              try {
                l.stateNode.nodeValue = a ? "" : l.memoizedProps;
              } catch (g) {
                je(l, l.return, g);
              }
            }
          } else if (t.tag === 18) {
            if (n === null) {
              l = t;
              try {
                var h = l.stateNode;
                a ? nw(h, !0) : nw(l.stateNode, !1);
              } catch (g) {
                je(l, l.return, g);
              }
            }
          } else if ((t.tag !== 22 && t.tag !== 23 || t.memoizedState === null || t === e) && t.child !== null) {
            t.child.return = t, t = t.child;
            continue;
          }
          if (t === e) break e;
          for (; t.sibling === null; ) {
            if (t.return === null || t.return === e) break e;
            n === t && (n = null), t = t.return;
          }
          n === t && (n = null), t.sibling.return = t.return, t = t.sibling;
        }
      r & 4 && (r = e.updateQueue, r !== null && (n = r.retryQueue, n !== null && (r.retryQueue = null, Iu(e, n))));
      break;
    case 19:
      Xt(t, e), Wt(e), r & 4 && (r = e.updateQueue, r !== null && (e.updateQueue = null, Iu(e, r)));
      break;
    case 30:
      break;
    case 21:
      break;
    default:
      Xt(t, e), Wt(e);
  }
}
function Wt(e) {
  var t = e.flags;
  if (t & 2) {
    try {
      for (var n, r = e.return; r !== null; ) {
        if (OC(r)) {
          n = r;
          break;
        }
        r = r.return;
      }
      if (n == null) throw Error(V(160));
      switch (n.tag) {
        case 27:
          var a = n.stateNode, i = ep(e);
          Wf(e, i, a);
          break;
        case 5:
          var o = n.stateNode;
          n.flags & 32 && (Os(o, ""), n.flags &= -33);
          var s = ep(e);
          Wf(e, s, o);
          break;
        case 3:
        case 4:
          var l = n.stateNode.containerInfo, c = ep(e);
          zm(
            e,
            c,
            l
          );
          break;
        default:
          throw Error(V(161));
      }
    } catch (u) {
      je(e, e.return, u);
    }
    e.flags &= -3;
  }
  t & 4096 && (e.flags &= -4097);
}
function LC(e) {
  if (e.subtreeFlags & 1024)
    for (e = e.child; e !== null; ) {
      var t = e;
      LC(t), t.tag === 5 && t.flags & 1024 && t.stateNode.reset(), e = e.sibling;
    }
}
function Ar(e, t) {
  if (t.subtreeFlags & 8772)
    for (t = t.child; t !== null; )
      RC(e, t.alternate, t), t = t.sibling;
}
function Ei(e) {
  for (e = e.child; e !== null; ) {
    var t = e;
    switch (t.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        Za(4, t, t.return), Ei(t);
        break;
      case 1:
        nr(t, t.return);
        var n = t.stateNode;
        typeof n.componentWillUnmount == "function" && TC(
          t,
          t.return,
          n
        ), Ei(t);
        break;
      case 27:
        rc(t.stateNode);
      case 26:
      case 5:
        nr(t, t.return), Ei(t);
        break;
      case 22:
        t.memoizedState === null && Ei(t);
        break;
      case 30:
        Ei(t);
        break;
      default:
        Ei(t);
    }
    e = e.sibling;
  }
}
function Dr(e, t, n) {
  for (n = n && (t.subtreeFlags & 8772) !== 0, t = t.child; t !== null; ) {
    var r = t.alternate, a = e, i = t, o = i.flags;
    switch (i.tag) {
      case 0:
      case 11:
      case 15:
        Dr(
          a,
          i,
          n
        ), nu(4, i);
        break;
      case 1:
        if (Dr(
          a,
          i,
          n
        ), r = i, a = r.stateNode, typeof a.componentDidMount == "function")
          try {
            a.componentDidMount();
          } catch (c) {
            je(r, r.return, c);
          }
        if (r = i, a = r.updateQueue, a !== null) {
          var s = r.stateNode;
          try {
            var l = a.shared.hiddenCallbacks;
            if (l !== null)
              for (a.shared.hiddenCallbacks = null, a = 0; a < l.length; a++)
                NT(l[a], s);
          } catch (c) {
            je(r, r.return, c);
          }
        }
        n && o & 64 && SC(i), Jl(i, i.return);
        break;
      case 27:
        AC(i);
      case 26:
      case 5:
        Dr(
          a,
          i,
          n
        ), n && r === null && o & 4 && CC(i), Jl(i, i.return);
        break;
      case 12:
        Dr(
          a,
          i,
          n
        );
        break;
      case 31:
        Dr(
          a,
          i,
          n
        ), n && o & 4 && NC(a, i);
        break;
      case 13:
        Dr(
          a,
          i,
          n
        ), n && o & 4 && kC(a, i);
        break;
      case 22:
        i.memoizedState === null && Dr(
          a,
          i,
          n
        ), Jl(i, i.return);
        break;
      case 30:
        break;
      default:
        Dr(
          a,
          i,
          n
        );
    }
    t = t.sibling;
  }
}
function ay(e, t) {
  var n = null;
  e !== null && e.memoizedState !== null && e.memoizedState.cachePool !== null && (n = e.memoizedState.cachePool.pool), e = null, t.memoizedState !== null && t.memoizedState.cachePool !== null && (e = t.memoizedState.cachePool.pool), e !== n && (e != null && e.refCount++, n != null && eu(n));
}
function iy(e, t) {
  e = null, t.alternate !== null && (e = t.alternate.memoizedState.cache), t = t.memoizedState.cache, t !== e && (t.refCount++, e != null && eu(e));
}
function Pn(e, t, n, r) {
  if (t.subtreeFlags & 10256)
    for (t = t.child; t !== null; )
      zC(
        e,
        t,
        n,
        r
      ), t = t.sibling;
}
function zC(e, t, n, r) {
  var a = t.flags;
  switch (t.tag) {
    case 0:
    case 11:
    case 15:
      Pn(
        e,
        t,
        n,
        r
      ), a & 2048 && nu(9, t);
      break;
    case 1:
      Pn(
        e,
        t,
        n,
        r
      );
      break;
    case 3:
      Pn(
        e,
        t,
        n,
        r
      ), a & 2048 && (e = null, t.alternate !== null && (e = t.alternate.memoizedState.cache), t = t.memoizedState.cache, t !== e && (t.refCount++, e != null && eu(e)));
      break;
    case 12:
      if (a & 2048) {
        Pn(
          e,
          t,
          n,
          r
        ), e = t.stateNode;
        try {
          var i = t.memoizedProps, o = i.id, s = i.onPostCommit;
          typeof s == "function" && s(
            o,
            t.alternate === null ? "mount" : "update",
            e.passiveEffectDuration,
            -0
          );
        } catch (l) {
          je(t, t.return, l);
        }
      } else
        Pn(
          e,
          t,
          n,
          r
        );
      break;
    case 31:
      Pn(
        e,
        t,
        n,
        r
      );
      break;
    case 13:
      Pn(
        e,
        t,
        n,
        r
      );
      break;
    case 23:
      break;
    case 22:
      i = t.stateNode, o = t.alternate, t.memoizedState !== null ? i._visibility & 2 ? Pn(
        e,
        t,
        n,
        r
      ) : ec(e, t) : i._visibility & 2 ? Pn(
        e,
        t,
        n,
        r
      ) : (i._visibility |= 2, Co(
        e,
        t,
        n,
        r,
        (t.subtreeFlags & 10256) !== 0 || !1
      )), a & 2048 && ay(o, t);
      break;
    case 24:
      Pn(
        e,
        t,
        n,
        r
      ), a & 2048 && iy(t.alternate, t);
      break;
    default:
      Pn(
        e,
        t,
        n,
        r
      );
  }
}
function Co(e, t, n, r, a) {
  for (a = a && ((t.subtreeFlags & 10256) !== 0 || !1), t = t.child; t !== null; ) {
    var i = e, o = t, s = n, l = r, c = o.flags;
    switch (o.tag) {
      case 0:
      case 11:
      case 15:
        Co(
          i,
          o,
          s,
          l,
          a
        ), nu(8, o);
        break;
      case 23:
        break;
      case 22:
        var u = o.stateNode;
        o.memoizedState !== null ? u._visibility & 2 ? Co(
          i,
          o,
          s,
          l,
          a
        ) : ec(
          i,
          o
        ) : (u._visibility |= 2, Co(
          i,
          o,
          s,
          l,
          a
        )), a && c & 2048 && ay(
          o.alternate,
          o
        );
        break;
      case 24:
        Co(
          i,
          o,
          s,
          l,
          a
        ), a && c & 2048 && iy(o.alternate, o);
        break;
      default:
        Co(
          i,
          o,
          s,
          l,
          a
        );
    }
    t = t.sibling;
  }
}
function ec(e, t) {
  if (t.subtreeFlags & 10256)
    for (t = t.child; t !== null; ) {
      var n = e, r = t, a = r.flags;
      switch (r.tag) {
        case 22:
          ec(n, r), a & 2048 && ay(
            r.alternate,
            r
          );
          break;
        case 24:
          ec(n, r), a & 2048 && iy(r.alternate, r);
          break;
        default:
          ec(n, r);
      }
      t = t.sibling;
    }
}
var jl = 8192;
function go(e, t, n) {
  if (e.subtreeFlags & jl)
    for (e = e.child; e !== null; )
      jC(
        e,
        t,
        n
      ), e = e.sibling;
}
function jC(e, t, n) {
  switch (e.tag) {
    case 26:
      go(
        e,
        t,
        n
      ), e.flags & jl && e.memoizedState !== null && pM(
        n,
        qn,
        e.memoizedState,
        e.memoizedProps
      );
      break;
    case 5:
      go(
        e,
        t,
        n
      );
      break;
    case 3:
    case 4:
      var r = qn;
      qn = id(e.stateNode.containerInfo), go(
        e,
        t,
        n
      ), qn = r;
      break;
    case 22:
      e.memoizedState === null && (r = e.alternate, r !== null && r.memoizedState !== null ? (r = jl, jl = 16777216, go(
        e,
        t,
        n
      ), jl = r) : go(
        e,
        t,
        n
      ));
      break;
    default:
      go(
        e,
        t,
        n
      );
  }
}
function PC(e) {
  var t = e.alternate;
  if (t !== null && (e = t.child, e !== null)) {
    t.child = null;
    do
      t = e.sibling, e.sibling = null, e = t;
    while (e !== null);
  }
}
function gl(e) {
  var t = e.deletions;
  if (e.flags & 16) {
    if (t !== null)
      for (var n = 0; n < t.length; n++) {
        var r = t[n];
        Rt = r, FC(
          r,
          e
        );
      }
    PC(e);
  }
  if (e.subtreeFlags & 10256)
    for (e = e.child; e !== null; )
      IC(e), e = e.sibling;
}
function IC(e) {
  switch (e.tag) {
    case 0:
    case 11:
    case 15:
      gl(e), e.flags & 2048 && Za(9, e, e.return);
      break;
    case 3:
      gl(e);
      break;
    case 12:
      gl(e);
      break;
    case 22:
      var t = e.stateNode;
      e.memoizedState !== null && t._visibility & 2 && (e.return === null || e.return.tag !== 13) ? (t._visibility &= -3, gf(e)) : gl(e);
      break;
    default:
      gl(e);
  }
}
function gf(e) {
  var t = e.deletions;
  if (e.flags & 16) {
    if (t !== null)
      for (var n = 0; n < t.length; n++) {
        var r = t[n];
        Rt = r, FC(
          r,
          e
        );
      }
    PC(e);
  }
  for (e = e.child; e !== null; ) {
    switch (t = e, t.tag) {
      case 0:
      case 11:
      case 15:
        Za(8, t, t.return), gf(t);
        break;
      case 22:
        n = t.stateNode, n._visibility & 2 && (n._visibility &= -3, gf(t));
        break;
      default:
        gf(t);
    }
    e = e.sibling;
  }
}
function FC(e, t) {
  for (; Rt !== null; ) {
    var n = Rt;
    switch (n.tag) {
      case 0:
      case 11:
      case 15:
        Za(8, n, t);
        break;
      case 23:
      case 22:
        if (n.memoizedState !== null && n.memoizedState.cachePool !== null) {
          var r = n.memoizedState.cachePool.pool;
          r != null && r.refCount++;
        }
        break;
      case 24:
        eu(n.memoizedState.cache);
    }
    if (r = n.child, r !== null) r.return = n, Rt = r;
    else
      e: for (n = e; Rt !== null; ) {
        r = Rt;
        var a = r.sibling, i = r.return;
        if (_C(r), r === n) {
          Rt = null;
          break e;
        }
        if (a !== null) {
          a.return = i, Rt = a;
          break e;
        }
        Rt = i;
      }
  }
}
var _k = {
  getCacheForType: function(e) {
    var t = Pt(mt), n = t.data.get(e);
    return n === void 0 && (n = e(), t.data.set(e, n)), n;
  },
  cacheSignal: function() {
    return Pt(mt).controller.signal;
  }
}, Dk = typeof WeakMap == "function" ? WeakMap : Map, _e = 0, Fe = null, Ee = null, Te = 0, ze = 0, ln = null, La = !1, Ys = !1, oy = !1, Yr = 0, rt = 0, Ja = 0, Qi = 0, sy = 0, pn = 0, Ds = 0, tc = null, nn = null, jm = !1, Qd = 0, UC = 0, Zf = 1 / 0, Jf = null, Ba = null, Et = 0, Va = null, Ns = null, Vr = 0, Pm = 0, Im = null, qC = null, nc = 0, Fm = null;
function yn() {
  return _e & 2 && Te !== 0 ? Te & -Te : fe.T !== null ? cy() : XS();
}
function BC() {
  if (pn === 0)
    if (!(Te & 536870912) || Ae) {
      var e = Du;
      Du <<= 1, !(Du & 3932160) && (Du = 262144), pn = e;
    } else pn = 536870912;
  return e = xn.current, e !== null && (e.flags |= 32), pn;
}
function an(e, t, n) {
  (e === Fe && (ze === 2 || ze === 9) || e.cancelPendingCommit !== null) && (ks(e, 0), za(
    e,
    Te,
    pn,
    !1
  )), Wc(e, n), (!(_e & 2) || e !== Fe) && (e === Fe && (!(_e & 2) && (Qi |= n), rt === 4 && za(
    e,
    Te,
    pn,
    !1
  )), pr(e));
}
function VC(e, t, n) {
  if (_e & 6) throw Error(V(327));
  var r = !n && (t & 127) === 0 && (t & e.expiredLanes) === 0 || Xc(e, t), a = r ? Mk(e, t) : np(e, t, !0), i = r;
  do {
    if (a === 0) {
      Ys && !r && za(e, t, 0, !1);
      break;
    } else {
      if (n = e.current.alternate, i && !Nk(n)) {
        a = np(e, t, !1), i = !1;
        continue;
      }
      if (a === 2) {
        if (i = t, e.errorRecoveryDisabledLanes & i)
          var o = 0;
        else
          o = e.pendingLanes & -536870913, o = o !== 0 ? o : o & 536870912 ? 536870912 : 0;
        if (o !== 0) {
          t = o;
          e: {
            var s = e;
            a = tc;
            var l = s.current.memoizedState.isDehydrated;
            if (l && (ks(s, o).flags |= 256), o = np(
              s,
              o,
              !1
            ), o !== 2) {
              if (oy && !l) {
                s.errorRecoveryDisabledLanes |= i, Qi |= i, a = 4;
                break e;
              }
              i = nn, nn = a, i !== null && (nn === null ? nn = i : nn.push.apply(
                nn,
                i
              ));
            }
            a = o;
          }
          if (i = !1, a !== 2) continue;
        }
      }
      if (a === 1) {
        ks(e, 0), za(e, t, 0, !0);
        break;
      }
      e: {
        switch (r = e, i = a, i) {
          case 0:
          case 1:
            throw Error(V(345));
          case 4:
            if ((t & 4194048) !== t) break;
          case 6:
            za(
              r,
              t,
              pn,
              !La
            );
            break e;
          case 2:
            nn = null;
            break;
          case 3:
          case 5:
            break;
          default:
            throw Error(V(329));
        }
        if ((t & 62914560) === t && (a = Qd + 300 - mn(), 10 < a)) {
          if (za(
            r,
            t,
            pn,
            !La
          ), Md(r, 0, !0) !== 0) break e;
          Vr = t, r.timeoutHandle = cO(
            V0.bind(
              null,
              r,
              n,
              nn,
              Jf,
              jm,
              t,
              pn,
              Qi,
              Ds,
              La,
              i,
              "Throttled",
              -0,
              0
            ),
            a
          );
          break e;
        }
        V0(
          r,
          n,
          nn,
          Jf,
          jm,
          t,
          pn,
          Qi,
          Ds,
          La,
          i,
          null,
          -0,
          0
        );
      }
    }
    break;
  } while (!0);
  pr(e);
}
function V0(e, t, n, r, a, i, o, s, l, c, u, f, d, h) {
  if (e.timeoutHandle = -1, f = t.subtreeFlags, f & 8192 || (f & 16785408) === 16785408) {
    f = {
      stylesheets: null,
      count: 0,
      imgCount: 0,
      imgBytes: 0,
      suspenseyImages: [],
      waitingForImages: !0,
      waitingForViewTransition: !1,
      unsuspend: Fr
    }, jC(
      t,
      i,
      f
    );
    var g = (i & 62914560) === i ? Qd - mn() : (i & 4194048) === i ? UC - mn() : 0;
    if (g = mM(
      f,
      g
    ), g !== null) {
      Vr = i, e.cancelPendingCommit = g(
        H0.bind(
          null,
          e,
          t,
          i,
          n,
          r,
          a,
          o,
          s,
          l,
          u,
          f,
          null,
          d,
          h
        )
      ), za(e, i, o, !c);
      return;
    }
  }
  H0(
    e,
    t,
    i,
    n,
    r,
    a,
    o,
    s,
    l
  );
}
function Nk(e) {
  for (var t = e; ; ) {
    var n = t.tag;
    if ((n === 0 || n === 11 || n === 15) && t.flags & 16384 && (n = t.updateQueue, n !== null && (n = n.stores, n !== null)))
      for (var r = 0; r < n.length; r++) {
        var a = n[r], i = a.getSnapshot;
        a = a.value;
        try {
          if (!wn(i(), a)) return !1;
        } catch {
          return !1;
        }
      }
    if (n = t.child, t.subtreeFlags & 16384 && n !== null)
      n.return = t, t = n;
    else {
      if (t === e) break;
      for (; t.sibling === null; ) {
        if (t.return === null || t.return === e) return !0;
        t = t.return;
      }
      t.sibling.return = t.return, t = t.sibling;
    }
  }
  return !0;
}
function za(e, t, n, r) {
  t &= ~sy, t &= ~Qi, e.suspendedLanes |= t, e.pingedLanes &= ~t, r && (e.warmLanes |= t), r = e.expirationTimes;
  for (var a = t; 0 < a; ) {
    var i = 31 - vn(a), o = 1 << i;
    r[i] = -1, a &= ~o;
  }
  n !== 0 && GS(e, n, t);
}
function Hd() {
  return _e & 6 ? !0 : (ru(0), !1);
}
function ly() {
  if (Ee !== null) {
    if (ze === 0)
      var e = Ee.return;
    else
      e = Ee, Ur = lo = null, Gv(e), es = null, vc = 0, e = Ee;
    for (; e !== null; )
      EC(e.alternate, e), e = e.return;
    Ee = null;
  }
}
function ks(e, t) {
  var n = e.timeoutHandle;
  n !== -1 && (e.timeoutHandle = -1, Wk(n)), n = e.cancelPendingCommit, n !== null && (e.cancelPendingCommit = null, n()), Vr = 0, ly(), Fe = e, Ee = n = qr(e.current, null), Te = t, ze = 0, ln = null, La = !1, Ys = Xc(e, t), oy = !1, Ds = pn = sy = Qi = Ja = rt = 0, nn = tc = null, jm = !1, t & 8 && (t |= t & 32);
  var r = e.entangledLanes;
  if (r !== 0)
    for (e = e.entanglements, r &= t; 0 < r; ) {
      var a = 31 - vn(r), i = 1 << a;
      t |= e[a], r &= ~i;
    }
  return Yr = t, Pd(), n;
}
function QC(e, t) {
  ge = null, fe.H = bc, t === Gs || t === Fd ? (t = x0(), ze = 3) : t === Uv ? (t = x0(), ze = 4) : ze = t === ny ? 8 : t !== null && typeof t == "object" && typeof t.then == "function" ? 6 : 1, ln = t, Ee === null && (rt = 1, Kf(
    e,
    Dn(t, e.current)
  ));
}
function HC() {
  var e = xn.current;
  return e === null ? !0 : (Te & 4194048) === Te ? kn === null : (Te & 62914560) === Te || Te & 536870912 ? e === kn : !1;
}
function $C() {
  var e = fe.H;
  return fe.H = bc, e === null ? bc : e;
}
function GC() {
  var e = fe.A;
  return fe.A = _k, e;
}
function ed() {
  rt = 4, La || (Te & 4194048) !== Te && xn.current !== null || (Ys = !0), !(Ja & 134217727) && !(Qi & 134217727) || Fe === null || za(
    Fe,
    Te,
    pn,
    !1
  );
}
function np(e, t, n) {
  var r = _e;
  _e |= 2;
  var a = $C(), i = GC();
  (Fe !== e || Te !== t) && (Jf = null, ks(e, t)), t = !1;
  var o = rt;
  e: do
    try {
      if (ze !== 0 && Ee !== null) {
        var s = Ee, l = ln;
        switch (ze) {
          case 8:
            ly(), o = 6;
            break e;
          case 3:
          case 2:
          case 9:
          case 6:
            xn.current === null && (t = !0);
            var c = ze;
            if (ze = 0, ln = null, Vo(e, s, l, c), n && Ys) {
              o = 0;
              break e;
            }
            break;
          default:
            c = ze, ze = 0, ln = null, Vo(e, s, l, c);
        }
      }
      kk(), o = rt;
      break;
    } catch (u) {
      QC(e, u);
    }
  while (!0);
  return t && e.shellSuspendCounter++, Ur = lo = null, _e = r, fe.H = a, fe.A = i, Ee === null && (Fe = null, Te = 0, Pd()), o;
}
function kk() {
  for (; Ee !== null; ) YC(Ee);
}
function Mk(e, t) {
  var n = _e;
  _e |= 2;
  var r = $C(), a = GC();
  Fe !== e || Te !== t ? (Jf = null, Zf = mn() + 500, ks(e, t)) : Ys = Xc(
    e,
    t
  );
  e: do
    try {
      if (ze !== 0 && Ee !== null) {
        t = Ee;
        var i = ln;
        t: switch (ze) {
          case 1:
            ze = 0, ln = null, Vo(e, t, i, 1);
            break;
          case 2:
          case 9:
            if (w0(i)) {
              ze = 0, ln = null, Q0(t);
              break;
            }
            t = function() {
              ze !== 2 && ze !== 9 || Fe !== e || (ze = 7), pr(e);
            }, i.then(t, t);
            break e;
          case 3:
            ze = 7;
            break e;
          case 4:
            ze = 5;
            break e;
          case 7:
            w0(i) ? (ze = 0, ln = null, Q0(t)) : (ze = 0, ln = null, Vo(e, t, i, 7));
            break;
          case 5:
            var o = null;
            switch (Ee.tag) {
              case 26:
                o = Ee.memoizedState;
              case 5:
              case 27:
                var s = Ee;
                if (o ? pO(o) : s.stateNode.complete) {
                  ze = 0, ln = null;
                  var l = s.sibling;
                  if (l !== null) Ee = l;
                  else {
                    var c = s.return;
                    c !== null ? (Ee = c, $d(c)) : Ee = null;
                  }
                  break t;
                }
            }
            ze = 0, ln = null, Vo(e, t, i, 5);
            break;
          case 6:
            ze = 0, ln = null, Vo(e, t, i, 6);
            break;
          case 8:
            ly(), rt = 6;
            break e;
          default:
            throw Error(V(462));
        }
      }
      Lk();
      break;
    } catch (u) {
      QC(e, u);
    }
  while (!0);
  return Ur = lo = null, fe.H = r, fe.A = a, _e = n, Ee !== null ? 0 : (Fe = null, Te = 0, Pd(), rt);
}
function Lk() {
  for (; Ee !== null && !rN(); )
    YC(Ee);
}
function YC(e) {
  var t = xC(e.alternate, e, Yr);
  e.memoizedProps = e.pendingProps, t === null ? $d(e) : Ee = t;
}
function Q0(e) {
  var t = e, n = t.alternate;
  switch (t.tag) {
    case 15:
    case 0:
      t = P0(
        n,
        t,
        t.pendingProps,
        t.type,
        void 0,
        Te
      );
      break;
    case 11:
      t = P0(
        n,
        t,
        t.pendingProps,
        t.type.render,
        t.ref,
        Te
      );
      break;
    case 5:
      Gv(t);
    default:
      EC(n, t), t = Ee = ET(t, Yr), t = xC(n, t, Yr);
  }
  e.memoizedProps = e.pendingProps, t === null ? $d(e) : Ee = t;
}
function Vo(e, t, n, r) {
  Ur = lo = null, Gv(t), es = null, vc = 0;
  var a = t.return;
  try {
    if (Ek(
      e,
      a,
      t,
      n,
      Te
    )) {
      rt = 1, Kf(
        e,
        Dn(n, e.current)
      ), Ee = null;
      return;
    }
  } catch (i) {
    if (a !== null) throw Ee = a, i;
    rt = 1, Kf(
      e,
      Dn(n, e.current)
    ), Ee = null;
    return;
  }
  t.flags & 32768 ? (Ae || r === 1 ? e = !0 : Ys || Te & 536870912 ? e = !1 : (La = e = !0, (r === 2 || r === 9 || r === 3 || r === 6) && (r = xn.current, r !== null && r.tag === 13 && (r.flags |= 16384))), KC(t, e)) : $d(t);
}
function $d(e) {
  var t = e;
  do {
    if (t.flags & 32768) {
      KC(
        t,
        La
      );
      return;
    }
    e = t.return;
    var n = Ck(
      t.alternate,
      t,
      Yr
    );
    if (n !== null) {
      Ee = n;
      return;
    }
    if (t = t.sibling, t !== null) {
      Ee = t;
      return;
    }
    Ee = t = e;
  } while (t !== null);
  rt === 0 && (rt = 5);
}
function KC(e, t) {
  do {
    var n = Ok(e.alternate, e);
    if (n !== null) {
      n.flags &= 32767, Ee = n;
      return;
    }
    if (n = e.return, n !== null && (n.flags |= 32768, n.subtreeFlags = 0, n.deletions = null), !t && (e = e.sibling, e !== null)) {
      Ee = e;
      return;
    }
    Ee = e = n;
  } while (e !== null);
  rt = 6, Ee = null;
}
function H0(e, t, n, r, a, i, o, s, l) {
  e.cancelPendingCommit = null;
  do
    Gd();
  while (Et !== 0);
  if (_e & 6) throw Error(V(327));
  if (t !== null) {
    if (t === e.current) throw Error(V(177));
    if (i = t.lanes | t.childLanes, i |= Mv, hN(
      e,
      n,
      i,
      o,
      s,
      l
    ), e === Fe && (Ee = Fe = null, Te = 0), Ns = t, Va = e, Vr = n, Pm = i, Im = a, qC = r, t.subtreeFlags & 10256 || t.flags & 10256 ? (e.callbackNode = null, e.callbackPriority = 0, Ik(If, function() {
      return eO(), null;
    })) : (e.callbackNode = null, e.callbackPriority = 0), r = (t.flags & 13878) !== 0, t.subtreeFlags & 13878 || r) {
      r = fe.T, fe.T = null, a = De.p, De.p = 2, o = _e, _e |= 4;
      try {
        Ak(e, t, n);
      } finally {
        _e = o, De.p = a, fe.T = r;
      }
    }
    Et = 1, XC(), WC(), ZC();
  }
}
function XC() {
  if (Et === 1) {
    Et = 0;
    var e = Va, t = Ns, n = (t.flags & 13878) !== 0;
    if (t.subtreeFlags & 13878 || n) {
      n = fe.T, fe.T = null;
      var r = De.p;
      De.p = 2;
      var a = _e;
      _e |= 4;
      try {
        MC(t, e);
        var i = Vm, o = pT(e.containerInfo), s = i.focusedElem, l = i.selectionRange;
        if (o !== s && s && s.ownerDocument && hT(
          s.ownerDocument.documentElement,
          s
        )) {
          if (l !== null && kv(s)) {
            var c = l.start, u = l.end;
            if (u === void 0 && (u = c), "selectionStart" in s)
              s.selectionStart = c, s.selectionEnd = Math.min(
                u,
                s.value.length
              );
            else {
              var f = s.ownerDocument || document, d = f && f.defaultView || window;
              if (d.getSelection) {
                var h = d.getSelection(), g = s.textContent.length, v = Math.min(l.start, g), b = l.end === void 0 ? v : Math.min(l.end, g);
                !h.extend && v > b && (o = b, b = v, v = o);
                var p = h0(
                  s,
                  v
                ), m = h0(
                  s,
                  b
                );
                if (p && m && (h.rangeCount !== 1 || h.anchorNode !== p.node || h.anchorOffset !== p.offset || h.focusNode !== m.node || h.focusOffset !== m.offset)) {
                  var w = f.createRange();
                  w.setStart(p.node, p.offset), h.removeAllRanges(), v > b ? (h.addRange(w), h.extend(m.node, m.offset)) : (w.setEnd(m.node, m.offset), h.addRange(w));
                }
              }
            }
          }
          for (f = [], h = s; h = h.parentNode; )
            h.nodeType === 1 && f.push({
              element: h,
              left: h.scrollLeft,
              top: h.scrollTop
            });
          for (typeof s.focus == "function" && s.focus(), s = 0; s < f.length; s++) {
            var x = f[s];
            x.element.scrollLeft = x.left, x.element.scrollTop = x.top;
          }
        }
        ld = !!Bm, Vm = Bm = null;
      } finally {
        _e = a, De.p = r, fe.T = n;
      }
    }
    e.current = t, Et = 2;
  }
}
function WC() {
  if (Et === 2) {
    Et = 0;
    var e = Va, t = Ns, n = (t.flags & 8772) !== 0;
    if (t.subtreeFlags & 8772 || n) {
      n = fe.T, fe.T = null;
      var r = De.p;
      De.p = 2;
      var a = _e;
      _e |= 4;
      try {
        RC(e, t.alternate, t);
      } finally {
        _e = a, De.p = r, fe.T = n;
      }
    }
    Et = 3;
  }
}
function ZC() {
  if (Et === 4 || Et === 3) {
    Et = 0, aN();
    var e = Va, t = Ns, n = Vr, r = qC;
    t.subtreeFlags & 10256 || t.flags & 10256 ? Et = 5 : (Et = 0, Ns = Va = null, JC(e, e.pendingLanes));
    var a = e.pendingLanes;
    if (a === 0 && (Ba = null), Cv(n), t = t.stateNode, gn && typeof gn.onCommitFiberRoot == "function")
      try {
        gn.onCommitFiberRoot(
          Kc,
          t,
          void 0,
          (t.current.flags & 128) === 128
        );
      } catch {
      }
    if (r !== null) {
      t = fe.T, a = De.p, De.p = 2, fe.T = null;
      try {
        for (var i = e.onRecoverableError, o = 0; o < r.length; o++) {
          var s = r[o];
          i(s.value, {
            componentStack: s.stack
          });
        }
      } finally {
        fe.T = t, De.p = a;
      }
    }
    Vr & 3 && Gd(), pr(e), a = e.pendingLanes, n & 261930 && a & 42 ? e === Fm ? nc++ : (nc = 0, Fm = e) : nc = 0, ru(0);
  }
}
function JC(e, t) {
  (e.pooledCacheLanes &= t) === 0 && (t = e.pooledCache, t != null && (e.pooledCache = null, eu(t)));
}
function Gd() {
  return XC(), WC(), ZC(), eO();
}
function eO() {
  if (Et !== 5) return !1;
  var e = Va, t = Pm;
  Pm = 0;
  var n = Cv(Vr), r = fe.T, a = De.p;
  try {
    De.p = 32 > n ? 32 : n, fe.T = null, n = Im, Im = null;
    var i = Va, o = Vr;
    if (Et = 0, Ns = Va = null, Vr = 0, _e & 6) throw Error(V(331));
    var s = _e;
    if (_e |= 4, IC(i.current), zC(
      i,
      i.current,
      o,
      n
    ), _e = s, ru(0, !1), gn && typeof gn.onPostCommitFiberRoot == "function")
      try {
        gn.onPostCommitFiberRoot(Kc, i);
      } catch {
      }
    return !0;
  } finally {
    De.p = a, fe.T = r, JC(e, t);
  }
}
function $0(e, t, n) {
  t = Dn(n, t), t = km(e.stateNode, t, 2), e = qa(e, t, 2), e !== null && (Wc(e, 2), pr(e));
}
function je(e, t, n) {
  if (e.tag === 3)
    $0(e, e, n);
  else
    for (; t !== null; ) {
      if (t.tag === 3) {
        $0(
          t,
          e,
          n
        );
        break;
      } else if (t.tag === 1) {
        var r = t.stateNode;
        if (typeof t.type.getDerivedStateFromError == "function" || typeof r.componentDidCatch == "function" && (Ba === null || !Ba.has(r))) {
          e = Dn(n, e), n = mC(2), r = qa(t, n, 2), r !== null && (gC(
            n,
            r,
            t,
            e
          ), Wc(r, 2), pr(r));
          break;
        }
      }
      t = t.return;
    }
}
function rp(e, t, n) {
  var r = e.pingCache;
  if (r === null) {
    r = e.pingCache = new Dk();
    var a = /* @__PURE__ */ new Set();
    r.set(t, a);
  } else
    a = r.get(t), a === void 0 && (a = /* @__PURE__ */ new Set(), r.set(t, a));
  a.has(n) || (oy = !0, a.add(n), e = zk.bind(null, e, t, n), t.then(e, e));
}
function zk(e, t, n) {
  var r = e.pingCache;
  r !== null && r.delete(t), e.pingedLanes |= e.suspendedLanes & n, e.warmLanes &= ~n, Fe === e && (Te & n) === n && (rt === 4 || rt === 3 && (Te & 62914560) === Te && 300 > mn() - Qd ? !(_e & 2) && ks(e, 0) : sy |= n, Ds === Te && (Ds = 0)), pr(e);
}
function tO(e, t) {
  t === 0 && (t = $S()), e = so(e, t), e !== null && (Wc(e, t), pr(e));
}
function jk(e) {
  var t = e.memoizedState, n = 0;
  t !== null && (n = t.retryLane), tO(e, n);
}
function Pk(e, t) {
  var n = 0;
  switch (e.tag) {
    case 31:
    case 13:
      var r = e.stateNode, a = e.memoizedState;
      a !== null && (n = a.retryLane);
      break;
    case 19:
      r = e.stateNode;
      break;
    case 22:
      r = e.stateNode._retryCache;
      break;
    default:
      throw Error(V(314));
  }
  r !== null && r.delete(t), tO(e, n);
}
function Ik(e, t) {
  return Sv(e, t);
}
var td = null, Oo = null, Um = !1, nd = !1, ap = !1, ja = 0;
function pr(e) {
  e !== Oo && e.next === null && (Oo === null ? td = Oo = e : Oo = Oo.next = e), nd = !0, Um || (Um = !0, Uk());
}
function ru(e, t) {
  if (!ap && nd) {
    ap = !0;
    do
      for (var n = !1, r = td; r !== null; ) {
        if (e !== 0) {
          var a = r.pendingLanes;
          if (a === 0) var i = 0;
          else {
            var o = r.suspendedLanes, s = r.pingedLanes;
            i = (1 << 31 - vn(42 | e) + 1) - 1, i &= a & ~(o & ~s), i = i & 201326741 ? i & 201326741 | 1 : i ? i | 2 : 0;
          }
          i !== 0 && (n = !0, G0(r, i));
        } else
          i = Te, i = Md(
            r,
            r === Fe ? i : 0,
            r.cancelPendingCommit !== null || r.timeoutHandle !== -1
          ), !(i & 3) || Xc(r, i) || (n = !0, G0(r, i));
        r = r.next;
      }
    while (n);
    ap = !1;
  }
}
function Fk() {
  nO();
}
function nO() {
  nd = Um = !1;
  var e = 0;
  ja !== 0 && Xk() && (e = ja);
  for (var t = mn(), n = null, r = td; r !== null; ) {
    var a = r.next, i = rO(r, t);
    i === 0 ? (r.next = null, n === null ? td = a : n.next = a, a === null && (Oo = n)) : (n = r, (e !== 0 || i & 3) && (nd = !0)), r = a;
  }
  Et !== 0 && Et !== 5 || ru(e), ja !== 0 && (ja = 0);
}
function rO(e, t) {
  for (var n = e.suspendedLanes, r = e.pingedLanes, a = e.expirationTimes, i = e.pendingLanes & -62914561; 0 < i; ) {
    var o = 31 - vn(i), s = 1 << o, l = a[o];
    l === -1 ? (!(s & n) || s & r) && (a[o] = dN(s, t)) : l <= t && (e.expiredLanes |= s), i &= ~s;
  }
  if (t = Fe, n = Te, n = Md(
    e,
    e === t ? n : 0,
    e.cancelPendingCommit !== null || e.timeoutHandle !== -1
  ), r = e.callbackNode, n === 0 || e === t && (ze === 2 || ze === 9) || e.cancelPendingCommit !== null)
    return r !== null && r !== null && kh(r), e.callbackNode = null, e.callbackPriority = 0;
  if (!(n & 3) || Xc(e, n)) {
    if (t = n & -n, t === e.callbackPriority) return t;
    switch (r !== null && kh(r), Cv(n)) {
      case 2:
      case 8:
        n = QS;
        break;
      case 32:
        n = If;
        break;
      case 268435456:
        n = HS;
        break;
      default:
        n = If;
    }
    return r = aO.bind(null, e), n = Sv(n, r), e.callbackPriority = t, e.callbackNode = n, t;
  }
  return r !== null && r !== null && kh(r), e.callbackPriority = 2, e.callbackNode = null, 2;
}
function aO(e, t) {
  if (Et !== 0 && Et !== 5)
    return e.callbackNode = null, e.callbackPriority = 0, null;
  var n = e.callbackNode;
  if (Gd() && e.callbackNode !== n)
    return null;
  var r = Te;
  return r = Md(
    e,
    e === Fe ? r : 0,
    e.cancelPendingCommit !== null || e.timeoutHandle !== -1
  ), r === 0 ? null : (VC(e, r, t), rO(e, mn()), e.callbackNode != null && e.callbackNode === n ? aO.bind(null, e) : null);
}
function G0(e, t) {
  if (Gd()) return null;
  VC(e, t, !0);
}
function Uk() {
  Zk(function() {
    _e & 6 ? Sv(
      VS,
      Fk
    ) : nO();
  });
}
function cy() {
  if (ja === 0) {
    var e = As;
    e === 0 && (e = _u, _u <<= 1, !(_u & 261888) && (_u = 256)), ja = e;
  }
  return ja;
}
function Y0(e) {
  return e == null || typeof e == "symbol" || typeof e == "boolean" ? null : typeof e == "function" ? e : sf("" + e);
}
function K0(e, t) {
  var n = t.ownerDocument.createElement("input");
  return n.name = t.name, n.value = t.value, e.id && n.setAttribute("form", e.id), t.parentNode.insertBefore(n, t), e = new FormData(e), n.parentNode.removeChild(n), e;
}
function qk(e, t, n, r, a) {
  if (t === "submit" && n && n.stateNode === a) {
    var i = Y0(
      (a[on] || null).action
    ), o = r.submitter;
    o && (t = (t = o[on] || null) ? Y0(t.formAction) : o.getAttribute("formAction"), t !== null && (i = t, o = null));
    var s = new Ld(
      "action",
      "action",
      null,
      r,
      a
    );
    e.push({
      event: s,
      listeners: [
        {
          instance: null,
          listener: function() {
            if (r.defaultPrevented) {
              if (ja !== 0) {
                var l = o ? K0(a, o) : new FormData(a);
                Dm(
                  n,
                  {
                    pending: !0,
                    data: l,
                    method: a.method,
                    action: i
                  },
                  null,
                  l
                );
              }
            } else
              typeof i == "function" && (s.preventDefault(), l = o ? K0(a, o) : new FormData(a), Dm(
                n,
                {
                  pending: !0,
                  data: l,
                  method: a.method,
                  action: i
                },
                i,
                l
              ));
          },
          currentTarget: a
        }
      ]
    });
  }
}
for (var ip = 0; ip < ym.length; ip++) {
  var op = ym[ip], Bk = op.toLowerCase(), Vk = op[0].toUpperCase() + op.slice(1);
  $n(
    Bk,
    "on" + Vk
  );
}
$n(gT, "onAnimationEnd");
$n(vT, "onAnimationIteration");
$n(yT, "onAnimationStart");
$n("dblclick", "onDoubleClick");
$n("focusin", "onFocus");
$n("focusout", "onBlur");
$n(ik, "onTransitionRun");
$n(ok, "onTransitionStart");
$n(sk, "onTransitionCancel");
$n(bT, "onTransitionEnd");
Cs("onMouseEnter", ["mouseout", "mouseover"]);
Cs("onMouseLeave", ["mouseout", "mouseover"]);
Cs("onPointerEnter", ["pointerout", "pointerover"]);
Cs("onPointerLeave", ["pointerout", "pointerover"]);
ao(
  "onChange",
  "change click focusin focusout input keydown keyup selectionchange".split(" ")
);
ao(
  "onSelect",
  "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
    " "
  )
);
ao("onBeforeInput", [
  "compositionend",
  "keypress",
  "textInput",
  "paste"
]);
ao(
  "onCompositionEnd",
  "compositionend focusout keydown keypress keyup mousedown".split(" ")
);
ao(
  "onCompositionStart",
  "compositionstart focusout keydown keypress keyup mousedown".split(" ")
);
ao(
  "onCompositionUpdate",
  "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
);
var wc = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
  " "
), Qk = new Set(
  "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(wc)
);
function iO(e, t) {
  t = (t & 4) !== 0;
  for (var n = 0; n < e.length; n++) {
    var r = e[n], a = r.event;
    r = r.listeners;
    e: {
      var i = void 0;
      if (t)
        for (var o = r.length - 1; 0 <= o; o--) {
          var s = r[o], l = s.instance, c = s.currentTarget;
          if (s = s.listener, l !== i && a.isPropagationStopped())
            break e;
          i = s, a.currentTarget = c;
          try {
            i(a);
          } catch (u) {
            Uf(u);
          }
          a.currentTarget = null, i = l;
        }
      else
        for (o = 0; o < r.length; o++) {
          if (s = r[o], l = s.instance, c = s.currentTarget, s = s.listener, l !== i && a.isPropagationStopped())
            break e;
          i = s, a.currentTarget = c;
          try {
            i(a);
          } catch (u) {
            Uf(u);
          }
          a.currentTarget = null, i = l;
        }
    }
  }
}
function xe(e, t) {
  var n = t[um];
  n === void 0 && (n = t[um] = /* @__PURE__ */ new Set());
  var r = e + "__bubble";
  n.has(r) || (oO(t, e, 2, !1), n.add(r));
}
function sp(e, t, n) {
  var r = 0;
  t && (r |= 4), oO(
    n,
    e,
    r,
    t
  );
}
var Fu = "_reactListening" + Math.random().toString(36).slice(2);
function uy(e) {
  if (!e[Fu]) {
    e[Fu] = !0, WS.forEach(function(n) {
      n !== "selectionchange" && (Qk.has(n) || sp(n, !1, e), sp(n, !0, e));
    });
    var t = e.nodeType === 9 ? e : e.ownerDocument;
    t === null || t[Fu] || (t[Fu] = !0, sp("selectionchange", !1, t));
  }
}
function oO(e, t, n, r) {
  switch (bO(t)) {
    case 2:
      var a = yM;
      break;
    case 8:
      a = bM;
      break;
    default:
      a = py;
  }
  n = a.bind(
    null,
    t,
    n,
    e
  ), a = void 0, !mm || t !== "touchstart" && t !== "touchmove" && t !== "wheel" || (a = !0), r ? a !== void 0 ? e.addEventListener(t, n, {
    capture: !0,
    passive: a
  }) : e.addEventListener(t, n, !0) : a !== void 0 ? e.addEventListener(t, n, {
    passive: a
  }) : e.addEventListener(t, n, !1);
}
function lp(e, t, n, r, a) {
  var i = r;
  if (!(t & 1) && !(t & 2) && r !== null)
    e: for (; ; ) {
      if (r === null) return;
      var o = r.tag;
      if (o === 3 || o === 4) {
        var s = r.stateNode.containerInfo;
        if (s === a) break;
        if (o === 4)
          for (o = r.return; o !== null; ) {
            var l = o.tag;
            if ((l === 3 || l === 4) && o.stateNode.containerInfo === a)
              return;
            o = o.return;
          }
        for (; s !== null; ) {
          if (o = Lo(s), o === null) return;
          if (l = o.tag, l === 5 || l === 6 || l === 26 || l === 27) {
            r = i = o;
            continue e;
          }
          s = s.parentNode;
        }
      }
      r = r.return;
    }
  iT(function() {
    var c = i, u = Rv(n), f = [];
    e: {
      var d = wT.get(e);
      if (d !== void 0) {
        var h = Ld, g = e;
        switch (e) {
          case "keypress":
            if (cf(n) === 0) break e;
          case "keydown":
          case "keyup":
            h = PN;
            break;
          case "focusin":
            g = "focus", h = Ph;
            break;
          case "focusout":
            g = "blur", h = Ph;
            break;
          case "beforeblur":
          case "afterblur":
            h = Ph;
            break;
          case "click":
            if (n.button === 2) break e;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            h = r0;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            h = CN;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            h = UN;
            break;
          case gT:
          case vT:
          case yT:
            h = RN;
            break;
          case bT:
            h = BN;
            break;
          case "scroll":
          case "scrollend":
            h = SN;
            break;
          case "wheel":
            h = QN;
            break;
          case "copy":
          case "cut":
          case "paste":
            h = DN;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            h = i0;
            break;
          case "toggle":
          case "beforetoggle":
            h = $N;
        }
        var v = (t & 4) !== 0, b = !v && (e === "scroll" || e === "scrollend"), p = v ? d !== null ? d + "Capture" : null : d;
        v = [];
        for (var m = c, w; m !== null; ) {
          var x = m;
          if (w = x.stateNode, x = x.tag, x !== 5 && x !== 26 && x !== 27 || w === null || p === null || (x = dc(m, p), x != null && v.push(
            xc(m, x, w)
          )), b) break;
          m = m.return;
        }
        0 < v.length && (d = new h(
          d,
          g,
          null,
          n,
          u
        ), f.push({ event: d, listeners: v }));
      }
    }
    if (!(t & 7)) {
      e: {
        if (d = e === "mouseover" || e === "pointerover", h = e === "mouseout" || e === "pointerout", d && n !== pm && (g = n.relatedTarget || n.fromElement) && (Lo(g) || g[Qs]))
          break e;
        if ((h || d) && (d = u.window === u ? u : (d = u.ownerDocument) ? d.defaultView || d.parentWindow : window, h ? (g = n.relatedTarget || n.toElement, h = c, g = g ? Lo(g) : null, g !== null && (b = Yc(g), v = g.tag, g !== b || v !== 5 && v !== 27 && v !== 6) && (g = null)) : (h = null, g = c), h !== g)) {
          if (v = r0, x = "onMouseLeave", p = "onMouseEnter", m = "mouse", (e === "pointerout" || e === "pointerover") && (v = i0, x = "onPointerLeave", p = "onPointerEnter", m = "pointer"), b = h == null ? d : Ll(h), w = g == null ? d : Ll(g), d = new v(
            x,
            m + "leave",
            h,
            n,
            u
          ), d.target = b, d.relatedTarget = w, x = null, Lo(u) === c && (v = new v(
            p,
            m + "enter",
            g,
            n,
            u
          ), v.target = w, v.relatedTarget = b, x = v), b = x, h && g)
            t: {
              for (v = Hk, p = h, m = g, w = 0, x = p; x; x = v(x))
                w++;
              x = 0;
              for (var S = m; S; S = v(S))
                x++;
              for (; 0 < w - x; )
                p = v(p), w--;
              for (; 0 < x - w; )
                m = v(m), x--;
              for (; w--; ) {
                if (p === m || m !== null && p === m.alternate) {
                  v = p;
                  break t;
                }
                p = v(p), m = v(m);
              }
              v = null;
            }
          else v = null;
          h !== null && X0(
            f,
            d,
            h,
            v,
            !1
          ), g !== null && b !== null && X0(
            f,
            b,
            g,
            v,
            !0
          );
        }
      }
      e: {
        if (d = c ? Ll(c) : window, h = d.nodeName && d.nodeName.toLowerCase(), h === "select" || h === "input" && d.type === "file")
          var T = c0;
        else if (l0(d))
          if (fT)
            T = nk;
          else {
            T = ek;
            var E = JN;
          }
        else
          h = d.nodeName, !h || h.toLowerCase() !== "input" || d.type !== "checkbox" && d.type !== "radio" ? c && Av(c.elementType) && (T = c0) : T = tk;
        if (T && (T = T(e, c))) {
          uT(
            f,
            T,
            n,
            u
          );
          break e;
        }
        E && E(e, d, c), e === "focusout" && c && d.type === "number" && c.memoizedProps.value != null && hm(d, "number", d.value);
      }
      switch (E = c ? Ll(c) : window, e) {
        case "focusin":
          (l0(E) || E.contentEditable === "true") && (Po = E, gm = c, Gl = null);
          break;
        case "focusout":
          Gl = gm = Po = null;
          break;
        case "mousedown":
          vm = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          vm = !1, p0(f, n, u);
          break;
        case "selectionchange":
          if (ak) break;
        case "keydown":
        case "keyup":
          p0(f, n, u);
      }
      var O;
      if (Nv)
        e: {
          switch (e) {
            case "compositionstart":
              var D = "onCompositionStart";
              break e;
            case "compositionend":
              D = "onCompositionEnd";
              break e;
            case "compositionupdate":
              D = "onCompositionUpdate";
              break e;
          }
          D = void 0;
        }
      else
        jo ? lT(e, n) && (D = "onCompositionEnd") : e === "keydown" && n.keyCode === 229 && (D = "onCompositionStart");
      D && (sT && n.locale !== "ko" && (jo || D !== "onCompositionStart" ? D === "onCompositionEnd" && jo && (O = oT()) : (Ma = u, _v = "value" in Ma ? Ma.value : Ma.textContent, jo = !0)), E = rd(c, D), 0 < E.length && (D = new a0(
        D,
        e,
        null,
        n,
        u
      ), f.push({ event: D, listeners: E }), O ? D.data = O : (O = cT(n), O !== null && (D.data = O)))), (O = YN ? KN(e, n) : XN(e, n)) && (D = rd(c, "onBeforeInput"), 0 < D.length && (E = new a0(
        "onBeforeInput",
        "beforeinput",
        null,
        n,
        u
      ), f.push({
        event: E,
        listeners: D
      }), E.data = O)), qk(
        f,
        e,
        c,
        n,
        u
      );
    }
    iO(f, t);
  });
}
function xc(e, t, n) {
  return {
    instance: e,
    listener: t,
    currentTarget: n
  };
}
function rd(e, t) {
  for (var n = t + "Capture", r = []; e !== null; ) {
    var a = e, i = a.stateNode;
    if (a = a.tag, a !== 5 && a !== 26 && a !== 27 || i === null || (a = dc(e, n), a != null && r.unshift(
      xc(e, a, i)
    ), a = dc(e, t), a != null && r.push(
      xc(e, a, i)
    )), e.tag === 3) return r;
    e = e.return;
  }
  return [];
}
function Hk(e) {
  if (e === null) return null;
  do
    e = e.return;
  while (e && e.tag !== 5 && e.tag !== 27);
  return e || null;
}
function X0(e, t, n, r, a) {
  for (var i = t._reactName, o = []; n !== null && n !== r; ) {
    var s = n, l = s.alternate, c = s.stateNode;
    if (s = s.tag, l !== null && l === r) break;
    s !== 5 && s !== 26 && s !== 27 || c === null || (l = c, a ? (c = dc(n, i), c != null && o.unshift(
      xc(n, c, l)
    )) : a || (c = dc(n, i), c != null && o.push(
      xc(n, c, l)
    ))), n = n.return;
  }
  o.length !== 0 && e.push({ event: t, listeners: o });
}
var $k = /\r\n?/g, Gk = /\u0000|\uFFFD/g;
function W0(e) {
  return (typeof e == "string" ? e : "" + e).replace($k, `
`).replace(Gk, "");
}
function sO(e, t) {
  return t = W0(t), W0(e) === t;
}
function Pe(e, t, n, r, a, i) {
  switch (n) {
    case "children":
      typeof r == "string" ? t === "body" || t === "textarea" && r === "" || Os(e, r) : (typeof r == "number" || typeof r == "bigint") && t !== "body" && Os(e, "" + r);
      break;
    case "className":
      ku(e, "class", r);
      break;
    case "tabIndex":
      ku(e, "tabindex", r);
      break;
    case "dir":
    case "role":
    case "viewBox":
    case "width":
    case "height":
      ku(e, n, r);
      break;
    case "style":
      aT(e, r, i);
      break;
    case "data":
      if (t !== "object") {
        ku(e, "data", r);
        break;
      }
    case "src":
    case "href":
      if (r === "" && (t !== "a" || n !== "href")) {
        e.removeAttribute(n);
        break;
      }
      if (r == null || typeof r == "function" || typeof r == "symbol" || typeof r == "boolean") {
        e.removeAttribute(n);
        break;
      }
      r = sf("" + r), e.setAttribute(n, r);
      break;
    case "action":
    case "formAction":
      if (typeof r == "function") {
        e.setAttribute(
          n,
          "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
        );
        break;
      } else
        typeof i == "function" && (n === "formAction" ? (t !== "input" && Pe(e, t, "name", a.name, a, null), Pe(
          e,
          t,
          "formEncType",
          a.formEncType,
          a,
          null
        ), Pe(
          e,
          t,
          "formMethod",
          a.formMethod,
          a,
          null
        ), Pe(
          e,
          t,
          "formTarget",
          a.formTarget,
          a,
          null
        )) : (Pe(e, t, "encType", a.encType, a, null), Pe(e, t, "method", a.method, a, null), Pe(e, t, "target", a.target, a, null)));
      if (r == null || typeof r == "symbol" || typeof r == "boolean") {
        e.removeAttribute(n);
        break;
      }
      r = sf("" + r), e.setAttribute(n, r);
      break;
    case "onClick":
      r != null && (e.onclick = Fr);
      break;
    case "onScroll":
      r != null && xe("scroll", e);
      break;
    case "onScrollEnd":
      r != null && xe("scrollend", e);
      break;
    case "dangerouslySetInnerHTML":
      if (r != null) {
        if (typeof r != "object" || !("__html" in r))
          throw Error(V(61));
        if (n = r.__html, n != null) {
          if (a.children != null) throw Error(V(60));
          e.innerHTML = n;
        }
      }
      break;
    case "multiple":
      e.multiple = r && typeof r != "function" && typeof r != "symbol";
      break;
    case "muted":
      e.muted = r && typeof r != "function" && typeof r != "symbol";
      break;
    case "suppressContentEditableWarning":
    case "suppressHydrationWarning":
    case "defaultValue":
    case "defaultChecked":
    case "innerHTML":
    case "ref":
      break;
    case "autoFocus":
      break;
    case "xlinkHref":
      if (r == null || typeof r == "function" || typeof r == "boolean" || typeof r == "symbol") {
        e.removeAttribute("xlink:href");
        break;
      }
      n = sf("" + r), e.setAttributeNS(
        "http://www.w3.org/1999/xlink",
        "xlink:href",
        n
      );
      break;
    case "contentEditable":
    case "spellCheck":
    case "draggable":
    case "value":
    case "autoReverse":
    case "externalResourcesRequired":
    case "focusable":
    case "preserveAlpha":
      r != null && typeof r != "function" && typeof r != "symbol" ? e.setAttribute(n, "" + r) : e.removeAttribute(n);
      break;
    case "inert":
    case "allowFullScreen":
    case "async":
    case "autoPlay":
    case "controls":
    case "default":
    case "defer":
    case "disabled":
    case "disablePictureInPicture":
    case "disableRemotePlayback":
    case "formNoValidate":
    case "hidden":
    case "loop":
    case "noModule":
    case "noValidate":
    case "open":
    case "playsInline":
    case "readOnly":
    case "required":
    case "reversed":
    case "scoped":
    case "seamless":
    case "itemScope":
      r && typeof r != "function" && typeof r != "symbol" ? e.setAttribute(n, "") : e.removeAttribute(n);
      break;
    case "capture":
    case "download":
      r === !0 ? e.setAttribute(n, "") : r !== !1 && r != null && typeof r != "function" && typeof r != "symbol" ? e.setAttribute(n, r) : e.removeAttribute(n);
      break;
    case "cols":
    case "rows":
    case "size":
    case "span":
      r != null && typeof r != "function" && typeof r != "symbol" && !isNaN(r) && 1 <= r ? e.setAttribute(n, r) : e.removeAttribute(n);
      break;
    case "rowSpan":
    case "start":
      r == null || typeof r == "function" || typeof r == "symbol" || isNaN(r) ? e.removeAttribute(n) : e.setAttribute(n, r);
      break;
    case "popover":
      xe("beforetoggle", e), xe("toggle", e), of(e, "popover", r);
      break;
    case "xlinkActuate":
      Tr(
        e,
        "http://www.w3.org/1999/xlink",
        "xlink:actuate",
        r
      );
      break;
    case "xlinkArcrole":
      Tr(
        e,
        "http://www.w3.org/1999/xlink",
        "xlink:arcrole",
        r
      );
      break;
    case "xlinkRole":
      Tr(
        e,
        "http://www.w3.org/1999/xlink",
        "xlink:role",
        r
      );
      break;
    case "xlinkShow":
      Tr(
        e,
        "http://www.w3.org/1999/xlink",
        "xlink:show",
        r
      );
      break;
    case "xlinkTitle":
      Tr(
        e,
        "http://www.w3.org/1999/xlink",
        "xlink:title",
        r
      );
      break;
    case "xlinkType":
      Tr(
        e,
        "http://www.w3.org/1999/xlink",
        "xlink:type",
        r
      );
      break;
    case "xmlBase":
      Tr(
        e,
        "http://www.w3.org/XML/1998/namespace",
        "xml:base",
        r
      );
      break;
    case "xmlLang":
      Tr(
        e,
        "http://www.w3.org/XML/1998/namespace",
        "xml:lang",
        r
      );
      break;
    case "xmlSpace":
      Tr(
        e,
        "http://www.w3.org/XML/1998/namespace",
        "xml:space",
        r
      );
      break;
    case "is":
      of(e, "is", r);
      break;
    case "innerText":
    case "textContent":
      break;
    default:
      (!(2 < n.length) || n[0] !== "o" && n[0] !== "O" || n[1] !== "n" && n[1] !== "N") && (n = xN.get(n) || n, of(e, n, r));
  }
}
function qm(e, t, n, r, a, i) {
  switch (n) {
    case "style":
      aT(e, r, i);
      break;
    case "dangerouslySetInnerHTML":
      if (r != null) {
        if (typeof r != "object" || !("__html" in r))
          throw Error(V(61));
        if (n = r.__html, n != null) {
          if (a.children != null) throw Error(V(60));
          e.innerHTML = n;
        }
      }
      break;
    case "children":
      typeof r == "string" ? Os(e, r) : (typeof r == "number" || typeof r == "bigint") && Os(e, "" + r);
      break;
    case "onScroll":
      r != null && xe("scroll", e);
      break;
    case "onScrollEnd":
      r != null && xe("scrollend", e);
      break;
    case "onClick":
      r != null && (e.onclick = Fr);
      break;
    case "suppressContentEditableWarning":
    case "suppressHydrationWarning":
    case "innerHTML":
    case "ref":
      break;
    case "innerText":
    case "textContent":
      break;
    default:
      if (!ZS.hasOwnProperty(n))
        e: {
          if (n[0] === "o" && n[1] === "n" && (a = n.endsWith("Capture"), t = n.slice(2, a ? n.length - 7 : void 0), i = e[on] || null, i = i != null ? i[n] : null, typeof i == "function" && e.removeEventListener(t, i, a), typeof r == "function")) {
            typeof i != "function" && i !== null && (n in e ? e[n] = null : e.hasAttribute(n) && e.removeAttribute(n)), e.addEventListener(t, r, a);
            break e;
          }
          n in e ? e[n] = r : r === !0 ? e.setAttribute(n, "") : of(e, n, r);
        }
  }
}
function It(e, t, n) {
  switch (t) {
    case "div":
    case "span":
    case "svg":
    case "path":
    case "a":
    case "g":
    case "p":
    case "li":
      break;
    case "img":
      xe("error", e), xe("load", e);
      var r = !1, a = !1, i;
      for (i in n)
        if (n.hasOwnProperty(i)) {
          var o = n[i];
          if (o != null)
            switch (i) {
              case "src":
                r = !0;
                break;
              case "srcSet":
                a = !0;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(V(137, t));
              default:
                Pe(e, t, i, o, n, null);
            }
        }
      a && Pe(e, t, "srcSet", n.srcSet, n, null), r && Pe(e, t, "src", n.src, n, null);
      return;
    case "input":
      xe("invalid", e);
      var s = i = o = a = null, l = null, c = null;
      for (r in n)
        if (n.hasOwnProperty(r)) {
          var u = n[r];
          if (u != null)
            switch (r) {
              case "name":
                a = u;
                break;
              case "type":
                o = u;
                break;
              case "checked":
                l = u;
                break;
              case "defaultChecked":
                c = u;
                break;
              case "value":
                i = u;
                break;
              case "defaultValue":
                s = u;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                if (u != null)
                  throw Error(V(137, t));
                break;
              default:
                Pe(e, t, r, u, n, null);
            }
        }
      tT(
        e,
        i,
        s,
        l,
        c,
        o,
        a,
        !1
      );
      return;
    case "select":
      xe("invalid", e), r = o = i = null;
      for (a in n)
        if (n.hasOwnProperty(a) && (s = n[a], s != null))
          switch (a) {
            case "value":
              i = s;
              break;
            case "defaultValue":
              o = s;
              break;
            case "multiple":
              r = s;
            default:
              Pe(e, t, a, s, n, null);
          }
      t = i, n = o, e.multiple = !!r, t != null ? Wo(e, !!r, t, !1) : n != null && Wo(e, !!r, n, !0);
      return;
    case "textarea":
      xe("invalid", e), i = a = r = null;
      for (o in n)
        if (n.hasOwnProperty(o) && (s = n[o], s != null))
          switch (o) {
            case "value":
              r = s;
              break;
            case "defaultValue":
              a = s;
              break;
            case "children":
              i = s;
              break;
            case "dangerouslySetInnerHTML":
              if (s != null) throw Error(V(91));
              break;
            default:
              Pe(e, t, o, s, n, null);
          }
      rT(e, r, a, i);
      return;
    case "option":
      for (l in n)
        if (n.hasOwnProperty(l) && (r = n[l], r != null))
          switch (l) {
            case "selected":
              e.selected = r && typeof r != "function" && typeof r != "symbol";
              break;
            default:
              Pe(e, t, l, r, n, null);
          }
      return;
    case "dialog":
      xe("beforetoggle", e), xe("toggle", e), xe("cancel", e), xe("close", e);
      break;
    case "iframe":
    case "object":
      xe("load", e);
      break;
    case "video":
    case "audio":
      for (r = 0; r < wc.length; r++)
        xe(wc[r], e);
      break;
    case "image":
      xe("error", e), xe("load", e);
      break;
    case "details":
      xe("toggle", e);
      break;
    case "embed":
    case "source":
    case "link":
      xe("error", e), xe("load", e);
    case "area":
    case "base":
    case "br":
    case "col":
    case "hr":
    case "keygen":
    case "meta":
    case "param":
    case "track":
    case "wbr":
    case "menuitem":
      for (c in n)
        if (n.hasOwnProperty(c) && (r = n[c], r != null))
          switch (c) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw Error(V(137, t));
            default:
              Pe(e, t, c, r, n, null);
          }
      return;
    default:
      if (Av(t)) {
        for (u in n)
          n.hasOwnProperty(u) && (r = n[u], r !== void 0 && qm(
            e,
            t,
            u,
            r,
            n,
            void 0
          ));
        return;
      }
  }
  for (s in n)
    n.hasOwnProperty(s) && (r = n[s], r != null && Pe(e, t, s, r, n, null));
}
function Yk(e, t, n, r) {
  switch (t) {
    case "div":
    case "span":
    case "svg":
    case "path":
    case "a":
    case "g":
    case "p":
    case "li":
      break;
    case "input":
      var a = null, i = null, o = null, s = null, l = null, c = null, u = null;
      for (h in n) {
        var f = n[h];
        if (n.hasOwnProperty(h) && f != null)
          switch (h) {
            case "checked":
              break;
            case "value":
              break;
            case "defaultValue":
              l = f;
            default:
              r.hasOwnProperty(h) || Pe(e, t, h, null, r, f);
          }
      }
      for (var d in r) {
        var h = r[d];
        if (f = n[d], r.hasOwnProperty(d) && (h != null || f != null))
          switch (d) {
            case "type":
              i = h;
              break;
            case "name":
              a = h;
              break;
            case "checked":
              c = h;
              break;
            case "defaultChecked":
              u = h;
              break;
            case "value":
              o = h;
              break;
            case "defaultValue":
              s = h;
              break;
            case "children":
            case "dangerouslySetInnerHTML":
              if (h != null)
                throw Error(V(137, t));
              break;
            default:
              h !== f && Pe(
                e,
                t,
                d,
                h,
                r,
                f
              );
          }
      }
      dm(
        e,
        o,
        s,
        l,
        c,
        u,
        i,
        a
      );
      return;
    case "select":
      h = o = s = d = null;
      for (i in n)
        if (l = n[i], n.hasOwnProperty(i) && l != null)
          switch (i) {
            case "value":
              break;
            case "multiple":
              h = l;
            default:
              r.hasOwnProperty(i) || Pe(
                e,
                t,
                i,
                null,
                r,
                l
              );
          }
      for (a in r)
        if (i = r[a], l = n[a], r.hasOwnProperty(a) && (i != null || l != null))
          switch (a) {
            case "value":
              d = i;
              break;
            case "defaultValue":
              s = i;
              break;
            case "multiple":
              o = i;
            default:
              i !== l && Pe(
                e,
                t,
                a,
                i,
                r,
                l
              );
          }
      t = s, n = o, r = h, d != null ? Wo(e, !!n, d, !1) : !!r != !!n && (t != null ? Wo(e, !!n, t, !0) : Wo(e, !!n, n ? [] : "", !1));
      return;
    case "textarea":
      h = d = null;
      for (s in n)
        if (a = n[s], n.hasOwnProperty(s) && a != null && !r.hasOwnProperty(s))
          switch (s) {
            case "value":
              break;
            case "children":
              break;
            default:
              Pe(e, t, s, null, r, a);
          }
      for (o in r)
        if (a = r[o], i = n[o], r.hasOwnProperty(o) && (a != null || i != null))
          switch (o) {
            case "value":
              d = a;
              break;
            case "defaultValue":
              h = a;
              break;
            case "children":
              break;
            case "dangerouslySetInnerHTML":
              if (a != null) throw Error(V(91));
              break;
            default:
              a !== i && Pe(e, t, o, a, r, i);
          }
      nT(e, d, h);
      return;
    case "option":
      for (var g in n)
        if (d = n[g], n.hasOwnProperty(g) && d != null && !r.hasOwnProperty(g))
          switch (g) {
            case "selected":
              e.selected = !1;
              break;
            default:
              Pe(
                e,
                t,
                g,
                null,
                r,
                d
              );
          }
      for (l in r)
        if (d = r[l], h = n[l], r.hasOwnProperty(l) && d !== h && (d != null || h != null))
          switch (l) {
            case "selected":
              e.selected = d && typeof d != "function" && typeof d != "symbol";
              break;
            default:
              Pe(
                e,
                t,
                l,
                d,
                r,
                h
              );
          }
      return;
    case "img":
    case "link":
    case "area":
    case "base":
    case "br":
    case "col":
    case "embed":
    case "hr":
    case "keygen":
    case "meta":
    case "param":
    case "source":
    case "track":
    case "wbr":
    case "menuitem":
      for (var v in n)
        d = n[v], n.hasOwnProperty(v) && d != null && !r.hasOwnProperty(v) && Pe(e, t, v, null, r, d);
      for (c in r)
        if (d = r[c], h = n[c], r.hasOwnProperty(c) && d !== h && (d != null || h != null))
          switch (c) {
            case "children":
            case "dangerouslySetInnerHTML":
              if (d != null)
                throw Error(V(137, t));
              break;
            default:
              Pe(
                e,
                t,
                c,
                d,
                r,
                h
              );
          }
      return;
    default:
      if (Av(t)) {
        for (var b in n)
          d = n[b], n.hasOwnProperty(b) && d !== void 0 && !r.hasOwnProperty(b) && qm(
            e,
            t,
            b,
            void 0,
            r,
            d
          );
        for (u in r)
          d = r[u], h = n[u], !r.hasOwnProperty(u) || d === h || d === void 0 && h === void 0 || qm(
            e,
            t,
            u,
            d,
            r,
            h
          );
        return;
      }
  }
  for (var p in n)
    d = n[p], n.hasOwnProperty(p) && d != null && !r.hasOwnProperty(p) && Pe(e, t, p, null, r, d);
  for (f in r)
    d = r[f], h = n[f], !r.hasOwnProperty(f) || d === h || d == null && h == null || Pe(e, t, f, d, r, h);
}
function Z0(e) {
  switch (e) {
    case "css":
    case "script":
    case "font":
    case "img":
    case "image":
    case "input":
    case "link":
      return !0;
    default:
      return !1;
  }
}
function Kk() {
  if (typeof performance.getEntriesByType == "function") {
    for (var e = 0, t = 0, n = performance.getEntriesByType("resource"), r = 0; r < n.length; r++) {
      var a = n[r], i = a.transferSize, o = a.initiatorType, s = a.duration;
      if (i && s && Z0(o)) {
        for (o = 0, s = a.responseEnd, r += 1; r < n.length; r++) {
          var l = n[r], c = l.startTime;
          if (c > s) break;
          var u = l.transferSize, f = l.initiatorType;
          u && Z0(f) && (l = l.responseEnd, o += u * (l < s ? 1 : (s - c) / (l - c)));
        }
        if (--r, t += 8 * (i + o) / (a.duration / 1e3), e++, 10 < e) break;
      }
    }
    if (0 < e) return t / e / 1e6;
  }
  return navigator.connection && (e = navigator.connection.downlink, typeof e == "number") ? e : 5;
}
var Bm = null, Vm = null;
function ad(e) {
  return e.nodeType === 9 ? e : e.ownerDocument;
}
function J0(e) {
  switch (e) {
    case "http://www.w3.org/2000/svg":
      return 1;
    case "http://www.w3.org/1998/Math/MathML":
      return 2;
    default:
      return 0;
  }
}
function lO(e, t) {
  if (e === 0)
    switch (t) {
      case "svg":
        return 1;
      case "math":
        return 2;
      default:
        return 0;
    }
  return e === 1 && t === "foreignObject" ? 0 : e;
}
function Qm(e, t) {
  return e === "textarea" || e === "noscript" || typeof t.children == "string" || typeof t.children == "number" || typeof t.children == "bigint" || typeof t.dangerouslySetInnerHTML == "object" && t.dangerouslySetInnerHTML !== null && t.dangerouslySetInnerHTML.__html != null;
}
var cp = null;
function Xk() {
  var e = window.event;
  return e && e.type === "popstate" ? e === cp ? !1 : (cp = e, !0) : (cp = null, !1);
}
var cO = typeof setTimeout == "function" ? setTimeout : void 0, Wk = typeof clearTimeout == "function" ? clearTimeout : void 0, ew = typeof Promise == "function" ? Promise : void 0, Zk = typeof queueMicrotask == "function" ? queueMicrotask : typeof ew < "u" ? function(e) {
  return ew.resolve(null).then(e).catch(Jk);
} : cO;
function Jk(e) {
  setTimeout(function() {
    throw e;
  });
}
function ui(e) {
  return e === "head";
}
function tw(e, t) {
  var n = t, r = 0;
  do {
    var a = n.nextSibling;
    if (e.removeChild(n), a && a.nodeType === 8)
      if (n = a.data, n === "/$" || n === "/&") {
        if (r === 0) {
          e.removeChild(a), Ls(t);
          return;
        }
        r--;
      } else if (n === "$" || n === "$?" || n === "$~" || n === "$!" || n === "&")
        r++;
      else if (n === "html")
        rc(e.ownerDocument.documentElement);
      else if (n === "head") {
        n = e.ownerDocument.head, rc(n);
        for (var i = n.firstChild; i; ) {
          var o = i.nextSibling, s = i.nodeName;
          i[Zc] || s === "SCRIPT" || s === "STYLE" || s === "LINK" && i.rel.toLowerCase() === "stylesheet" || n.removeChild(i), i = o;
        }
      } else
        n === "body" && rc(e.ownerDocument.body);
    n = a;
  } while (n);
  Ls(t);
}
function nw(e, t) {
  var n = e;
  e = 0;
  do {
    var r = n.nextSibling;
    if (n.nodeType === 1 ? t ? (n._stashedDisplay = n.style.display, n.style.display = "none") : (n.style.display = n._stashedDisplay || "", n.getAttribute("style") === "" && n.removeAttribute("style")) : n.nodeType === 3 && (t ? (n._stashedText = n.nodeValue, n.nodeValue = "") : n.nodeValue = n._stashedText || ""), r && r.nodeType === 8)
      if (n = r.data, n === "/$") {
        if (e === 0) break;
        e--;
      } else
        n !== "$" && n !== "$?" && n !== "$~" && n !== "$!" || e++;
    n = r;
  } while (n);
}
function Hm(e) {
  var t = e.firstChild;
  for (t && t.nodeType === 10 && (t = t.nextSibling); t; ) {
    var n = t;
    switch (t = t.nextSibling, n.nodeName) {
      case "HTML":
      case "HEAD":
      case "BODY":
        Hm(n), Ov(n);
        continue;
      case "SCRIPT":
      case "STYLE":
        continue;
      case "LINK":
        if (n.rel.toLowerCase() === "stylesheet") continue;
    }
    e.removeChild(n);
  }
}
function eM(e, t, n, r) {
  for (; e.nodeType === 1; ) {
    var a = n;
    if (e.nodeName.toLowerCase() !== t.toLowerCase()) {
      if (!r && (e.nodeName !== "INPUT" || e.type !== "hidden"))
        break;
    } else if (r) {
      if (!e[Zc])
        switch (t) {
          case "meta":
            if (!e.hasAttribute("itemprop")) break;
            return e;
          case "link":
            if (i = e.getAttribute("rel"), i === "stylesheet" && e.hasAttribute("data-precedence"))
              break;
            if (i !== a.rel || e.getAttribute("href") !== (a.href == null || a.href === "" ? null : a.href) || e.getAttribute("crossorigin") !== (a.crossOrigin == null ? null : a.crossOrigin) || e.getAttribute("title") !== (a.title == null ? null : a.title))
              break;
            return e;
          case "style":
            if (e.hasAttribute("data-precedence")) break;
            return e;
          case "script":
            if (i = e.getAttribute("src"), (i !== (a.src == null ? null : a.src) || e.getAttribute("type") !== (a.type == null ? null : a.type) || e.getAttribute("crossorigin") !== (a.crossOrigin == null ? null : a.crossOrigin)) && i && e.hasAttribute("async") && !e.hasAttribute("itemprop"))
              break;
            return e;
          default:
            return e;
        }
    } else if (t === "input" && e.type === "hidden") {
      var i = a.name == null ? null : "" + a.name;
      if (a.type === "hidden" && e.getAttribute("name") === i)
        return e;
    } else return e;
    if (e = Mn(e.nextSibling), e === null) break;
  }
  return null;
}
function tM(e, t, n) {
  if (t === "") return null;
  for (; e.nodeType !== 3; )
    if ((e.nodeType !== 1 || e.nodeName !== "INPUT" || e.type !== "hidden") && !n || (e = Mn(e.nextSibling), e === null)) return null;
  return e;
}
function uO(e, t) {
  for (; e.nodeType !== 8; )
    if ((e.nodeType !== 1 || e.nodeName !== "INPUT" || e.type !== "hidden") && !t || (e = Mn(e.nextSibling), e === null)) return null;
  return e;
}
function $m(e) {
  return e.data === "$?" || e.data === "$~";
}
function Gm(e) {
  return e.data === "$!" || e.data === "$?" && e.ownerDocument.readyState !== "loading";
}
function nM(e, t) {
  var n = e.ownerDocument;
  if (e.data === "$~") e._reactRetry = t;
  else if (e.data !== "$?" || n.readyState !== "loading")
    t();
  else {
    var r = function() {
      t(), n.removeEventListener("DOMContentLoaded", r);
    };
    n.addEventListener("DOMContentLoaded", r), e._reactRetry = r;
  }
}
function Mn(e) {
  for (; e != null; e = e.nextSibling) {
    var t = e.nodeType;
    if (t === 1 || t === 3) break;
    if (t === 8) {
      if (t = e.data, t === "$" || t === "$!" || t === "$?" || t === "$~" || t === "&" || t === "F!" || t === "F")
        break;
      if (t === "/$" || t === "/&") return null;
    }
  }
  return e;
}
var Ym = null;
function rw(e) {
  e = e.nextSibling;
  for (var t = 0; e; ) {
    if (e.nodeType === 8) {
      var n = e.data;
      if (n === "/$" || n === "/&") {
        if (t === 0)
          return Mn(e.nextSibling);
        t--;
      } else
        n !== "$" && n !== "$!" && n !== "$?" && n !== "$~" && n !== "&" || t++;
    }
    e = e.nextSibling;
  }
  return null;
}
function aw(e) {
  e = e.previousSibling;
  for (var t = 0; e; ) {
    if (e.nodeType === 8) {
      var n = e.data;
      if (n === "$" || n === "$!" || n === "$?" || n === "$~" || n === "&") {
        if (t === 0) return e;
        t--;
      } else n !== "/$" && n !== "/&" || t++;
    }
    e = e.previousSibling;
  }
  return null;
}
function fO(e, t, n) {
  switch (t = ad(n), e) {
    case "html":
      if (e = t.documentElement, !e) throw Error(V(452));
      return e;
    case "head":
      if (e = t.head, !e) throw Error(V(453));
      return e;
    case "body":
      if (e = t.body, !e) throw Error(V(454));
      return e;
    default:
      throw Error(V(451));
  }
}
function rc(e) {
  for (var t = e.attributes; t.length; )
    e.removeAttributeNode(t[0]);
  Ov(e);
}
var zn = /* @__PURE__ */ new Map(), iw = /* @__PURE__ */ new Set();
function id(e) {
  return typeof e.getRootNode == "function" ? e.getRootNode() : e.nodeType === 9 ? e : e.ownerDocument;
}
var ea = De.d;
De.d = {
  f: rM,
  r: aM,
  D: iM,
  C: oM,
  L: sM,
  m: lM,
  X: uM,
  S: cM,
  M: fM
};
function rM() {
  var e = ea.f(), t = Hd();
  return e || t;
}
function aM(e) {
  var t = Hs(e);
  t !== null && t.tag === 5 && t.type === "form" ? aC(t) : ea.r(e);
}
var Ks = typeof document > "u" ? null : document;
function dO(e, t, n) {
  var r = Ks;
  if (r && typeof t == "string" && t) {
    var a = _n(t);
    a = 'link[rel="' + e + '"][href="' + a + '"]', typeof n == "string" && (a += '[crossorigin="' + n + '"]'), iw.has(a) || (iw.add(a), e = { rel: e, crossOrigin: n, href: t }, r.querySelector(a) === null && (t = r.createElement("link"), It(t, "link", e), _t(t), r.head.appendChild(t)));
  }
}
function iM(e) {
  ea.D(e), dO("dns-prefetch", e, null);
}
function oM(e, t) {
  ea.C(e, t), dO("preconnect", e, t);
}
function sM(e, t, n) {
  ea.L(e, t, n);
  var r = Ks;
  if (r && e && t) {
    var a = 'link[rel="preload"][as="' + _n(t) + '"]';
    t === "image" && n && n.imageSrcSet ? (a += '[imagesrcset="' + _n(
      n.imageSrcSet
    ) + '"]', typeof n.imageSizes == "string" && (a += '[imagesizes="' + _n(
      n.imageSizes
    ) + '"]')) : a += '[href="' + _n(e) + '"]';
    var i = a;
    switch (t) {
      case "style":
        i = Ms(e);
        break;
      case "script":
        i = Xs(e);
    }
    zn.has(i) || (e = Xe(
      {
        rel: "preload",
        href: t === "image" && n && n.imageSrcSet ? void 0 : e,
        as: t
      },
      n
    ), zn.set(i, e), r.querySelector(a) !== null || t === "style" && r.querySelector(au(i)) || t === "script" && r.querySelector(iu(i)) || (t = r.createElement("link"), It(t, "link", e), _t(t), r.head.appendChild(t)));
  }
}
function lM(e, t) {
  ea.m(e, t);
  var n = Ks;
  if (n && e) {
    var r = t && typeof t.as == "string" ? t.as : "script", a = 'link[rel="modulepreload"][as="' + _n(r) + '"][href="' + _n(e) + '"]', i = a;
    switch (r) {
      case "audioworklet":
      case "paintworklet":
      case "serviceworker":
      case "sharedworker":
      case "worker":
      case "script":
        i = Xs(e);
    }
    if (!zn.has(i) && (e = Xe({ rel: "modulepreload", href: e }, t), zn.set(i, e), n.querySelector(a) === null)) {
      switch (r) {
        case "audioworklet":
        case "paintworklet":
        case "serviceworker":
        case "sharedworker":
        case "worker":
        case "script":
          if (n.querySelector(iu(i)))
            return;
      }
      r = n.createElement("link"), It(r, "link", e), _t(r), n.head.appendChild(r);
    }
  }
}
function cM(e, t, n) {
  ea.S(e, t, n);
  var r = Ks;
  if (r && e) {
    var a = Xo(r).hoistableStyles, i = Ms(e);
    t = t || "default";
    var o = a.get(i);
    if (!o) {
      var s = { loading: 0, preload: null };
      if (o = r.querySelector(
        au(i)
      ))
        s.loading = 5;
      else {
        e = Xe(
          { rel: "stylesheet", href: e, "data-precedence": t },
          n
        ), (n = zn.get(i)) && fy(e, n);
        var l = o = r.createElement("link");
        _t(l), It(l, "link", e), l._p = new Promise(function(c, u) {
          l.onload = c, l.onerror = u;
        }), l.addEventListener("load", function() {
          s.loading |= 1;
        }), l.addEventListener("error", function() {
          s.loading |= 2;
        }), s.loading |= 4, vf(o, t, r);
      }
      o = {
        type: "stylesheet",
        instance: o,
        count: 1,
        state: s
      }, a.set(i, o);
    }
  }
}
function uM(e, t) {
  ea.X(e, t);
  var n = Ks;
  if (n && e) {
    var r = Xo(n).hoistableScripts, a = Xs(e), i = r.get(a);
    i || (i = n.querySelector(iu(a)), i || (e = Xe({ src: e, async: !0 }, t), (t = zn.get(a)) && dy(e, t), i = n.createElement("script"), _t(i), It(i, "link", e), n.head.appendChild(i)), i = {
      type: "script",
      instance: i,
      count: 1,
      state: null
    }, r.set(a, i));
  }
}
function fM(e, t) {
  ea.M(e, t);
  var n = Ks;
  if (n && e) {
    var r = Xo(n).hoistableScripts, a = Xs(e), i = r.get(a);
    i || (i = n.querySelector(iu(a)), i || (e = Xe({ src: e, async: !0, type: "module" }, t), (t = zn.get(a)) && dy(e, t), i = n.createElement("script"), _t(i), It(i, "link", e), n.head.appendChild(i)), i = {
      type: "script",
      instance: i,
      count: 1,
      state: null
    }, r.set(a, i));
  }
}
function ow(e, t, n, r) {
  var a = (a = Ia.current) ? id(a) : null;
  if (!a) throw Error(V(446));
  switch (e) {
    case "meta":
    case "title":
      return null;
    case "style":
      return typeof n.precedence == "string" && typeof n.href == "string" ? (t = Ms(n.href), n = Xo(
        a
      ).hoistableStyles, r = n.get(t), r || (r = {
        type: "style",
        instance: null,
        count: 0,
        state: null
      }, n.set(t, r)), r) : { type: "void", instance: null, count: 0, state: null };
    case "link":
      if (n.rel === "stylesheet" && typeof n.href == "string" && typeof n.precedence == "string") {
        e = Ms(n.href);
        var i = Xo(
          a
        ).hoistableStyles, o = i.get(e);
        if (o || (a = a.ownerDocument || a, o = {
          type: "stylesheet",
          instance: null,
          count: 0,
          state: { loading: 0, preload: null }
        }, i.set(e, o), (i = a.querySelector(
          au(e)
        )) && !i._p && (o.instance = i, o.state.loading = 5), zn.has(e) || (n = {
          rel: "preload",
          as: "style",
          href: n.href,
          crossOrigin: n.crossOrigin,
          integrity: n.integrity,
          media: n.media,
          hrefLang: n.hrefLang,
          referrerPolicy: n.referrerPolicy
        }, zn.set(e, n), i || dM(
          a,
          e,
          n,
          o.state
        ))), t && r === null)
          throw Error(V(528, ""));
        return o;
      }
      if (t && r !== null)
        throw Error(V(529, ""));
      return null;
    case "script":
      return t = n.async, n = n.src, typeof n == "string" && t && typeof t != "function" && typeof t != "symbol" ? (t = Xs(n), n = Xo(
        a
      ).hoistableScripts, r = n.get(t), r || (r = {
        type: "script",
        instance: null,
        count: 0,
        state: null
      }, n.set(t, r)), r) : { type: "void", instance: null, count: 0, state: null };
    default:
      throw Error(V(444, e));
  }
}
function Ms(e) {
  return 'href="' + _n(e) + '"';
}
function au(e) {
  return 'link[rel="stylesheet"][' + e + "]";
}
function hO(e) {
  return Xe({}, e, {
    "data-precedence": e.precedence,
    precedence: null
  });
}
function dM(e, t, n, r) {
  e.querySelector('link[rel="preload"][as="style"][' + t + "]") ? r.loading = 1 : (t = e.createElement("link"), r.preload = t, t.addEventListener("load", function() {
    return r.loading |= 1;
  }), t.addEventListener("error", function() {
    return r.loading |= 2;
  }), It(t, "link", n), _t(t), e.head.appendChild(t));
}
function Xs(e) {
  return '[src="' + _n(e) + '"]';
}
function iu(e) {
  return "script[async]" + e;
}
function sw(e, t, n) {
  if (t.count++, t.instance === null)
    switch (t.type) {
      case "style":
        var r = e.querySelector(
          'style[data-href~="' + _n(n.href) + '"]'
        );
        if (r)
          return t.instance = r, _t(r), r;
        var a = Xe({}, n, {
          "data-href": n.href,
          "data-precedence": n.precedence,
          href: null,
          precedence: null
        });
        return r = (e.ownerDocument || e).createElement(
          "style"
        ), _t(r), It(r, "style", a), vf(r, n.precedence, e), t.instance = r;
      case "stylesheet":
        a = Ms(n.href);
        var i = e.querySelector(
          au(a)
        );
        if (i)
          return t.state.loading |= 4, t.instance = i, _t(i), i;
        r = hO(n), (a = zn.get(a)) && fy(r, a), i = (e.ownerDocument || e).createElement("link"), _t(i);
        var o = i;
        return o._p = new Promise(function(s, l) {
          o.onload = s, o.onerror = l;
        }), It(i, "link", r), t.state.loading |= 4, vf(i, n.precedence, e), t.instance = i;
      case "script":
        return i = Xs(n.src), (a = e.querySelector(
          iu(i)
        )) ? (t.instance = a, _t(a), a) : (r = n, (a = zn.get(i)) && (r = Xe({}, n), dy(r, a)), e = e.ownerDocument || e, a = e.createElement("script"), _t(a), It(a, "link", r), e.head.appendChild(a), t.instance = a);
      case "void":
        return null;
      default:
        throw Error(V(443, t.type));
    }
  else
    t.type === "stylesheet" && !(t.state.loading & 4) && (r = t.instance, t.state.loading |= 4, vf(r, n.precedence, e));
  return t.instance;
}
function vf(e, t, n) {
  for (var r = n.querySelectorAll(
    'link[rel="stylesheet"][data-precedence],style[data-precedence]'
  ), a = r.length ? r[r.length - 1] : null, i = a, o = 0; o < r.length; o++) {
    var s = r[o];
    if (s.dataset.precedence === t) i = s;
    else if (i !== a) break;
  }
  i ? i.parentNode.insertBefore(e, i.nextSibling) : (t = n.nodeType === 9 ? n.head : n, t.insertBefore(e, t.firstChild));
}
function fy(e, t) {
  e.crossOrigin == null && (e.crossOrigin = t.crossOrigin), e.referrerPolicy == null && (e.referrerPolicy = t.referrerPolicy), e.title == null && (e.title = t.title);
}
function dy(e, t) {
  e.crossOrigin == null && (e.crossOrigin = t.crossOrigin), e.referrerPolicy == null && (e.referrerPolicy = t.referrerPolicy), e.integrity == null && (e.integrity = t.integrity);
}
var yf = null;
function lw(e, t, n) {
  if (yf === null) {
    var r = /* @__PURE__ */ new Map(), a = yf = /* @__PURE__ */ new Map();
    a.set(n, r);
  } else
    a = yf, r = a.get(n), r || (r = /* @__PURE__ */ new Map(), a.set(n, r));
  if (r.has(e)) return r;
  for (r.set(e, null), n = n.getElementsByTagName(e), a = 0; a < n.length; a++) {
    var i = n[a];
    if (!(i[Zc] || i[zt] || e === "link" && i.getAttribute("rel") === "stylesheet") && i.namespaceURI !== "http://www.w3.org/2000/svg") {
      var o = i.getAttribute(t) || "";
      o = e + o;
      var s = r.get(o);
      s ? s.push(i) : r.set(o, [i]);
    }
  }
  return r;
}
function cw(e, t, n) {
  e = e.ownerDocument || e, e.head.insertBefore(
    n,
    t === "title" ? e.querySelector("head > title") : null
  );
}
function hM(e, t, n) {
  if (n === 1 || t.itemProp != null) return !1;
  switch (e) {
    case "meta":
    case "title":
      return !0;
    case "style":
      if (typeof t.precedence != "string" || typeof t.href != "string" || t.href === "")
        break;
      return !0;
    case "link":
      if (typeof t.rel != "string" || typeof t.href != "string" || t.href === "" || t.onLoad || t.onError)
        break;
      switch (t.rel) {
        case "stylesheet":
          return e = t.disabled, typeof t.precedence == "string" && e == null;
        default:
          return !0;
      }
    case "script":
      if (t.async && typeof t.async != "function" && typeof t.async != "symbol" && !t.onLoad && !t.onError && t.src && typeof t.src == "string")
        return !0;
  }
  return !1;
}
function pO(e) {
  return !(e.type === "stylesheet" && !(e.state.loading & 3));
}
function pM(e, t, n, r) {
  if (n.type === "stylesheet" && (typeof r.media != "string" || matchMedia(r.media).matches !== !1) && !(n.state.loading & 4)) {
    if (n.instance === null) {
      var a = Ms(r.href), i = t.querySelector(
        au(a)
      );
      if (i) {
        t = i._p, t !== null && typeof t == "object" && typeof t.then == "function" && (e.count++, e = od.bind(e), t.then(e, e)), n.state.loading |= 4, n.instance = i, _t(i);
        return;
      }
      i = t.ownerDocument || t, r = hO(r), (a = zn.get(a)) && fy(r, a), i = i.createElement("link"), _t(i);
      var o = i;
      o._p = new Promise(function(s, l) {
        o.onload = s, o.onerror = l;
      }), It(i, "link", r), n.instance = i;
    }
    e.stylesheets === null && (e.stylesheets = /* @__PURE__ */ new Map()), e.stylesheets.set(n, t), (t = n.state.preload) && !(n.state.loading & 3) && (e.count++, n = od.bind(e), t.addEventListener("load", n), t.addEventListener("error", n));
  }
}
var up = 0;
function mM(e, t) {
  return e.stylesheets && e.count === 0 && bf(e, e.stylesheets), 0 < e.count || 0 < e.imgCount ? function(n) {
    var r = setTimeout(function() {
      if (e.stylesheets && bf(e, e.stylesheets), e.unsuspend) {
        var i = e.unsuspend;
        e.unsuspend = null, i();
      }
    }, 6e4 + t);
    0 < e.imgBytes && up === 0 && (up = 62500 * Kk());
    var a = setTimeout(
      function() {
        if (e.waitingForImages = !1, e.count === 0 && (e.stylesheets && bf(e, e.stylesheets), e.unsuspend)) {
          var i = e.unsuspend;
          e.unsuspend = null, i();
        }
      },
      (e.imgBytes > up ? 50 : 800) + t
    );
    return e.unsuspend = n, function() {
      e.unsuspend = null, clearTimeout(r), clearTimeout(a);
    };
  } : null;
}
function od() {
  if (this.count--, this.count === 0 && (this.imgCount === 0 || !this.waitingForImages)) {
    if (this.stylesheets) bf(this, this.stylesheets);
    else if (this.unsuspend) {
      var e = this.unsuspend;
      this.unsuspend = null, e();
    }
  }
}
var sd = null;
function bf(e, t) {
  e.stylesheets = null, e.unsuspend !== null && (e.count++, sd = /* @__PURE__ */ new Map(), t.forEach(gM, e), sd = null, od.call(e));
}
function gM(e, t) {
  if (!(t.state.loading & 4)) {
    var n = sd.get(e);
    if (n) var r = n.get(null);
    else {
      n = /* @__PURE__ */ new Map(), sd.set(e, n);
      for (var a = e.querySelectorAll(
        "link[data-precedence],style[data-precedence]"
      ), i = 0; i < a.length; i++) {
        var o = a[i];
        (o.nodeName === "LINK" || o.getAttribute("media") !== "not all") && (n.set(o.dataset.precedence, o), r = o);
      }
      r && n.set(null, r);
    }
    a = t.instance, o = a.getAttribute("data-precedence"), i = n.get(o) || r, i === r && n.set(null, a), n.set(o, a), this.count++, r = od.bind(this), a.addEventListener("load", r), a.addEventListener("error", r), i ? i.parentNode.insertBefore(a, i.nextSibling) : (e = e.nodeType === 9 ? e.head : e, e.insertBefore(a, e.firstChild)), t.state.loading |= 4;
  }
}
var Ec = {
  $$typeof: Ir,
  Provider: null,
  Consumer: null,
  _currentValue: Ui,
  _currentValue2: Ui,
  _threadCount: 0
};
function vM(e, t, n, r, a, i, o, s, l) {
  this.tag = 1, this.containerInfo = e, this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = Mh(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Mh(0), this.hiddenUpdates = Mh(null), this.identifierPrefix = r, this.onUncaughtError = a, this.onCaughtError = i, this.onRecoverableError = o, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = l, this.incompleteTransitions = /* @__PURE__ */ new Map();
}
function mO(e, t, n, r, a, i, o, s, l, c, u, f) {
  return e = new vM(
    e,
    t,
    n,
    o,
    l,
    c,
    u,
    f,
    s
  ), t = 1, i === !0 && (t |= 24), i = hn(3, null, null, t), e.current = i, i.stateNode = e, t = Iv(), t.refCount++, e.pooledCache = t, t.refCount++, i.memoizedState = {
    element: r,
    isDehydrated: n,
    cache: t
  }, qv(i), e;
}
function gO(e) {
  return e ? (e = Uo, e) : Uo;
}
function vO(e, t, n, r, a, i) {
  a = gO(a), r.context === null ? r.context = a : r.pendingContext = a, r = Ua(t), r.payload = { element: n }, i = i === void 0 ? null : i, i !== null && (r.callback = i), n = qa(e, r, t), n !== null && (an(n, e, t), Kl(n, e, t));
}
function uw(e, t) {
  if (e = e.memoizedState, e !== null && e.dehydrated !== null) {
    var n = e.retryLane;
    e.retryLane = n !== 0 && n < t ? n : t;
  }
}
function hy(e, t) {
  uw(e, t), (e = e.alternate) && uw(e, t);
}
function yO(e) {
  if (e.tag === 13 || e.tag === 31) {
    var t = so(e, 67108864);
    t !== null && an(t, e, 67108864), hy(e, 67108864);
  }
}
function fw(e) {
  if (e.tag === 13 || e.tag === 31) {
    var t = yn();
    t = Tv(t);
    var n = so(e, t);
    n !== null && an(n, e, t), hy(e, t);
  }
}
var ld = !0;
function yM(e, t, n, r) {
  var a = fe.T;
  fe.T = null;
  var i = De.p;
  try {
    De.p = 2, py(e, t, n, r);
  } finally {
    De.p = i, fe.T = a;
  }
}
function bM(e, t, n, r) {
  var a = fe.T;
  fe.T = null;
  var i = De.p;
  try {
    De.p = 8, py(e, t, n, r);
  } finally {
    De.p = i, fe.T = a;
  }
}
function py(e, t, n, r) {
  if (ld) {
    var a = Km(r);
    if (a === null)
      lp(
        e,
        t,
        r,
        cd,
        n
      ), dw(e, r);
    else if (xM(
      a,
      e,
      t,
      n,
      r
    ))
      r.stopPropagation();
    else if (dw(e, r), t & 4 && -1 < wM.indexOf(e)) {
      for (; a !== null; ) {
        var i = Hs(a);
        if (i !== null)
          switch (i.tag) {
            case 3:
              if (i = i.stateNode, i.current.memoizedState.isDehydrated) {
                var o = wi(i.pendingLanes);
                if (o !== 0) {
                  var s = i;
                  for (s.pendingLanes |= 2, s.entangledLanes |= 2; o; ) {
                    var l = 1 << 31 - vn(o);
                    s.entanglements[1] |= l, o &= ~l;
                  }
                  pr(i), !(_e & 6) && (Zf = mn() + 500, ru(0));
                }
              }
              break;
            case 31:
            case 13:
              s = so(i, 2), s !== null && an(s, i, 2), Hd(), hy(i, 2);
          }
        if (i = Km(r), i === null && lp(
          e,
          t,
          r,
          cd,
          n
        ), i === a) break;
        a = i;
      }
      a !== null && r.stopPropagation();
    } else
      lp(
        e,
        t,
        r,
        null,
        n
      );
  }
}
function Km(e) {
  return e = Rv(e), my(e);
}
var cd = null;
function my(e) {
  if (cd = null, e = Lo(e), e !== null) {
    var t = Yc(e);
    if (t === null) e = null;
    else {
      var n = t.tag;
      if (n === 13) {
        if (e = IS(t), e !== null) return e;
        e = null;
      } else if (n === 31) {
        if (e = FS(t), e !== null) return e;
        e = null;
      } else if (n === 3) {
        if (t.stateNode.current.memoizedState.isDehydrated)
          return t.tag === 3 ? t.stateNode.containerInfo : null;
        e = null;
      } else t !== e && (e = null);
    }
  }
  return cd = e, null;
}
function bO(e) {
  switch (e) {
    case "beforetoggle":
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "toggle":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 2;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 8;
    case "message":
      switch (iN()) {
        case VS:
          return 2;
        case QS:
          return 8;
        case If:
        case oN:
          return 32;
        case HS:
          return 268435456;
        default:
          return 32;
      }
    default:
      return 32;
  }
}
var Xm = !1, Qa = null, Ha = null, $a = null, Sc = /* @__PURE__ */ new Map(), Tc = /* @__PURE__ */ new Map(), xa = [], wM = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
  " "
);
function dw(e, t) {
  switch (e) {
    case "focusin":
    case "focusout":
      Qa = null;
      break;
    case "dragenter":
    case "dragleave":
      Ha = null;
      break;
    case "mouseover":
    case "mouseout":
      $a = null;
      break;
    case "pointerover":
    case "pointerout":
      Sc.delete(t.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Tc.delete(t.pointerId);
  }
}
function vl(e, t, n, r, a, i) {
  return e === null || e.nativeEvent !== i ? (e = {
    blockedOn: t,
    domEventName: n,
    eventSystemFlags: r,
    nativeEvent: i,
    targetContainers: [a]
  }, t !== null && (t = Hs(t), t !== null && yO(t)), e) : (e.eventSystemFlags |= r, t = e.targetContainers, a !== null && t.indexOf(a) === -1 && t.push(a), e);
}
function xM(e, t, n, r, a) {
  switch (t) {
    case "focusin":
      return Qa = vl(
        Qa,
        e,
        t,
        n,
        r,
        a
      ), !0;
    case "dragenter":
      return Ha = vl(
        Ha,
        e,
        t,
        n,
        r,
        a
      ), !0;
    case "mouseover":
      return $a = vl(
        $a,
        e,
        t,
        n,
        r,
        a
      ), !0;
    case "pointerover":
      var i = a.pointerId;
      return Sc.set(
        i,
        vl(
          Sc.get(i) || null,
          e,
          t,
          n,
          r,
          a
        )
      ), !0;
    case "gotpointercapture":
      return i = a.pointerId, Tc.set(
        i,
        vl(
          Tc.get(i) || null,
          e,
          t,
          n,
          r,
          a
        )
      ), !0;
  }
  return !1;
}
function wO(e) {
  var t = Lo(e.target);
  if (t !== null) {
    var n = Yc(t);
    if (n !== null) {
      if (t = n.tag, t === 13) {
        if (t = IS(n), t !== null) {
          e.blockedOn = t, Xb(e.priority, function() {
            fw(n);
          });
          return;
        }
      } else if (t === 31) {
        if (t = FS(n), t !== null) {
          e.blockedOn = t, Xb(e.priority, function() {
            fw(n);
          });
          return;
        }
      } else if (t === 3 && n.stateNode.current.memoizedState.isDehydrated) {
        e.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null;
        return;
      }
    }
  }
  e.blockedOn = null;
}
function wf(e) {
  if (e.blockedOn !== null) return !1;
  for (var t = e.targetContainers; 0 < t.length; ) {
    var n = Km(e.nativeEvent);
    if (n === null) {
      n = e.nativeEvent;
      var r = new n.constructor(
        n.type,
        n
      );
      pm = r, n.target.dispatchEvent(r), pm = null;
    } else
      return t = Hs(n), t !== null && yO(t), e.blockedOn = n, !1;
    t.shift();
  }
  return !0;
}
function hw(e, t, n) {
  wf(e) && n.delete(t);
}
function EM() {
  Xm = !1, Qa !== null && wf(Qa) && (Qa = null), Ha !== null && wf(Ha) && (Ha = null), $a !== null && wf($a) && ($a = null), Sc.forEach(hw), Tc.forEach(hw);
}
function Uu(e, t) {
  e.blockedOn === t && (e.blockedOn = null, Xm || (Xm = !0, St.unstable_scheduleCallback(
    St.unstable_NormalPriority,
    EM
  )));
}
var qu = null;
function pw(e) {
  qu !== e && (qu = e, St.unstable_scheduleCallback(
    St.unstable_NormalPriority,
    function() {
      qu === e && (qu = null);
      for (var t = 0; t < e.length; t += 3) {
        var n = e[t], r = e[t + 1], a = e[t + 2];
        if (typeof r != "function") {
          if (my(r || n) === null)
            continue;
          break;
        }
        var i = Hs(n);
        i !== null && (e.splice(t, 3), t -= 3, Dm(
          i,
          {
            pending: !0,
            data: a,
            method: n.method,
            action: r
          },
          r,
          a
        ));
      }
    }
  ));
}
function Ls(e) {
  function t(l) {
    return Uu(l, e);
  }
  Qa !== null && Uu(Qa, e), Ha !== null && Uu(Ha, e), $a !== null && Uu($a, e), Sc.forEach(t), Tc.forEach(t);
  for (var n = 0; n < xa.length; n++) {
    var r = xa[n];
    r.blockedOn === e && (r.blockedOn = null);
  }
  for (; 0 < xa.length && (n = xa[0], n.blockedOn === null); )
    wO(n), n.blockedOn === null && xa.shift();
  if (n = (e.ownerDocument || e).$$reactFormReplay, n != null)
    for (r = 0; r < n.length; r += 3) {
      var a = n[r], i = n[r + 1], o = a[on] || null;
      if (typeof i == "function")
        o || pw(n);
      else if (o) {
        var s = null;
        if (i && i.hasAttribute("formAction")) {
          if (a = i, o = i[on] || null)
            s = o.formAction;
          else if (my(a) !== null) continue;
        } else s = o.action;
        typeof s == "function" ? n[r + 1] = s : (n.splice(r, 3), r -= 3), pw(n);
      }
    }
}
function xO() {
  function e(i) {
    i.canIntercept && i.info === "react-transition" && i.intercept({
      handler: function() {
        return new Promise(function(o) {
          return a = o;
        });
      },
      focusReset: "manual",
      scroll: "manual"
    });
  }
  function t() {
    a !== null && (a(), a = null), r || setTimeout(n, 20);
  }
  function n() {
    if (!r && !navigation.transition) {
      var i = navigation.currentEntry;
      i && i.url != null && navigation.navigate(i.url, {
        state: i.getState(),
        info: "react-transition",
        history: "replace"
      });
    }
  }
  if (typeof navigation == "object") {
    var r = !1, a = null;
    return navigation.addEventListener("navigate", e), navigation.addEventListener("navigatesuccess", t), navigation.addEventListener("navigateerror", t), setTimeout(n, 100), function() {
      r = !0, navigation.removeEventListener("navigate", e), navigation.removeEventListener("navigatesuccess", t), navigation.removeEventListener("navigateerror", t), a !== null && (a(), a = null);
    };
  }
}
function gy(e) {
  this._internalRoot = e;
}
Yd.prototype.render = gy.prototype.render = function(e) {
  var t = this._internalRoot;
  if (t === null) throw Error(V(409));
  var n = t.current, r = yn();
  vO(n, r, e, t, null, null);
};
Yd.prototype.unmount = gy.prototype.unmount = function() {
  var e = this._internalRoot;
  if (e !== null) {
    this._internalRoot = null;
    var t = e.containerInfo;
    vO(e.current, 2, null, e, null, null), Hd(), t[Qs] = null;
  }
};
function Yd(e) {
  this._internalRoot = e;
}
Yd.prototype.unstable_scheduleHydration = function(e) {
  if (e) {
    var t = XS();
    e = { blockedOn: null, target: e, priority: t };
    for (var n = 0; n < xa.length && t !== 0 && t < xa[n].priority; n++) ;
    xa.splice(n, 0, e), n === 0 && wO(e);
  }
};
var mw = jS.version;
if (mw !== "19.2.0")
  throw Error(
    V(
      527,
      mw,
      "19.2.0"
    )
  );
De.findDOMNode = function(e) {
  var t = e._reactInternals;
  if (t === void 0)
    throw typeof e.render == "function" ? Error(V(188)) : (e = Object.keys(e).join(","), Error(V(268, e)));
  return e = ZD(t), e = e !== null ? US(e) : null, e = e === null ? null : e.stateNode, e;
};
var SM = {
  bundleType: 0,
  version: "19.2.0",
  rendererPackageName: "react-dom",
  currentDispatcherRef: fe,
  reconcilerVersion: "19.2.0"
};
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
  var Bu = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!Bu.isDisabled && Bu.supportsFiber)
    try {
      Kc = Bu.inject(
        SM
      ), gn = Bu;
    } catch {
    }
}
Nd.createRoot = function(e, t) {
  if (!PS(e)) throw Error(V(299));
  var n = !1, r = "", a = dC, i = hC, o = pC;
  return t != null && (t.unstable_strictMode === !0 && (n = !0), t.identifierPrefix !== void 0 && (r = t.identifierPrefix), t.onUncaughtError !== void 0 && (a = t.onUncaughtError), t.onCaughtError !== void 0 && (i = t.onCaughtError), t.onRecoverableError !== void 0 && (o = t.onRecoverableError)), t = mO(
    e,
    1,
    !1,
    null,
    null,
    n,
    r,
    null,
    a,
    i,
    o,
    xO
  ), e[Qs] = t.current, uy(e), new gy(t);
};
Nd.hydrateRoot = function(e, t, n) {
  if (!PS(e)) throw Error(V(299));
  var r = !1, a = "", i = dC, o = hC, s = pC, l = null;
  return n != null && (n.unstable_strictMode === !0 && (r = !0), n.identifierPrefix !== void 0 && (a = n.identifierPrefix), n.onUncaughtError !== void 0 && (i = n.onUncaughtError), n.onCaughtError !== void 0 && (o = n.onCaughtError), n.onRecoverableError !== void 0 && (s = n.onRecoverableError), n.formState !== void 0 && (l = n.formState)), t = mO(
    e,
    1,
    !0,
    t,
    n ?? null,
    r,
    a,
    l,
    i,
    o,
    s,
    xO
  ), t.context = gO(null), n = t.current, r = yn(), r = Tv(r), a = Ua(r), a.callback = null, qa(n, a, r), n = r, t.current.lanes = n, Wc(t, n), pr(t), e[Qs] = t.current, uy(e), new Yd(t);
};
Nd.version = "19.2.0";
function EO() {
  if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(EO);
    } catch (e) {
      console.error(e);
    }
}
EO(), SS.exports = Nd;
var TM = SS.exports;
const CM = /* @__PURE__ */ _d(TM);
var ou = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set(), this.subscribe = this.subscribe.bind(this);
  }
  subscribe(e) {
    return this.listeners.add(e), this.onSubscribe(), () => {
      this.listeners.delete(e), this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
}, OM = {
  // We need the wrapper function syntax below instead of direct references to
  // global setTimeout etc.
  //
  // BAD: `setTimeout: setTimeout`
  // GOOD: `setTimeout: (cb, delay) => setTimeout(cb, delay)`
  //
  // If we use direct references here, then anything that wants to spy on or
  // replace the global setTimeout (like tests) won't work since we'll already
  // have a hard reference to the original implementation at the time when this
  // file was imported.
  setTimeout: (e, t) => setTimeout(e, t),
  clearTimeout: (e) => clearTimeout(e),
  setInterval: (e, t) => setInterval(e, t),
  clearInterval: (e) => clearInterval(e)
}, Ta, pv, uS, AM = (uS = class {
  constructor() {
    // We cannot have TimeoutManager<T> as we must instantiate it with a concrete
    // type at app boot; and if we leave that type, then any new timer provider
    // would need to support ReturnType<typeof setTimeout>, which is infeasible.
    //
    // We settle for type safety for the TimeoutProvider type, and accept that
    // this class is unsafe internally to allow for extension.
    ce(this, Ta, OM);
    ce(this, pv, !1);
  }
  setTimeoutProvider(e) {
    te(this, Ta, e);
  }
  setTimeout(e, t) {
    return _(this, Ta).setTimeout(e, t);
  }
  clearTimeout(e) {
    _(this, Ta).clearTimeout(e);
  }
  setInterval(e, t) {
    return _(this, Ta).setInterval(e, t);
  }
  clearInterval(e) {
    _(this, Ta).clearInterval(e);
  }
}, Ta = new WeakMap(), pv = new WeakMap(), uS), Ai = new AM();
function RM(e) {
  setTimeout(e, 0);
}
var Wi = typeof window > "u" || "Deno" in globalThis;
function rn() {
}
function _M(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function Wm(e) {
  return typeof e == "number" && e >= 0 && e !== 1 / 0;
}
function SO(e, t) {
  return Math.max(e + (t || 0) - Date.now(), 0);
}
function Ga(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function Cn(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function gw(e, t) {
  const {
    type: n = "all",
    exact: r,
    fetchStatus: a,
    predicate: i,
    queryKey: o,
    stale: s
  } = e;
  if (o) {
    if (r) {
      if (t.queryHash !== vy(o, t.options))
        return !1;
    } else if (!Oc(t.queryKey, o))
      return !1;
  }
  if (n !== "all") {
    const l = t.isActive();
    if (n === "active" && !l || n === "inactive" && l)
      return !1;
  }
  return !(typeof s == "boolean" && t.isStale() !== s || a && a !== t.state.fetchStatus || i && !i(t));
}
function vw(e, t) {
  const { exact: n, status: r, predicate: a, mutationKey: i } = e;
  if (i) {
    if (!t.options.mutationKey)
      return !1;
    if (n) {
      if (Cc(t.options.mutationKey) !== Cc(i))
        return !1;
    } else if (!Oc(t.options.mutationKey, i))
      return !1;
  }
  return !(r && t.state.status !== r || a && !a(t));
}
function vy(e, t) {
  return ((t == null ? void 0 : t.queryKeyHashFn) || Cc)(e);
}
function Cc(e) {
  return JSON.stringify(
    e,
    (t, n) => Jm(n) ? Object.keys(n).sort().reduce((r, a) => (r[a] = n[a], r), {}) : n
  );
}
function Oc(e, t) {
  return e === t ? !0 : typeof e != typeof t ? !1 : e && t && typeof e == "object" && typeof t == "object" ? Object.keys(t).every((n) => Oc(e[n], t[n])) : !1;
}
var DM = Object.prototype.hasOwnProperty;
function TO(e, t) {
  if (e === t)
    return e;
  const n = yw(e) && yw(t);
  if (!n && !(Jm(e) && Jm(t))) return t;
  const a = (n ? e : Object.keys(e)).length, i = n ? t : Object.keys(t), o = i.length, s = n ? new Array(o) : {};
  let l = 0;
  for (let c = 0; c < o; c++) {
    const u = n ? c : i[c], f = e[u], d = t[u];
    if (f === d) {
      s[u] = f, (n ? c < a : DM.call(e, u)) && l++;
      continue;
    }
    if (f === null || d === null || typeof f != "object" || typeof d != "object") {
      s[u] = d;
      continue;
    }
    const h = TO(f, d);
    s[u] = h, h === f && l++;
  }
  return a === o && l === a ? e : s;
}
function Zm(e, t) {
  if (!t || Object.keys(e).length !== Object.keys(t).length)
    return !1;
  for (const n in e)
    if (e[n] !== t[n])
      return !1;
  return !0;
}
function yw(e) {
  return Array.isArray(e) && e.length === Object.keys(e).length;
}
function Jm(e) {
  if (!bw(e))
    return !1;
  const t = e.constructor;
  if (t === void 0)
    return !0;
  const n = t.prototype;
  return !(!bw(n) || !n.hasOwnProperty("isPrototypeOf") || Object.getPrototypeOf(e) !== Object.prototype);
}
function bw(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function NM(e) {
  return new Promise((t) => {
    Ai.setTimeout(t, e);
  });
}
function eg(e, t, n) {
  return typeof n.structuralSharing == "function" ? n.structuralSharing(e, t) : n.structuralSharing !== !1 ? TO(e, t) : t;
}
function kM(e, t, n = 0) {
  const r = [...e, t];
  return n && r.length > n ? r.slice(1) : r;
}
function MM(e, t, n = 0) {
  const r = [t, ...e];
  return n && r.length > n ? r.slice(0, -1) : r;
}
var yy = Symbol();
function CO(e, t) {
  return !e.queryFn && (t != null && t.initialPromise) ? () => t.initialPromise : !e.queryFn || e.queryFn === yy ? () => Promise.reject(new Error(`Missing queryFn: '${e.queryHash}'`)) : e.queryFn;
}
function LM(e, t) {
  return typeof e == "function" ? e(...t) : !!e;
}
var Ni, Ca, ds, fS, zM = (fS = class extends ou {
  constructor() {
    super();
    ce(this, Ni);
    ce(this, Ca);
    ce(this, ds);
    te(this, ds, (t) => {
      if (!Wi && window.addEventListener) {
        const n = () => t();
        return window.addEventListener("visibilitychange", n, !1), () => {
          window.removeEventListener("visibilitychange", n);
        };
      }
    });
  }
  onSubscribe() {
    _(this, Ca) || this.setEventListener(_(this, ds));
  }
  onUnsubscribe() {
    var t;
    this.hasListeners() || ((t = _(this, Ca)) == null || t.call(this), te(this, Ca, void 0));
  }
  setEventListener(t) {
    var n;
    te(this, ds, t), (n = _(this, Ca)) == null || n.call(this), te(this, Ca, t((r) => {
      typeof r == "boolean" ? this.setFocused(r) : this.onFocus();
    }));
  }
  setFocused(t) {
    _(this, Ni) !== t && (te(this, Ni, t), this.onFocus());
  }
  onFocus() {
    const t = this.isFocused();
    this.listeners.forEach((n) => {
      n(t);
    });
  }
  isFocused() {
    var t;
    return typeof _(this, Ni) == "boolean" ? _(this, Ni) : ((t = globalThis.document) == null ? void 0 : t.visibilityState) !== "hidden";
  }
}, Ni = new WeakMap(), Ca = new WeakMap(), ds = new WeakMap(), fS), by = new zM();
function tg() {
  let e, t;
  const n = new Promise((a, i) => {
    e = a, t = i;
  });
  n.status = "pending", n.catch(() => {
  });
  function r(a) {
    Object.assign(n, a), delete n.resolve, delete n.reject;
  }
  return n.resolve = (a) => {
    r({
      status: "fulfilled",
      value: a
    }), e(a);
  }, n.reject = (a) => {
    r({
      status: "rejected",
      reason: a
    }), t(a);
  }, n;
}
var jM = RM;
function PM() {
  let e = [], t = 0, n = (s) => {
    s();
  }, r = (s) => {
    s();
  }, a = jM;
  const i = (s) => {
    t ? e.push(s) : a(() => {
      n(s);
    });
  }, o = () => {
    const s = e;
    e = [], s.length && a(() => {
      r(() => {
        s.forEach((l) => {
          n(l);
        });
      });
    });
  };
  return {
    batch: (s) => {
      let l;
      t++;
      try {
        l = s();
      } finally {
        t--, t || o();
      }
      return l;
    },
    /**
     * All calls to the wrapped function will be batched.
     */
    batchCalls: (s) => (...l) => {
      i(() => {
        s(...l);
      });
    },
    schedule: i,
    /**
     * Use this method to set a custom notify function.
     * This can be used to for example wrap notifications with `React.act` while running tests.
     */
    setNotifyFunction: (s) => {
      n = s;
    },
    /**
     * Use this method to set a custom function to batch notifications together into a single tick.
     * By default React Query will use the batch function provided by ReactDOM or React Native.
     */
    setBatchNotifyFunction: (s) => {
      r = s;
    },
    setScheduler: (s) => {
      a = s;
    }
  };
}
var Lt = PM(), hs, Oa, ps, dS, IM = (dS = class extends ou {
  constructor() {
    super();
    ce(this, hs, !0);
    ce(this, Oa);
    ce(this, ps);
    te(this, ps, (t) => {
      if (!Wi && window.addEventListener) {
        const n = () => t(!0), r = () => t(!1);
        return window.addEventListener("online", n, !1), window.addEventListener("offline", r, !1), () => {
          window.removeEventListener("online", n), window.removeEventListener("offline", r);
        };
      }
    });
  }
  onSubscribe() {
    _(this, Oa) || this.setEventListener(_(this, ps));
  }
  onUnsubscribe() {
    var t;
    this.hasListeners() || ((t = _(this, Oa)) == null || t.call(this), te(this, Oa, void 0));
  }
  setEventListener(t) {
    var n;
    te(this, ps, t), (n = _(this, Oa)) == null || n.call(this), te(this, Oa, t(this.setOnline.bind(this)));
  }
  setOnline(t) {
    _(this, hs) !== t && (te(this, hs, t), this.listeners.forEach((r) => {
      r(t);
    }));
  }
  isOnline() {
    return _(this, hs);
  }
}, hs = new WeakMap(), Oa = new WeakMap(), ps = new WeakMap(), dS), ud = new IM();
function FM(e) {
  return Math.min(1e3 * 2 ** e, 3e4);
}
function OO(e) {
  return (e ?? "online") === "online" ? ud.isOnline() : !0;
}
var ng = class extends Error {
  constructor(e) {
    super("CancelledError"), this.revert = e == null ? void 0 : e.revert, this.silent = e == null ? void 0 : e.silent;
  }
};
function AO(e) {
  let t = !1, n = 0, r;
  const a = tg(), i = () => a.status !== "pending", o = (v) => {
    var b;
    if (!i()) {
      const p = new ng(v);
      d(p), (b = e.onCancel) == null || b.call(e, p);
    }
  }, s = () => {
    t = !0;
  }, l = () => {
    t = !1;
  }, c = () => by.isFocused() && (e.networkMode === "always" || ud.isOnline()) && e.canRun(), u = () => OO(e.networkMode) && e.canRun(), f = (v) => {
    i() || (r == null || r(), a.resolve(v));
  }, d = (v) => {
    i() || (r == null || r(), a.reject(v));
  }, h = () => new Promise((v) => {
    var b;
    r = (p) => {
      (i() || c()) && v(p);
    }, (b = e.onPause) == null || b.call(e);
  }).then(() => {
    var v;
    r = void 0, i() || (v = e.onContinue) == null || v.call(e);
  }), g = () => {
    if (i())
      return;
    let v;
    const b = n === 0 ? e.initialPromise : void 0;
    try {
      v = b ?? e.fn();
    } catch (p) {
      v = Promise.reject(p);
    }
    Promise.resolve(v).then(f).catch((p) => {
      var T;
      if (i())
        return;
      const m = e.retry ?? (Wi ? 0 : 3), w = e.retryDelay ?? FM, x = typeof w == "function" ? w(n, p) : w, S = m === !0 || typeof m == "number" && n < m || typeof m == "function" && m(n, p);
      if (t || !S) {
        d(p);
        return;
      }
      n++, (T = e.onFail) == null || T.call(e, n, p), NM(x).then(() => c() ? void 0 : h()).then(() => {
        t ? d(p) : g();
      });
    });
  };
  return {
    promise: a,
    status: () => a.status,
    cancel: o,
    continue: () => (r == null || r(), a),
    cancelRetry: s,
    continueRetry: l,
    canStart: u,
    start: () => (u() ? g() : h().then(g), a)
  };
}
var ki, hS, RO = (hS = class {
  constructor() {
    ce(this, ki);
  }
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout(), Wm(this.gcTime) && te(this, ki, Ai.setTimeout(() => {
      this.optionalRemove();
    }, this.gcTime));
  }
  updateGcTime(e) {
    this.gcTime = Math.max(
      this.gcTime || 0,
      e ?? (Wi ? 1 / 0 : 5 * 60 * 1e3)
    );
  }
  clearGcTimeout() {
    _(this, ki) && (Ai.clearTimeout(_(this, ki)), te(this, ki, void 0));
  }
}, ki = new WeakMap(), hS), Mi, ms, En, Li, Ot, Bc, zi, Fn, Nr, pS, UM = (pS = class extends RO {
  constructor(t) {
    super();
    ce(this, Fn);
    ce(this, Mi);
    ce(this, ms);
    ce(this, En);
    ce(this, Li);
    ce(this, Ot);
    ce(this, Bc);
    ce(this, zi);
    te(this, zi, !1), te(this, Bc, t.defaultOptions), this.setOptions(t.options), this.observers = [], te(this, Li, t.client), te(this, En, _(this, Li).getQueryCache()), this.queryKey = t.queryKey, this.queryHash = t.queryHash, te(this, Mi, xw(this.options)), this.state = t.state ?? _(this, Mi), this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  get promise() {
    var t;
    return (t = _(this, Ot)) == null ? void 0 : t.promise;
  }
  setOptions(t) {
    if (this.options = { ..._(this, Bc), ...t }, this.updateGcTime(this.options.gcTime), this.state && this.state.data === void 0) {
      const n = xw(this.options);
      n.data !== void 0 && (this.setState(
        ww(n.data, n.dataUpdatedAt)
      ), te(this, Mi, n));
    }
  }
  optionalRemove() {
    !this.observers.length && this.state.fetchStatus === "idle" && _(this, En).remove(this);
  }
  setData(t, n) {
    const r = eg(this.state.data, t, this.options);
    return Ce(this, Fn, Nr).call(this, {
      data: r,
      type: "success",
      dataUpdatedAt: n == null ? void 0 : n.updatedAt,
      manual: n == null ? void 0 : n.manual
    }), r;
  }
  setState(t, n) {
    Ce(this, Fn, Nr).call(this, { type: "setState", state: t, setStateOptions: n });
  }
  cancel(t) {
    var r, a;
    const n = (r = _(this, Ot)) == null ? void 0 : r.promise;
    return (a = _(this, Ot)) == null || a.cancel(t), n ? n.then(rn).catch(rn) : Promise.resolve();
  }
  destroy() {
    super.destroy(), this.cancel({ silent: !0 });
  }
  reset() {
    this.destroy(), this.setState(_(this, Mi));
  }
  isActive() {
    return this.observers.some(
      (t) => Cn(t.options.enabled, this) !== !1
    );
  }
  isDisabled() {
    return this.getObserversCount() > 0 ? !this.isActive() : this.options.queryFn === yy || this.state.dataUpdateCount + this.state.errorUpdateCount === 0;
  }
  isStatic() {
    return this.getObserversCount() > 0 ? this.observers.some(
      (t) => Ga(t.options.staleTime, this) === "static"
    ) : !1;
  }
  isStale() {
    return this.getObserversCount() > 0 ? this.observers.some(
      (t) => t.getCurrentResult().isStale
    ) : this.state.data === void 0 || this.state.isInvalidated;
  }
  isStaleByTime(t = 0) {
    return this.state.data === void 0 ? !0 : t === "static" ? !1 : this.state.isInvalidated ? !0 : !SO(this.state.dataUpdatedAt, t);
  }
  onFocus() {
    var n;
    const t = this.observers.find((r) => r.shouldFetchOnWindowFocus());
    t == null || t.refetch({ cancelRefetch: !1 }), (n = _(this, Ot)) == null || n.continue();
  }
  onOnline() {
    var n;
    const t = this.observers.find((r) => r.shouldFetchOnReconnect());
    t == null || t.refetch({ cancelRefetch: !1 }), (n = _(this, Ot)) == null || n.continue();
  }
  addObserver(t) {
    this.observers.includes(t) || (this.observers.push(t), this.clearGcTimeout(), _(this, En).notify({ type: "observerAdded", query: this, observer: t }));
  }
  removeObserver(t) {
    this.observers.includes(t) && (this.observers = this.observers.filter((n) => n !== t), this.observers.length || (_(this, Ot) && (_(this, zi) ? _(this, Ot).cancel({ revert: !0 }) : _(this, Ot).cancelRetry()), this.scheduleGc()), _(this, En).notify({ type: "observerRemoved", query: this, observer: t }));
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    this.state.isInvalidated || Ce(this, Fn, Nr).call(this, { type: "invalidate" });
  }
  async fetch(t, n) {
    var l, c, u, f, d, h, g, v, b, p, m, w;
    if (this.state.fetchStatus !== "idle" && // If the promise in the retyer is already rejected, we have to definitely
    // re-start the fetch; there is a chance that the query is still in a
    // pending state when that happens
    ((l = _(this, Ot)) == null ? void 0 : l.status()) !== "rejected") {
      if (this.state.data !== void 0 && (n != null && n.cancelRefetch))
        this.cancel({ silent: !0 });
      else if (_(this, Ot))
        return _(this, Ot).continueRetry(), _(this, Ot).promise;
    }
    if (t && this.setOptions(t), !this.options.queryFn) {
      const x = this.observers.find((S) => S.options.queryFn);
      x && this.setOptions(x.options);
    }
    const r = new AbortController(), a = (x) => {
      Object.defineProperty(x, "signal", {
        enumerable: !0,
        get: () => (te(this, zi, !0), r.signal)
      });
    }, i = () => {
      const x = CO(this.options, n), T = (() => {
        const E = {
          client: _(this, Li),
          queryKey: this.queryKey,
          meta: this.meta
        };
        return a(E), E;
      })();
      return te(this, zi, !1), this.options.persister ? this.options.persister(
        x,
        T,
        this
      ) : x(T);
    }, s = (() => {
      const x = {
        fetchOptions: n,
        options: this.options,
        queryKey: this.queryKey,
        client: _(this, Li),
        state: this.state,
        fetchFn: i
      };
      return a(x), x;
    })();
    (c = this.options.behavior) == null || c.onFetch(s, this), te(this, ms, this.state), (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((u = s.fetchOptions) == null ? void 0 : u.meta)) && Ce(this, Fn, Nr).call(this, { type: "fetch", meta: (f = s.fetchOptions) == null ? void 0 : f.meta }), te(this, Ot, AO({
      initialPromise: n == null ? void 0 : n.initialPromise,
      fn: s.fetchFn,
      onCancel: (x) => {
        x instanceof ng && x.revert && this.setState({
          ..._(this, ms),
          fetchStatus: "idle"
        }), r.abort();
      },
      onFail: (x, S) => {
        Ce(this, Fn, Nr).call(this, { type: "failed", failureCount: x, error: S });
      },
      onPause: () => {
        Ce(this, Fn, Nr).call(this, { type: "pause" });
      },
      onContinue: () => {
        Ce(this, Fn, Nr).call(this, { type: "continue" });
      },
      retry: s.options.retry,
      retryDelay: s.options.retryDelay,
      networkMode: s.options.networkMode,
      canRun: () => !0
    }));
    try {
      const x = await _(this, Ot).start();
      if (x === void 0)
        throw new Error(`${this.queryHash} data is undefined`);
      return this.setData(x), (h = (d = _(this, En).config).onSuccess) == null || h.call(d, x, this), (v = (g = _(this, En).config).onSettled) == null || v.call(
        g,
        x,
        this.state.error,
        this
      ), x;
    } catch (x) {
      if (x instanceof ng) {
        if (x.silent)
          return _(this, Ot).promise;
        if (x.revert) {
          if (this.state.data === void 0)
            throw x;
          return this.state.data;
        }
      }
      throw Ce(this, Fn, Nr).call(this, {
        type: "error",
        error: x
      }), (p = (b = _(this, En).config).onError) == null || p.call(
        b,
        x,
        this
      ), (w = (m = _(this, En).config).onSettled) == null || w.call(
        m,
        this.state.data,
        x,
        this
      ), x;
    } finally {
      this.scheduleGc();
    }
  }
}, Mi = new WeakMap(), ms = new WeakMap(), En = new WeakMap(), Li = new WeakMap(), Ot = new WeakMap(), Bc = new WeakMap(), zi = new WeakMap(), Fn = new WeakSet(), Nr = function(t) {
  const n = (r) => {
    switch (t.type) {
      case "failed":
        return {
          ...r,
          fetchFailureCount: t.failureCount,
          fetchFailureReason: t.error
        };
      case "pause":
        return {
          ...r,
          fetchStatus: "paused"
        };
      case "continue":
        return {
          ...r,
          fetchStatus: "fetching"
        };
      case "fetch":
        return {
          ...r,
          ..._O(r.data, this.options),
          fetchMeta: t.meta ?? null
        };
      case "success":
        const a = {
          ...r,
          ...ww(t.data, t.dataUpdatedAt),
          dataUpdateCount: r.dataUpdateCount + 1,
          ...!t.manual && {
            fetchStatus: "idle",
            fetchFailureCount: 0,
            fetchFailureReason: null
          }
        };
        return te(this, ms, t.manual ? a : void 0), a;
      case "error":
        const i = t.error;
        return {
          ...r,
          error: i,
          errorUpdateCount: r.errorUpdateCount + 1,
          errorUpdatedAt: Date.now(),
          fetchFailureCount: r.fetchFailureCount + 1,
          fetchFailureReason: i,
          fetchStatus: "idle",
          status: "error"
        };
      case "invalidate":
        return {
          ...r,
          isInvalidated: !0
        };
      case "setState":
        return {
          ...r,
          ...t.state
        };
    }
  };
  this.state = n(this.state), Lt.batch(() => {
    this.observers.forEach((r) => {
      r.onQueryUpdate();
    }), _(this, En).notify({ query: this, type: "updated", action: t });
  });
}, pS);
function _O(e, t) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: OO(t.networkMode) ? "fetching" : "paused",
    ...e === void 0 && {
      error: null,
      status: "pending"
    }
  };
}
function ww(e, t) {
  return {
    data: e,
    dataUpdatedAt: t ?? Date.now(),
    error: null,
    isInvalidated: !1,
    status: "success"
  };
}
function xw(e) {
  const t = typeof e.initialData == "function" ? e.initialData() : e.initialData, n = t !== void 0, r = n ? typeof e.initialDataUpdatedAt == "function" ? e.initialDataUpdatedAt() : e.initialDataUpdatedAt : 0;
  return {
    data: t,
    dataUpdateCount: 0,
    dataUpdatedAt: n ? r ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: !1,
    status: n ? "success" : "pending",
    fetchStatus: "idle"
  };
}
var Jt, Oe, Vc, qt, ji, gs, zr, Aa, Qc, vs, ys, Pi, Ii, Ra, bs, Le, Pl, rg, ag, ig, og, sg, lg, cg, DO, mS, qM = (mS = class extends ou {
  constructor(t, n) {
    super();
    ce(this, Le);
    ce(this, Jt);
    ce(this, Oe);
    ce(this, Vc);
    ce(this, qt);
    ce(this, ji);
    ce(this, gs);
    ce(this, zr);
    ce(this, Aa);
    ce(this, Qc);
    ce(this, vs);
    // This property keeps track of the last query with defined data.
    // It will be used to pass the previous data and query to the placeholder function between renders.
    ce(this, ys);
    ce(this, Pi);
    ce(this, Ii);
    ce(this, Ra);
    ce(this, bs, /* @__PURE__ */ new Set());
    this.options = n, te(this, Jt, t), te(this, Aa, null), te(this, zr, tg()), this.bindMethods(), this.setOptions(n);
  }
  bindMethods() {
    this.refetch = this.refetch.bind(this);
  }
  onSubscribe() {
    this.listeners.size === 1 && (_(this, Oe).addObserver(this), Ew(_(this, Oe), this.options) ? Ce(this, Le, Pl).call(this) : this.updateResult(), Ce(this, Le, og).call(this));
  }
  onUnsubscribe() {
    this.hasListeners() || this.destroy();
  }
  shouldFetchOnReconnect() {
    return ug(
      _(this, Oe),
      this.options,
      this.options.refetchOnReconnect
    );
  }
  shouldFetchOnWindowFocus() {
    return ug(
      _(this, Oe),
      this.options,
      this.options.refetchOnWindowFocus
    );
  }
  destroy() {
    this.listeners = /* @__PURE__ */ new Set(), Ce(this, Le, sg).call(this), Ce(this, Le, lg).call(this), _(this, Oe).removeObserver(this);
  }
  setOptions(t) {
    const n = this.options, r = _(this, Oe);
    if (this.options = _(this, Jt).defaultQueryOptions(t), this.options.enabled !== void 0 && typeof this.options.enabled != "boolean" && typeof this.options.enabled != "function" && typeof Cn(this.options.enabled, _(this, Oe)) != "boolean")
      throw new Error(
        "Expected enabled to be a boolean or a callback that returns a boolean"
      );
    Ce(this, Le, cg).call(this), _(this, Oe).setOptions(this.options), n._defaulted && !Zm(this.options, n) && _(this, Jt).getQueryCache().notify({
      type: "observerOptionsUpdated",
      query: _(this, Oe),
      observer: this
    });
    const a = this.hasListeners();
    a && Sw(
      _(this, Oe),
      r,
      this.options,
      n
    ) && Ce(this, Le, Pl).call(this), this.updateResult(), a && (_(this, Oe) !== r || Cn(this.options.enabled, _(this, Oe)) !== Cn(n.enabled, _(this, Oe)) || Ga(this.options.staleTime, _(this, Oe)) !== Ga(n.staleTime, _(this, Oe))) && Ce(this, Le, rg).call(this);
    const i = Ce(this, Le, ag).call(this);
    a && (_(this, Oe) !== r || Cn(this.options.enabled, _(this, Oe)) !== Cn(n.enabled, _(this, Oe)) || i !== _(this, Ra)) && Ce(this, Le, ig).call(this, i);
  }
  getOptimisticResult(t) {
    const n = _(this, Jt).getQueryCache().build(_(this, Jt), t), r = this.createResult(n, t);
    return VM(this, r) && (te(this, qt, r), te(this, gs, this.options), te(this, ji, _(this, Oe).state)), r;
  }
  getCurrentResult() {
    return _(this, qt);
  }
  trackResult(t, n) {
    return new Proxy(t, {
      get: (r, a) => (this.trackProp(a), n == null || n(a), a === "promise" && (this.trackProp("data"), !this.options.experimental_prefetchInRender && _(this, zr).status === "pending" && _(this, zr).reject(
        new Error(
          "experimental_prefetchInRender feature flag is not enabled"
        )
      )), Reflect.get(r, a))
    });
  }
  trackProp(t) {
    _(this, bs).add(t);
  }
  getCurrentQuery() {
    return _(this, Oe);
  }
  refetch({ ...t } = {}) {
    return this.fetch({
      ...t
    });
  }
  fetchOptimistic(t) {
    const n = _(this, Jt).defaultQueryOptions(t), r = _(this, Jt).getQueryCache().build(_(this, Jt), n);
    return r.fetch().then(() => this.createResult(r, n));
  }
  fetch(t) {
    return Ce(this, Le, Pl).call(this, {
      ...t,
      cancelRefetch: t.cancelRefetch ?? !0
    }).then(() => (this.updateResult(), _(this, qt)));
  }
  createResult(t, n) {
    var D;
    const r = _(this, Oe), a = this.options, i = _(this, qt), o = _(this, ji), s = _(this, gs), c = t !== r ? t.state : _(this, Vc), { state: u } = t;
    let f = { ...u }, d = !1, h;
    if (n._optimisticResults) {
      const A = this.hasListeners(), U = !A && Ew(t, n), R = A && Sw(t, r, n, a);
      (U || R) && (f = {
        ...f,
        ..._O(u.data, t.options)
      }), n._optimisticResults === "isRestoring" && (f.fetchStatus = "idle");
    }
    let { error: g, errorUpdatedAt: v, status: b } = f;
    h = f.data;
    let p = !1;
    if (n.placeholderData !== void 0 && h === void 0 && b === "pending") {
      let A;
      i != null && i.isPlaceholderData && n.placeholderData === (s == null ? void 0 : s.placeholderData) ? (A = i.data, p = !0) : A = typeof n.placeholderData == "function" ? n.placeholderData(
        (D = _(this, ys)) == null ? void 0 : D.state.data,
        _(this, ys)
      ) : n.placeholderData, A !== void 0 && (b = "success", h = eg(
        i == null ? void 0 : i.data,
        A,
        n
      ), d = !0);
    }
    if (n.select && h !== void 0 && !p)
      if (i && h === (o == null ? void 0 : o.data) && n.select === _(this, Qc))
        h = _(this, vs);
      else
        try {
          te(this, Qc, n.select), h = n.select(h), h = eg(i == null ? void 0 : i.data, h, n), te(this, vs, h), te(this, Aa, null);
        } catch (A) {
          te(this, Aa, A);
        }
    _(this, Aa) && (g = _(this, Aa), h = _(this, vs), v = Date.now(), b = "error");
    const m = f.fetchStatus === "fetching", w = b === "pending", x = b === "error", S = w && m, T = h !== void 0, O = {
      status: b,
      fetchStatus: f.fetchStatus,
      isPending: w,
      isSuccess: b === "success",
      isError: x,
      isInitialLoading: S,
      isLoading: S,
      data: h,
      dataUpdatedAt: f.dataUpdatedAt,
      error: g,
      errorUpdatedAt: v,
      failureCount: f.fetchFailureCount,
      failureReason: f.fetchFailureReason,
      errorUpdateCount: f.errorUpdateCount,
      isFetched: f.dataUpdateCount > 0 || f.errorUpdateCount > 0,
      isFetchedAfterMount: f.dataUpdateCount > c.dataUpdateCount || f.errorUpdateCount > c.errorUpdateCount,
      isFetching: m,
      isRefetching: m && !w,
      isLoadingError: x && !T,
      isPaused: f.fetchStatus === "paused",
      isPlaceholderData: d,
      isRefetchError: x && T,
      isStale: wy(t, n),
      refetch: this.refetch,
      promise: _(this, zr),
      isEnabled: Cn(n.enabled, t) !== !1
    };
    if (this.options.experimental_prefetchInRender) {
      const A = (q) => {
        O.status === "error" ? q.reject(O.error) : O.data !== void 0 && q.resolve(O.data);
      }, U = () => {
        const q = te(this, zr, O.promise = tg());
        A(q);
      }, R = _(this, zr);
      switch (R.status) {
        case "pending":
          t.queryHash === r.queryHash && A(R);
          break;
        case "fulfilled":
          (O.status === "error" || O.data !== R.value) && U();
          break;
        case "rejected":
          (O.status !== "error" || O.error !== R.reason) && U();
          break;
      }
    }
    return O;
  }
  updateResult() {
    const t = _(this, qt), n = this.createResult(_(this, Oe), this.options);
    if (te(this, ji, _(this, Oe).state), te(this, gs, this.options), _(this, ji).data !== void 0 && te(this, ys, _(this, Oe)), Zm(n, t))
      return;
    te(this, qt, n);
    const r = () => {
      if (!t)
        return !0;
      const { notifyOnChangeProps: a } = this.options, i = typeof a == "function" ? a() : a;
      if (i === "all" || !i && !_(this, bs).size)
        return !0;
      const o = new Set(
        i ?? _(this, bs)
      );
      return this.options.throwOnError && o.add("error"), Object.keys(_(this, qt)).some((s) => {
        const l = s;
        return _(this, qt)[l] !== t[l] && o.has(l);
      });
    };
    Ce(this, Le, DO).call(this, { listeners: r() });
  }
  onQueryUpdate() {
    this.updateResult(), this.hasListeners() && Ce(this, Le, og).call(this);
  }
}, Jt = new WeakMap(), Oe = new WeakMap(), Vc = new WeakMap(), qt = new WeakMap(), ji = new WeakMap(), gs = new WeakMap(), zr = new WeakMap(), Aa = new WeakMap(), Qc = new WeakMap(), vs = new WeakMap(), ys = new WeakMap(), Pi = new WeakMap(), Ii = new WeakMap(), Ra = new WeakMap(), bs = new WeakMap(), Le = new WeakSet(), Pl = function(t) {
  Ce(this, Le, cg).call(this);
  let n = _(this, Oe).fetch(
    this.options,
    t
  );
  return t != null && t.throwOnError || (n = n.catch(rn)), n;
}, rg = function() {
  Ce(this, Le, sg).call(this);
  const t = Ga(
    this.options.staleTime,
    _(this, Oe)
  );
  if (Wi || _(this, qt).isStale || !Wm(t))
    return;
  const r = SO(_(this, qt).dataUpdatedAt, t) + 1;
  te(this, Pi, Ai.setTimeout(() => {
    _(this, qt).isStale || this.updateResult();
  }, r));
}, ag = function() {
  return (typeof this.options.refetchInterval == "function" ? this.options.refetchInterval(_(this, Oe)) : this.options.refetchInterval) ?? !1;
}, ig = function(t) {
  Ce(this, Le, lg).call(this), te(this, Ra, t), !(Wi || Cn(this.options.enabled, _(this, Oe)) === !1 || !Wm(_(this, Ra)) || _(this, Ra) === 0) && te(this, Ii, Ai.setInterval(() => {
    (this.options.refetchIntervalInBackground || by.isFocused()) && Ce(this, Le, Pl).call(this);
  }, _(this, Ra)));
}, og = function() {
  Ce(this, Le, rg).call(this), Ce(this, Le, ig).call(this, Ce(this, Le, ag).call(this));
}, sg = function() {
  _(this, Pi) && (Ai.clearTimeout(_(this, Pi)), te(this, Pi, void 0));
}, lg = function() {
  _(this, Ii) && (Ai.clearInterval(_(this, Ii)), te(this, Ii, void 0));
}, cg = function() {
  const t = _(this, Jt).getQueryCache().build(_(this, Jt), this.options);
  if (t === _(this, Oe))
    return;
  const n = _(this, Oe);
  te(this, Oe, t), te(this, Vc, t.state), this.hasListeners() && (n == null || n.removeObserver(this), t.addObserver(this));
}, DO = function(t) {
  Lt.batch(() => {
    t.listeners && this.listeners.forEach((n) => {
      n(_(this, qt));
    }), _(this, Jt).getQueryCache().notify({
      query: _(this, Oe),
      type: "observerResultsUpdated"
    });
  });
}, mS);
function BM(e, t) {
  return Cn(t.enabled, e) !== !1 && e.state.data === void 0 && !(e.state.status === "error" && t.retryOnMount === !1);
}
function Ew(e, t) {
  return BM(e, t) || e.state.data !== void 0 && ug(e, t, t.refetchOnMount);
}
function ug(e, t, n) {
  if (Cn(t.enabled, e) !== !1 && Ga(t.staleTime, e) !== "static") {
    const r = typeof n == "function" ? n(e) : n;
    return r === "always" || r !== !1 && wy(e, t);
  }
  return !1;
}
function Sw(e, t, n, r) {
  return (e !== t || Cn(r.enabled, e) === !1) && (!n.suspense || e.state.status !== "error") && wy(e, n);
}
function wy(e, t) {
  return Cn(t.enabled, e) !== !1 && e.isStaleByTime(Ga(t.staleTime, e));
}
function VM(e, t) {
  return !Zm(e.getCurrentResult(), t);
}
function Tw(e) {
  return {
    onFetch: (t, n) => {
      var u, f, d, h, g;
      const r = t.options, a = (d = (f = (u = t.fetchOptions) == null ? void 0 : u.meta) == null ? void 0 : f.fetchMore) == null ? void 0 : d.direction, i = ((h = t.state.data) == null ? void 0 : h.pages) || [], o = ((g = t.state.data) == null ? void 0 : g.pageParams) || [];
      let s = { pages: [], pageParams: [] }, l = 0;
      const c = async () => {
        let v = !1;
        const b = (w) => {
          Object.defineProperty(w, "signal", {
            enumerable: !0,
            get: () => (t.signal.aborted ? v = !0 : t.signal.addEventListener("abort", () => {
              v = !0;
            }), t.signal)
          });
        }, p = CO(t.options, t.fetchOptions), m = async (w, x, S) => {
          if (v)
            return Promise.reject();
          if (x == null && w.pages.length)
            return Promise.resolve(w);
          const E = (() => {
            const U = {
              client: t.client,
              queryKey: t.queryKey,
              pageParam: x,
              direction: S ? "backward" : "forward",
              meta: t.options.meta
            };
            return b(U), U;
          })(), O = await p(E), { maxPages: D } = t.options, A = S ? MM : kM;
          return {
            pages: A(w.pages, O, D),
            pageParams: A(w.pageParams, x, D)
          };
        };
        if (a && i.length) {
          const w = a === "backward", x = w ? NO : fg, S = {
            pages: i,
            pageParams: o
          }, T = x(r, S);
          s = await m(S, T, w);
        } else {
          const w = e ?? i.length;
          do {
            const x = l === 0 ? o[0] ?? r.initialPageParam : fg(r, s);
            if (l > 0 && x == null)
              break;
            s = await m(s, x), l++;
          } while (l < w);
        }
        return s;
      };
      t.options.persister ? t.fetchFn = () => {
        var v, b;
        return (b = (v = t.options).persister) == null ? void 0 : b.call(
          v,
          c,
          {
            client: t.client,
            queryKey: t.queryKey,
            meta: t.options.meta,
            signal: t.signal
          },
          n
        );
      } : t.fetchFn = c;
    }
  };
}
function fg(e, { pages: t, pageParams: n }) {
  const r = t.length - 1;
  return t.length > 0 ? e.getNextPageParam(
    t[r],
    t,
    n[r],
    n
  ) : void 0;
}
function NO(e, { pages: t, pageParams: n }) {
  var r;
  return t.length > 0 ? (r = e.getPreviousPageParam) == null ? void 0 : r.call(e, t[0], t, n[0], n) : void 0;
}
function A8(e, t) {
  return t ? fg(e, t) != null : !1;
}
function R8(e, t) {
  return !t || !e.getPreviousPageParam ? !1 : NO(e, t) != null;
}
var Hc, Wn, Bt, Fi, Zn, ua, gS, QM = (gS = class extends RO {
  constructor(t) {
    super();
    ce(this, Zn);
    ce(this, Hc);
    ce(this, Wn);
    ce(this, Bt);
    ce(this, Fi);
    te(this, Hc, t.client), this.mutationId = t.mutationId, te(this, Bt, t.mutationCache), te(this, Wn, []), this.state = t.state || HM(), this.setOptions(t.options), this.scheduleGc();
  }
  setOptions(t) {
    this.options = t, this.updateGcTime(this.options.gcTime);
  }
  get meta() {
    return this.options.meta;
  }
  addObserver(t) {
    _(this, Wn).includes(t) || (_(this, Wn).push(t), this.clearGcTimeout(), _(this, Bt).notify({
      type: "observerAdded",
      mutation: this,
      observer: t
    }));
  }
  removeObserver(t) {
    te(this, Wn, _(this, Wn).filter((n) => n !== t)), this.scheduleGc(), _(this, Bt).notify({
      type: "observerRemoved",
      mutation: this,
      observer: t
    });
  }
  optionalRemove() {
    _(this, Wn).length || (this.state.status === "pending" ? this.scheduleGc() : _(this, Bt).remove(this));
  }
  continue() {
    var t;
    return ((t = _(this, Fi)) == null ? void 0 : t.continue()) ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before
    this.execute(this.state.variables);
  }
  async execute(t) {
    var o, s, l, c, u, f, d, h, g, v, b, p, m, w, x, S, T, E, O, D;
    const n = () => {
      Ce(this, Zn, ua).call(this, { type: "continue" });
    }, r = {
      client: _(this, Hc),
      meta: this.options.meta,
      mutationKey: this.options.mutationKey
    };
    te(this, Fi, AO({
      fn: () => this.options.mutationFn ? this.options.mutationFn(t, r) : Promise.reject(new Error("No mutationFn found")),
      onFail: (A, U) => {
        Ce(this, Zn, ua).call(this, { type: "failed", failureCount: A, error: U });
      },
      onPause: () => {
        Ce(this, Zn, ua).call(this, { type: "pause" });
      },
      onContinue: n,
      retry: this.options.retry ?? 0,
      retryDelay: this.options.retryDelay,
      networkMode: this.options.networkMode,
      canRun: () => _(this, Bt).canRun(this)
    }));
    const a = this.state.status === "pending", i = !_(this, Fi).canStart();
    try {
      if (a)
        n();
      else {
        Ce(this, Zn, ua).call(this, { type: "pending", variables: t, isPaused: i }), await ((s = (o = _(this, Bt).config).onMutate) == null ? void 0 : s.call(
          o,
          t,
          this,
          r
        ));
        const U = await ((c = (l = this.options).onMutate) == null ? void 0 : c.call(
          l,
          t,
          r
        ));
        U !== this.state.context && Ce(this, Zn, ua).call(this, {
          type: "pending",
          context: U,
          variables: t,
          isPaused: i
        });
      }
      const A = await _(this, Fi).start();
      return await ((f = (u = _(this, Bt).config).onSuccess) == null ? void 0 : f.call(
        u,
        A,
        t,
        this.state.context,
        this,
        r
      )), await ((h = (d = this.options).onSuccess) == null ? void 0 : h.call(
        d,
        A,
        t,
        this.state.context,
        r
      )), await ((v = (g = _(this, Bt).config).onSettled) == null ? void 0 : v.call(
        g,
        A,
        null,
        this.state.variables,
        this.state.context,
        this,
        r
      )), await ((p = (b = this.options).onSettled) == null ? void 0 : p.call(
        b,
        A,
        null,
        t,
        this.state.context,
        r
      )), Ce(this, Zn, ua).call(this, { type: "success", data: A }), A;
    } catch (A) {
      try {
        throw await ((w = (m = _(this, Bt).config).onError) == null ? void 0 : w.call(
          m,
          A,
          t,
          this.state.context,
          this,
          r
        )), await ((S = (x = this.options).onError) == null ? void 0 : S.call(
          x,
          A,
          t,
          this.state.context,
          r
        )), await ((E = (T = _(this, Bt).config).onSettled) == null ? void 0 : E.call(
          T,
          void 0,
          A,
          this.state.variables,
          this.state.context,
          this,
          r
        )), await ((D = (O = this.options).onSettled) == null ? void 0 : D.call(
          O,
          void 0,
          A,
          t,
          this.state.context,
          r
        )), A;
      } finally {
        Ce(this, Zn, ua).call(this, { type: "error", error: A });
      }
    } finally {
      _(this, Bt).runNext(this);
    }
  }
}, Hc = new WeakMap(), Wn = new WeakMap(), Bt = new WeakMap(), Fi = new WeakMap(), Zn = new WeakSet(), ua = function(t) {
  const n = (r) => {
    switch (t.type) {
      case "failed":
        return {
          ...r,
          failureCount: t.failureCount,
          failureReason: t.error
        };
      case "pause":
        return {
          ...r,
          isPaused: !0
        };
      case "continue":
        return {
          ...r,
          isPaused: !1
        };
      case "pending":
        return {
          ...r,
          context: t.context,
          data: void 0,
          failureCount: 0,
          failureReason: null,
          error: null,
          isPaused: t.isPaused,
          status: "pending",
          variables: t.variables,
          submittedAt: Date.now()
        };
      case "success":
        return {
          ...r,
          data: t.data,
          failureCount: 0,
          failureReason: null,
          error: null,
          status: "success",
          isPaused: !1
        };
      case "error":
        return {
          ...r,
          data: void 0,
          error: t.error,
          failureCount: r.failureCount + 1,
          failureReason: t.error,
          isPaused: !1,
          status: "error"
        };
    }
  };
  this.state = n(this.state), Lt.batch(() => {
    _(this, Wn).forEach((r) => {
      r.onMutationUpdate(t);
    }), _(this, Bt).notify({
      mutation: this,
      type: "updated",
      action: t
    });
  });
}, gS);
function HM() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: !1,
    status: "idle",
    variables: void 0,
    submittedAt: 0
  };
}
var jr, Un, $c, vS, $M = (vS = class extends ou {
  constructor(t = {}) {
    super();
    ce(this, jr);
    ce(this, Un);
    ce(this, $c);
    this.config = t, te(this, jr, /* @__PURE__ */ new Set()), te(this, Un, /* @__PURE__ */ new Map()), te(this, $c, 0);
  }
  build(t, n, r) {
    const a = new QM({
      client: t,
      mutationCache: this,
      mutationId: ++Ou(this, $c)._,
      options: t.defaultMutationOptions(n),
      state: r
    });
    return this.add(a), a;
  }
  add(t) {
    _(this, jr).add(t);
    const n = Vu(t);
    if (typeof n == "string") {
      const r = _(this, Un).get(n);
      r ? r.push(t) : _(this, Un).set(n, [t]);
    }
    this.notify({ type: "added", mutation: t });
  }
  remove(t) {
    if (_(this, jr).delete(t)) {
      const n = Vu(t);
      if (typeof n == "string") {
        const r = _(this, Un).get(n);
        if (r)
          if (r.length > 1) {
            const a = r.indexOf(t);
            a !== -1 && r.splice(a, 1);
          } else r[0] === t && _(this, Un).delete(n);
      }
    }
    this.notify({ type: "removed", mutation: t });
  }
  canRun(t) {
    const n = Vu(t);
    if (typeof n == "string") {
      const r = _(this, Un).get(n), a = r == null ? void 0 : r.find(
        (i) => i.state.status === "pending"
      );
      return !a || a === t;
    } else
      return !0;
  }
  runNext(t) {
    var r;
    const n = Vu(t);
    if (typeof n == "string") {
      const a = (r = _(this, Un).get(n)) == null ? void 0 : r.find((i) => i !== t && i.state.isPaused);
      return (a == null ? void 0 : a.continue()) ?? Promise.resolve();
    } else
      return Promise.resolve();
  }
  clear() {
    Lt.batch(() => {
      _(this, jr).forEach((t) => {
        this.notify({ type: "removed", mutation: t });
      }), _(this, jr).clear(), _(this, Un).clear();
    });
  }
  getAll() {
    return Array.from(_(this, jr));
  }
  find(t) {
    const n = { exact: !0, ...t };
    return this.getAll().find(
      (r) => vw(n, r)
    );
  }
  findAll(t = {}) {
    return this.getAll().filter((n) => vw(t, n));
  }
  notify(t) {
    Lt.batch(() => {
      this.listeners.forEach((n) => {
        n(t);
      });
    });
  }
  resumePausedMutations() {
    const t = this.getAll().filter((n) => n.state.isPaused);
    return Lt.batch(
      () => Promise.all(
        t.map((n) => n.continue().catch(rn))
      )
    );
  }
}, jr = new WeakMap(), Un = new WeakMap(), $c = new WeakMap(), vS);
function Vu(e) {
  var t;
  return (t = e.options.scope) == null ? void 0 : t.id;
}
var Jn, yS, GM = (yS = class extends ou {
  constructor(t = {}) {
    super();
    ce(this, Jn);
    this.config = t, te(this, Jn, /* @__PURE__ */ new Map());
  }
  build(t, n, r) {
    const a = n.queryKey, i = n.queryHash ?? vy(a, n);
    let o = this.get(i);
    return o || (o = new UM({
      client: t,
      queryKey: a,
      queryHash: i,
      options: t.defaultQueryOptions(n),
      state: r,
      defaultOptions: t.getQueryDefaults(a)
    }), this.add(o)), o;
  }
  add(t) {
    _(this, Jn).has(t.queryHash) || (_(this, Jn).set(t.queryHash, t), this.notify({
      type: "added",
      query: t
    }));
  }
  remove(t) {
    const n = _(this, Jn).get(t.queryHash);
    n && (t.destroy(), n === t && _(this, Jn).delete(t.queryHash), this.notify({ type: "removed", query: t }));
  }
  clear() {
    Lt.batch(() => {
      this.getAll().forEach((t) => {
        this.remove(t);
      });
    });
  }
  get(t) {
    return _(this, Jn).get(t);
  }
  getAll() {
    return [..._(this, Jn).values()];
  }
  find(t) {
    const n = { exact: !0, ...t };
    return this.getAll().find(
      (r) => gw(n, r)
    );
  }
  findAll(t = {}) {
    const n = this.getAll();
    return Object.keys(t).length > 0 ? n.filter((r) => gw(t, r)) : n;
  }
  notify(t) {
    Lt.batch(() => {
      this.listeners.forEach((n) => {
        n(t);
      });
    });
  }
  onFocus() {
    Lt.batch(() => {
      this.getAll().forEach((t) => {
        t.onFocus();
      });
    });
  }
  onOnline() {
    Lt.batch(() => {
      this.getAll().forEach((t) => {
        t.onOnline();
      });
    });
  }
}, Jn = new WeakMap(), yS), nt, _a, Da, ws, xs, Na, Es, Ss, bS, kO = (bS = class {
  constructor(e = {}) {
    ce(this, nt);
    ce(this, _a);
    ce(this, Da);
    ce(this, ws);
    ce(this, xs);
    ce(this, Na);
    ce(this, Es);
    ce(this, Ss);
    te(this, nt, e.queryCache || new GM()), te(this, _a, e.mutationCache || new $M()), te(this, Da, e.defaultOptions || {}), te(this, ws, /* @__PURE__ */ new Map()), te(this, xs, /* @__PURE__ */ new Map()), te(this, Na, 0);
  }
  mount() {
    Ou(this, Na)._++, _(this, Na) === 1 && (te(this, Es, by.subscribe(async (e) => {
      e && (await this.resumePausedMutations(), _(this, nt).onFocus());
    })), te(this, Ss, ud.subscribe(async (e) => {
      e && (await this.resumePausedMutations(), _(this, nt).onOnline());
    })));
  }
  unmount() {
    var e, t;
    Ou(this, Na)._--, _(this, Na) === 0 && ((e = _(this, Es)) == null || e.call(this), te(this, Es, void 0), (t = _(this, Ss)) == null || t.call(this), te(this, Ss, void 0));
  }
  isFetching(e) {
    return _(this, nt).findAll({ ...e, fetchStatus: "fetching" }).length;
  }
  isMutating(e) {
    return _(this, _a).findAll({ ...e, status: "pending" }).length;
  }
  /**
   * Imperative (non-reactive) way to retrieve data for a QueryKey.
   * Should only be used in callbacks or functions where reading the latest data is necessary, e.g. for optimistic updates.
   *
   * Hint: Do not use this function inside a component, because it won't receive updates.
   * Use `useQuery` to create a `QueryObserver` that subscribes to changes.
   */
  getQueryData(e) {
    var n;
    const t = this.defaultQueryOptions({ queryKey: e });
    return (n = _(this, nt).get(t.queryHash)) == null ? void 0 : n.state.data;
  }
  ensureQueryData(e) {
    const t = this.defaultQueryOptions(e), n = _(this, nt).build(this, t), r = n.state.data;
    return r === void 0 ? this.fetchQuery(e) : (e.revalidateIfStale && n.isStaleByTime(Ga(t.staleTime, n)) && this.prefetchQuery(t), Promise.resolve(r));
  }
  getQueriesData(e) {
    return _(this, nt).findAll(e).map(({ queryKey: t, state: n }) => {
      const r = n.data;
      return [t, r];
    });
  }
  setQueryData(e, t, n) {
    const r = this.defaultQueryOptions({ queryKey: e }), a = _(this, nt).get(
      r.queryHash
    ), i = a == null ? void 0 : a.state.data, o = _M(t, i);
    if (o !== void 0)
      return _(this, nt).build(this, r).setData(o, { ...n, manual: !0 });
  }
  setQueriesData(e, t, n) {
    return Lt.batch(
      () => _(this, nt).findAll(e).map(({ queryKey: r }) => [
        r,
        this.setQueryData(r, t, n)
      ])
    );
  }
  getQueryState(e) {
    var n;
    const t = this.defaultQueryOptions({ queryKey: e });
    return (n = _(this, nt).get(
      t.queryHash
    )) == null ? void 0 : n.state;
  }
  removeQueries(e) {
    const t = _(this, nt);
    Lt.batch(() => {
      t.findAll(e).forEach((n) => {
        t.remove(n);
      });
    });
  }
  resetQueries(e, t) {
    const n = _(this, nt);
    return Lt.batch(() => (n.findAll(e).forEach((r) => {
      r.reset();
    }), this.refetchQueries(
      {
        type: "active",
        ...e
      },
      t
    )));
  }
  cancelQueries(e, t = {}) {
    const n = { revert: !0, ...t }, r = Lt.batch(
      () => _(this, nt).findAll(e).map((a) => a.cancel(n))
    );
    return Promise.all(r).then(rn).catch(rn);
  }
  invalidateQueries(e, t = {}) {
    return Lt.batch(() => (_(this, nt).findAll(e).forEach((n) => {
      n.invalidate();
    }), (e == null ? void 0 : e.refetchType) === "none" ? Promise.resolve() : this.refetchQueries(
      {
        ...e,
        type: (e == null ? void 0 : e.refetchType) ?? (e == null ? void 0 : e.type) ?? "active"
      },
      t
    )));
  }
  refetchQueries(e, t = {}) {
    const n = {
      ...t,
      cancelRefetch: t.cancelRefetch ?? !0
    }, r = Lt.batch(
      () => _(this, nt).findAll(e).filter((a) => !a.isDisabled() && !a.isStatic()).map((a) => {
        let i = a.fetch(void 0, n);
        return n.throwOnError || (i = i.catch(rn)), a.state.fetchStatus === "paused" ? Promise.resolve() : i;
      })
    );
    return Promise.all(r).then(rn);
  }
  fetchQuery(e) {
    const t = this.defaultQueryOptions(e);
    t.retry === void 0 && (t.retry = !1);
    const n = _(this, nt).build(this, t);
    return n.isStaleByTime(
      Ga(t.staleTime, n)
    ) ? n.fetch(t) : Promise.resolve(n.state.data);
  }
  prefetchQuery(e) {
    return this.fetchQuery(e).then(rn).catch(rn);
  }
  fetchInfiniteQuery(e) {
    return e.behavior = Tw(e.pages), this.fetchQuery(e);
  }
  prefetchInfiniteQuery(e) {
    return this.fetchInfiniteQuery(e).then(rn).catch(rn);
  }
  ensureInfiniteQueryData(e) {
    return e.behavior = Tw(e.pages), this.ensureQueryData(e);
  }
  resumePausedMutations() {
    return ud.isOnline() ? _(this, _a).resumePausedMutations() : Promise.resolve();
  }
  getQueryCache() {
    return _(this, nt);
  }
  getMutationCache() {
    return _(this, _a);
  }
  getDefaultOptions() {
    return _(this, Da);
  }
  setDefaultOptions(e) {
    te(this, Da, e);
  }
  setQueryDefaults(e, t) {
    _(this, ws).set(Cc(e), {
      queryKey: e,
      defaultOptions: t
    });
  }
  getQueryDefaults(e) {
    const t = [..._(this, ws).values()], n = {};
    return t.forEach((r) => {
      Oc(e, r.queryKey) && Object.assign(n, r.defaultOptions);
    }), n;
  }
  setMutationDefaults(e, t) {
    _(this, xs).set(Cc(e), {
      mutationKey: e,
      defaultOptions: t
    });
  }
  getMutationDefaults(e) {
    const t = [..._(this, xs).values()], n = {};
    return t.forEach((r) => {
      Oc(e, r.mutationKey) && Object.assign(n, r.defaultOptions);
    }), n;
  }
  defaultQueryOptions(e) {
    if (e._defaulted)
      return e;
    const t = {
      ..._(this, Da).queries,
      ...this.getQueryDefaults(e.queryKey),
      ...e,
      _defaulted: !0
    };
    return t.queryHash || (t.queryHash = vy(
      t.queryKey,
      t
    )), t.refetchOnReconnect === void 0 && (t.refetchOnReconnect = t.networkMode !== "always"), t.throwOnError === void 0 && (t.throwOnError = !!t.suspense), !t.networkMode && t.persister && (t.networkMode = "offlineFirst"), t.queryFn === yy && (t.enabled = !1), t;
  }
  defaultMutationOptions(e) {
    return e != null && e._defaulted ? e : {
      ..._(this, Da).mutations,
      ...(e == null ? void 0 : e.mutationKey) && this.getMutationDefaults(e.mutationKey),
      ...e,
      _defaulted: !0
    };
  }
  clear() {
    _(this, nt).clear(), _(this, _a).clear();
  }
}, nt = new WeakMap(), _a = new WeakMap(), Da = new WeakMap(), ws = new WeakMap(), xs = new WeakMap(), Na = new WeakMap(), Es = new WeakMap(), Ss = new WeakMap(), bS), MO = y.createContext(
  void 0
), xy = (e) => {
  const t = y.useContext(MO);
  if (!t)
    throw new Error("No QueryClient set, use QueryClientProvider to set one");
  return t;
}, Ey = ({
  client: e,
  children: t
}) => (y.useEffect(() => (e.mount(), () => {
  e.unmount();
}), [e]), /* @__PURE__ */ N.jsx(MO.Provider, { value: e, children: t })), LO = y.createContext(!1), YM = () => y.useContext(LO);
LO.Provider;
function KM() {
  let e = !1;
  return {
    clearReset: () => {
      e = !1;
    },
    reset: () => {
      e = !0;
    },
    isReset: () => e
  };
}
var XM = y.createContext(KM()), WM = () => y.useContext(XM), ZM = (e, t) => {
  (e.suspense || e.throwOnError || e.experimental_prefetchInRender) && (t.isReset() || (e.retryOnMount = !1));
}, JM = (e) => {
  y.useEffect(() => {
    e.clearReset();
  }, [e]);
}, e2 = ({
  result: e,
  errorResetBoundary: t,
  throwOnError: n,
  query: r,
  suspense: a
}) => e.isError && !t.isReset() && !e.isFetching && r && (a && e.data === void 0 || LM(n, [e.error, r])), t2 = (e) => {
  if (e.suspense) {
    const n = (a) => a === "static" ? a : Math.max(a ?? 1e3, 1e3), r = e.staleTime;
    e.staleTime = typeof r == "function" ? (...a) => n(r(...a)) : n(r), typeof e.gcTime == "number" && (e.gcTime = Math.max(
      e.gcTime,
      1e3
    ));
  }
}, n2 = (e, t) => e.isLoading && e.isFetching && !t, r2 = (e, t) => (e == null ? void 0 : e.suspense) && t.isPending, Cw = (e, t, n) => t.fetchOptimistic(e).catch(() => {
  n.clearReset();
});
function a2(e, t, n) {
  var f, d, h, g, v;
  const r = YM(), a = WM(), i = xy(), o = i.defaultQueryOptions(e);
  (d = (f = i.getDefaultOptions().queries) == null ? void 0 : f._experimental_beforeQuery) == null || d.call(
    f,
    o
  ), o._optimisticResults = r ? "isRestoring" : "optimistic", t2(o), ZM(o, a), JM(a);
  const s = !i.getQueryCache().get(o.queryHash), [l] = y.useState(
    () => new t(
      i,
      o
    )
  ), c = l.getOptimisticResult(o), u = !r && e.subscribed !== !1;
  if (y.useSyncExternalStore(
    y.useCallback(
      (b) => {
        const p = u ? l.subscribe(Lt.batchCalls(b)) : rn;
        return l.updateResult(), p;
      },
      [l, u]
    ),
    () => l.getCurrentResult(),
    () => l.getCurrentResult()
  ), y.useEffect(() => {
    l.setOptions(o);
  }, [o, l]), r2(o, c))
    throw Cw(o, l, a);
  if (e2({
    result: c,
    errorResetBoundary: a,
    throwOnError: o.throwOnError,
    query: i.getQueryCache().get(o.queryHash),
    suspense: o.suspense
  }))
    throw c.error;
  if ((g = (h = i.getDefaultOptions().queries) == null ? void 0 : h._experimental_afterQuery) == null || g.call(
    h,
    o,
    c
  ), o.experimental_prefetchInRender && !Wi && n2(c, r)) {
    const b = s ? (
      // Fetch immediately on render in order to ensure `.promise` is resolved even if the component is unmounted
      Cw(o, l, a)
    ) : (
      // subscribe to the "cache promise" so that we can finalize the currentThenable once data comes in
      (v = i.getQueryCache().get(o.queryHash)) == null ? void 0 : v.promise
    );
    b == null || b.catch(rn).finally(() => {
      l.updateResult();
    });
  }
  return o.notifyOnChangeProps ? c : l.trackResult(c);
}
function Sy(e, t) {
  return a2(e, qM);
}
/**
 * react-router v7.9.6
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
var zO = (e) => {
  throw TypeError(e);
}, i2 = (e, t, n) => t.has(e) || zO("Cannot " + n), fp = (e, t, n) => (i2(e, t, "read from private field"), n ? n.call(e) : t.get(e)), o2 = (e, t, n) => t.has(e) ? zO("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, n);
function s2(e = {}) {
  let { initialEntries: t = ["/"], initialIndex: n, v5Compat: r = !1 } = e, a;
  a = t.map(
    (h, g) => u(
      h,
      typeof h == "string" ? null : h.state,
      g === 0 ? "default" : void 0
    )
  );
  let i = l(
    n ?? a.length - 1
  ), o = "POP", s = null;
  function l(h) {
    return Math.min(Math.max(h, 0), a.length - 1);
  }
  function c() {
    return a[i];
  }
  function u(h, g = null, v) {
    let b = dg(
      a ? c().pathname : "/",
      h,
      g,
      v
    );
    return Je(
      b.pathname.charAt(0) === "/",
      `relative pathnames are not supported in memory history: ${JSON.stringify(
        h
      )}`
    ), b;
  }
  function f(h) {
    return typeof h == "string" ? h : cr(h);
  }
  return {
    get index() {
      return i;
    },
    get action() {
      return o;
    },
    get location() {
      return c();
    },
    createHref: f,
    createURL(h) {
      return new URL(f(h), "http://localhost");
    },
    encodeLocation(h) {
      let g = typeof h == "string" ? ta(h) : h;
      return {
        pathname: g.pathname || "",
        search: g.search || "",
        hash: g.hash || ""
      };
    },
    push(h, g) {
      o = "PUSH";
      let v = u(h, g);
      i += 1, a.splice(i, a.length, v), r && s && s({ action: o, location: v, delta: 1 });
    },
    replace(h, g) {
      o = "REPLACE";
      let v = u(h, g);
      a[i] = v, r && s && s({ action: o, location: v, delta: 0 });
    },
    go(h) {
      o = "POP";
      let g = l(i + h), v = a[g];
      i = g, s && s({ action: o, location: v, delta: h });
    },
    listen(h) {
      return s = h, () => {
        s = null;
      };
    }
  };
}
function be(e, t) {
  if (e === !1 || e === null || typeof e > "u")
    throw new Error(t);
}
function Je(e, t) {
  if (!e) {
    typeof console < "u" && console.warn(t);
    try {
      throw new Error(t);
    } catch {
    }
  }
}
function l2() {
  return Math.random().toString(36).substring(2, 10);
}
function dg(e, t, n = null, r) {
  return {
    pathname: typeof e == "string" ? e : e.pathname,
    search: "",
    hash: "",
    ...typeof t == "string" ? ta(t) : t,
    state: n,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: t && t.key || r || l2()
  };
}
function cr({
  pathname: e = "/",
  search: t = "",
  hash: n = ""
}) {
  return t && t !== "?" && (e += t.charAt(0) === "?" ? t : "?" + t), n && n !== "#" && (e += n.charAt(0) === "#" ? n : "#" + n), e;
}
function ta(e) {
  let t = {};
  if (e) {
    let n = e.indexOf("#");
    n >= 0 && (t.hash = e.substring(n), e = e.substring(0, n));
    let r = e.indexOf("?");
    r >= 0 && (t.search = e.substring(r), e = e.substring(0, r)), e && (t.pathname = e);
  }
  return t;
}
function c2(e, t = !1) {
  let n = "http://localhost";
  typeof window < "u" && (n = window.location.origin !== "null" ? window.location.origin : window.location.href), be(n, "No window.location.(origin|href) available to create URL");
  let r = typeof e == "string" ? e : cr(e);
  return r = r.replace(/ $/, "%20"), !t && r.startsWith("//") && (r = n + r), new URL(r, n);
}
var Il, Ow = class {
  /**
   * Create a new `RouterContextProvider` instance
   * @param init An optional initial context map to populate the provider with
   */
  constructor(e) {
    if (o2(this, Il, /* @__PURE__ */ new Map()), e)
      for (let [t, n] of e)
        this.set(t, n);
  }
  /**
   * Access a value from the context. If no value has been set for the context,
   * it will return the context's `defaultValue` if provided, or throw an error
   * if no `defaultValue` was set.
   * @param context The context to get the value for
   * @returns The value for the context, or the context's `defaultValue` if no
   * value was set
   */
  get(e) {
    if (fp(this, Il).has(e))
      return fp(this, Il).get(e);
    if (e.defaultValue !== void 0)
      return e.defaultValue;
    throw new Error("No value found for context");
  }
  /**
   * Set a value for the context. If the context already has a value set, this
   * will overwrite it.
   *
   * @param context The context to set the value for
   * @param value The value to set for the context
   * @returns {void}
   */
  set(e, t) {
    fp(this, Il).set(e, t);
  }
};
Il = /* @__PURE__ */ new WeakMap();
var u2 = /* @__PURE__ */ new Set([
  "lazy",
  "caseSensitive",
  "path",
  "id",
  "index",
  "children"
]);
function f2(e) {
  return u2.has(
    e
  );
}
var d2 = /* @__PURE__ */ new Set([
  "lazy",
  "caseSensitive",
  "path",
  "id",
  "index",
  "middleware",
  "children"
]);
function h2(e) {
  return d2.has(
    e
  );
}
function p2(e) {
  return e.index === !0;
}
function Ac(e, t, n = [], r = {}, a = !1) {
  return e.map((i, o) => {
    let s = [...n, String(o)], l = typeof i.id == "string" ? i.id : s.join("-");
    if (be(
      i.index !== !0 || !i.children,
      "Cannot specify children on an index route"
    ), be(
      a || !r[l],
      `Found a route id collision on id "${l}".  Route id's must be globally unique within Data Router usages`
    ), p2(i)) {
      let c = {
        ...i,
        id: l
      };
      return r[l] = Aw(
        c,
        t(c)
      ), c;
    } else {
      let c = {
        ...i,
        id: l,
        children: void 0
      };
      return r[l] = Aw(
        c,
        t(c)
      ), i.children && (c.children = Ac(
        i.children,
        t,
        s,
        r,
        a
      )), c;
    }
  });
}
function Aw(e, t) {
  return Object.assign(e, {
    ...t,
    ...typeof t.lazy == "object" && t.lazy != null ? {
      lazy: {
        ...e.lazy,
        ...t.lazy
      }
    } : {}
  });
}
function Ea(e, t, n = "/") {
  return Fl(e, t, n, !1);
}
function Fl(e, t, n, r) {
  let a = typeof t == "string" ? ta(t) : t, i = jn(a.pathname || "/", n);
  if (i == null)
    return null;
  let o = jO(e);
  g2(o);
  let s = null;
  for (let l = 0; s == null && l < o.length; ++l) {
    let c = A2(i);
    s = C2(
      o[l],
      c,
      r
    );
  }
  return s;
}
function m2(e, t) {
  let { route: n, pathname: r, params: a } = e;
  return {
    id: n.id,
    pathname: r,
    params: a,
    data: t[n.id],
    loaderData: t[n.id],
    handle: n.handle
  };
}
function jO(e, t = [], n = [], r = "", a = !1) {
  let i = (o, s, l = a, c) => {
    let u = {
      relativePath: c === void 0 ? o.path || "" : c,
      caseSensitive: o.caseSensitive === !0,
      childrenIndex: s,
      route: o
    };
    if (u.relativePath.startsWith("/")) {
      if (!u.relativePath.startsWith(r) && l)
        return;
      be(
        u.relativePath.startsWith(r),
        `Absolute route path "${u.relativePath}" nested under path "${r}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`
      ), u.relativePath = u.relativePath.slice(r.length);
    }
    let f = or([r, u.relativePath]), d = n.concat(u);
    o.children && o.children.length > 0 && (be(
      // Our types know better, but runtime JS may not!
      // @ts-expect-error
      o.index !== !0,
      `Index routes must not have child routes. Please remove all child routes from route path "${f}".`
    ), jO(
      o.children,
      t,
      d,
      f,
      l
    )), !(o.path == null && !o.index) && t.push({
      path: f,
      score: S2(f, o.index),
      routesMeta: d
    });
  };
  return e.forEach((o, s) => {
    var l;
    if (o.path === "" || !((l = o.path) != null && l.includes("?")))
      i(o, s);
    else
      for (let c of PO(o.path))
        i(o, s, !0, c);
  }), t;
}
function PO(e) {
  let t = e.split("/");
  if (t.length === 0) return [];
  let [n, ...r] = t, a = n.endsWith("?"), i = n.replace(/\?$/, "");
  if (r.length === 0)
    return a ? [i, ""] : [i];
  let o = PO(r.join("/")), s = [];
  return s.push(
    ...o.map(
      (l) => l === "" ? i : [i, l].join("/")
    )
  ), a && s.push(...o), s.map(
    (l) => e.startsWith("/") && l === "" ? "/" : l
  );
}
function g2(e) {
  e.sort(
    (t, n) => t.score !== n.score ? n.score - t.score : T2(
      t.routesMeta.map((r) => r.childrenIndex),
      n.routesMeta.map((r) => r.childrenIndex)
    )
  );
}
var v2 = /^:[\w-]+$/, y2 = 3, b2 = 2, w2 = 1, x2 = 10, E2 = -2, Rw = (e) => e === "*";
function S2(e, t) {
  let n = e.split("/"), r = n.length;
  return n.some(Rw) && (r += E2), t && (r += b2), n.filter((a) => !Rw(a)).reduce(
    (a, i) => a + (v2.test(i) ? y2 : i === "" ? w2 : x2),
    r
  );
}
function T2(e, t) {
  return e.length === t.length && e.slice(0, -1).every((r, a) => r === t[a]) ? (
    // If two routes are siblings, we should try to match the earlier sibling
    // first. This allows people to have fine-grained control over the matching
    // behavior by simply putting routes with identical paths in the order they
    // want them tried.
    e[e.length - 1] - t[t.length - 1]
  ) : (
    // Otherwise, it doesn't really make sense to rank non-siblings by index,
    // so they sort equally.
    0
  );
}
function C2(e, t, n = !1) {
  let { routesMeta: r } = e, a = {}, i = "/", o = [];
  for (let s = 0; s < r.length; ++s) {
    let l = r[s], c = s === r.length - 1, u = i === "/" ? t : t.slice(i.length) || "/", f = fd(
      { path: l.relativePath, caseSensitive: l.caseSensitive, end: c },
      u
    ), d = l.route;
    if (!f && c && n && !r[r.length - 1].route.index && (f = fd(
      {
        path: l.relativePath,
        caseSensitive: l.caseSensitive,
        end: !1
      },
      u
    )), !f)
      return null;
    Object.assign(a, f.params), o.push({
      // TODO: Can this as be avoided?
      params: a,
      pathname: or([i, f.pathname]),
      pathnameBase: N2(
        or([i, f.pathnameBase])
      ),
      route: d
    }), f.pathnameBase !== "/" && (i = or([i, f.pathnameBase]));
  }
  return o;
}
function fd(e, t) {
  typeof e == "string" && (e = { path: e, caseSensitive: !1, end: !0 });
  let [n, r] = O2(
    e.path,
    e.caseSensitive,
    e.end
  ), a = t.match(n);
  if (!a) return null;
  let i = a[0], o = i.replace(/(.)\/+$/, "$1"), s = a.slice(1);
  return {
    params: r.reduce(
      (c, { paramName: u, isOptional: f }, d) => {
        if (u === "*") {
          let g = s[d] || "";
          o = i.slice(0, i.length - g.length).replace(/(.)\/+$/, "$1");
        }
        const h = s[d];
        return f && !h ? c[u] = void 0 : c[u] = (h || "").replace(/%2F/g, "/"), c;
      },
      {}
    ),
    pathname: i,
    pathnameBase: o,
    pattern: e
  };
}
function O2(e, t = !1, n = !0) {
  Je(
    e === "*" || !e.endsWith("*") || e.endsWith("/*"),
    `Route path "${e}" will be treated as if it were "${e.replace(/\*$/, "/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${e.replace(/\*$/, "/*")}".`
  );
  let r = [], a = "^" + e.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(
    /\/:([\w-]+)(\?)?/g,
    (o, s, l) => (r.push({ paramName: s, isOptional: l != null }), l ? "/?([^\\/]+)?" : "/([^\\/]+)")
  ).replace(/\/([\w-]+)\?(\/|$)/g, "(/$1)?$2");
  return e.endsWith("*") ? (r.push({ paramName: "*" }), a += e === "*" || e === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : n ? a += "\\/*$" : e !== "" && e !== "/" && (a += "(?:(?=\\/|$))"), [new RegExp(a, t ? void 0 : "i"), r];
}
function A2(e) {
  try {
    return e.split("/").map((t) => decodeURIComponent(t).replace(/\//g, "%2F")).join("/");
  } catch (t) {
    return Je(
      !1,
      `The URL path "${e}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${t}).`
    ), e;
  }
}
function jn(e, t) {
  if (t === "/") return e;
  if (!e.toLowerCase().startsWith(t.toLowerCase()))
    return null;
  let n = t.endsWith("/") ? t.length - 1 : t.length, r = e.charAt(n);
  return r && r !== "/" ? null : e.slice(n) || "/";
}
function R2({
  basename: e,
  pathname: t
}) {
  return t === "/" ? e : or([e, t]);
}
var _2 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, Kd = (e) => _2.test(e);
function D2(e, t = "/") {
  let {
    pathname: n,
    search: r = "",
    hash: a = ""
  } = typeof e == "string" ? ta(e) : e, i;
  if (n)
    if (Kd(n))
      i = n;
    else {
      if (n.includes("//")) {
        let o = n;
        n = n.replace(/\/\/+/g, "/"), Je(
          !1,
          `Pathnames cannot have embedded double slashes - normalizing ${o} -> ${n}`
        );
      }
      n.startsWith("/") ? i = _w(n.substring(1), "/") : i = _w(n, t);
    }
  else
    i = t;
  return {
    pathname: i,
    search: k2(r),
    hash: M2(a)
  };
}
function _w(e, t) {
  let n = t.replace(/\/+$/, "").split("/");
  return e.split("/").forEach((a) => {
    a === ".." ? n.length > 1 && n.pop() : a !== "." && n.push(a);
  }), n.length > 1 ? n.join("/") : "/";
}
function dp(e, t, n, r) {
  return `Cannot include a '${e}' character in a manually specified \`to.${t}\` field [${JSON.stringify(
    r
  )}].  Please separate it out to the \`to.${n}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`;
}
function IO(e) {
  return e.filter(
    (t, n) => n === 0 || t.route.path && t.route.path.length > 0
  );
}
function Ty(e) {
  let t = IO(e);
  return t.map(
    (n, r) => r === t.length - 1 ? n.pathname : n.pathnameBase
  );
}
function Cy(e, t, n, r = !1) {
  let a;
  typeof e == "string" ? a = ta(e) : (a = { ...e }, be(
    !a.pathname || !a.pathname.includes("?"),
    dp("?", "pathname", "search", a)
  ), be(
    !a.pathname || !a.pathname.includes("#"),
    dp("#", "pathname", "hash", a)
  ), be(
    !a.search || !a.search.includes("#"),
    dp("#", "search", "hash", a)
  ));
  let i = e === "" || a.pathname === "", o = i ? "/" : a.pathname, s;
  if (o == null)
    s = n;
  else {
    let f = t.length - 1;
    if (!r && o.startsWith("..")) {
      let d = o.split("/");
      for (; d[0] === ".."; )
        d.shift(), f -= 1;
      a.pathname = d.join("/");
    }
    s = f >= 0 ? t[f] : "/";
  }
  let l = D2(a, s), c = o && o !== "/" && o.endsWith("/"), u = (i || o === ".") && n.endsWith("/");
  return !l.pathname.endsWith("/") && (c || u) && (l.pathname += "/"), l;
}
var or = (e) => e.join("/").replace(/\/\/+/g, "/"), N2 = (e) => e.replace(/\/+$/, "").replace(/^\/*/, "/"), k2 = (e) => !e || e === "?" ? "" : e.startsWith("?") ? e : "?" + e, M2 = (e) => !e || e === "#" ? "" : e.startsWith("#") ? e : "#" + e, hg = class {
  constructor(e, t, n, r = !1) {
    this.status = e, this.statusText = t || "", this.internal = r, n instanceof Error ? (this.data = n.toString(), this.error = n) : this.data = n;
  }
};
function Rc(e) {
  return e != null && typeof e.status == "number" && typeof e.statusText == "string" && typeof e.internal == "boolean" && "data" in e;
}
function Oy(e) {
  return e.filter(Boolean).join("/").replace(/\/\/*/g, "/") || "/";
}
var Pa = Symbol("Uninstrumented");
function L2(e, t) {
  let n = {
    lazy: [],
    "lazy.loader": [],
    "lazy.action": [],
    "lazy.middleware": [],
    middleware: [],
    loader: [],
    action: []
  };
  e.forEach(
    (a) => a({
      id: t.id,
      index: t.index,
      path: t.path,
      instrument(i) {
        let o = Object.keys(n);
        for (let s of o)
          i[s] && n[s].push(i[s]);
      }
    })
  );
  let r = {};
  if (typeof t.lazy == "function" && n.lazy.length > 0) {
    let a = Qo(n.lazy, t.lazy, () => {
    });
    a && (r.lazy = a);
  }
  if (typeof t.lazy == "object") {
    let a = t.lazy;
    ["middleware", "loader", "action"].forEach((i) => {
      let o = a[i], s = n[`lazy.${i}`];
      if (typeof o == "function" && s.length > 0) {
        let l = Qo(s, o, () => {
        });
        l && (r.lazy = Object.assign(r.lazy || {}, {
          [i]: l
        }));
      }
    });
  }
  return ["loader", "action"].forEach((a) => {
    let i = t[a];
    if (typeof i == "function" && n[a].length > 0) {
      let o = i[Pa] ?? i, s = Qo(
        n[a],
        o,
        (...l) => Dw(l[0])
      );
      s && (s[Pa] = o, r[a] = s);
    }
  }), t.middleware && t.middleware.length > 0 && n.middleware.length > 0 && (r.middleware = t.middleware.map((a) => {
    let i = a[Pa] ?? a, o = Qo(
      n.middleware,
      i,
      (...s) => Dw(s[0])
    );
    return o ? (o[Pa] = i, o) : a;
  })), r;
}
function z2(e, t) {
  let n = {
    navigate: [],
    fetch: []
  };
  if (t.forEach(
    (r) => r({
      instrument(a) {
        let i = Object.keys(a);
        for (let o of i)
          a[o] && n[o].push(a[o]);
      }
    })
  ), n.navigate.length > 0) {
    let r = e.navigate[Pa] ?? e.navigate, a = Qo(
      n.navigate,
      r,
      (...i) => {
        let [o, s] = i;
        return {
          to: typeof o == "number" || typeof o == "string" ? o : o ? cr(o) : ".",
          ...Nw(e, s ?? {})
        };
      }
    );
    a && (a[Pa] = r, e.navigate = a);
  }
  if (n.fetch.length > 0) {
    let r = e.fetch[Pa] ?? e.fetch, a = Qo(n.fetch, r, (...i) => {
      let [o, , s, l] = i;
      return {
        href: s ?? ".",
        fetcherKey: o,
        ...Nw(e, l ?? {})
      };
    });
    a && (a[Pa] = r, e.fetch = a);
  }
  return e;
}
function Qo(e, t, n) {
  return e.length === 0 ? null : async (...r) => {
    let a = await FO(
      e,
      n(...r),
      () => t(...r),
      e.length - 1
    );
    if (a.type === "error")
      throw a.value;
    return a.value;
  };
}
async function FO(e, t, n, r) {
  let a = e[r], i;
  if (a) {
    let o, s = async () => (o ? console.error("You cannot call instrumented handlers more than once") : o = FO(e, t, n, r - 1), i = await o, be(i, "Expected a result"), i.type === "error" && i.value instanceof Error ? { status: "error", error: i.value } : { status: "success", error: void 0 });
    try {
      await a(s, t);
    } catch (l) {
      console.error("An instrumentation function threw an error:", l);
    }
    o || await s(), await o;
  } else
    try {
      i = { type: "success", value: await n() };
    } catch (o) {
      i = { type: "error", value: o };
    }
  return i || {
    type: "error",
    value: new Error("No result assigned in instrumentation chain.")
  };
}
function Dw(e) {
  let { request: t, context: n, params: r, unstable_pattern: a } = e;
  return {
    request: j2(t),
    params: { ...r },
    unstable_pattern: a,
    context: P2(n)
  };
}
function Nw(e, t) {
  return {
    currentUrl: cr(e.state.location),
    ..."formMethod" in t ? { formMethod: t.formMethod } : {},
    ..."formEncType" in t ? { formEncType: t.formEncType } : {},
    ..."formData" in t ? { formData: t.formData } : {},
    ..."body" in t ? { body: t.body } : {}
  };
}
function j2(e) {
  return {
    method: e.method,
    url: e.url,
    headers: {
      get: (...t) => e.headers.get(...t)
    }
  };
}
function P2(e) {
  if (F2(e)) {
    let t = { ...e };
    return Object.freeze(t), t;
  } else
    return {
      get: (t) => e.get(t)
    };
}
var I2 = Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
function F2(e) {
  if (e === null || typeof e != "object")
    return !1;
  const t = Object.getPrototypeOf(e);
  return t === Object.prototype || t === null || Object.getOwnPropertyNames(t).sort().join("\0") === I2;
}
var UO = [
  "POST",
  "PUT",
  "PATCH",
  "DELETE"
], U2 = new Set(
  UO
), q2 = [
  "GET",
  ...UO
], B2 = new Set(q2), V2 = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]), Q2 = /* @__PURE__ */ new Set([307, 308]), hp = {
  state: "idle",
  location: void 0,
  formMethod: void 0,
  formAction: void 0,
  formEncType: void 0,
  formData: void 0,
  json: void 0,
  text: void 0
}, H2 = {
  state: "idle",
  data: void 0,
  formMethod: void 0,
  formAction: void 0,
  formEncType: void 0,
  formData: void 0,
  json: void 0,
  text: void 0
}, yl = {
  state: "unblocked",
  proceed: void 0,
  reset: void 0,
  location: void 0
}, $2 = (e) => ({
  hasErrorBoundary: !!e.hasErrorBoundary
}), qO = "remix-router-transitions", BO = Symbol("ResetLoaderData");
function G2(e) {
  const t = e.window ? e.window : typeof window < "u" ? window : void 0, n = typeof t < "u" && typeof t.document < "u" && typeof t.document.createElement < "u";
  be(
    e.routes.length > 0,
    "You must provide a non-empty routes array to createRouter"
  );
  let r = e.hydrationRouteProperties || [], a = e.mapRouteProperties || $2, i = a;
  if (e.unstable_instrumentations) {
    let C = e.unstable_instrumentations;
    i = (L) => ({
      ...a(L),
      ...L2(
        C.map((j) => j.route).filter(Boolean),
        L
      )
    });
  }
  let o = {}, s = Ac(
    e.routes,
    i,
    void 0,
    o
  ), l, c = e.basename || "/";
  c.startsWith("/") || (c = `/${c}`);
  let u = e.dataStrategy || Z2, f = {
    ...e.future
  }, d = null, h = /* @__PURE__ */ new Set(), g = null, v = null, b = null, p = e.hydrationData != null, m = Ea(s, e.history.location, c), w = !1, x = null, S;
  if (m == null && !e.patchRoutesOnNavigation) {
    let C = Tn(404, {
      pathname: e.history.location.pathname
    }), { matches: L, route: j } = Qu(s);
    S = !0, m = L, x = { [j.id]: C };
  } else if (m && !e.hydrationData && xu(
    m,
    s,
    e.history.location.pathname
  ).active && (m = null), m)
    if (m.some((C) => C.route.lazy))
      S = !1;
    else if (!m.some((C) => Ay(C.route)))
      S = !0;
    else {
      let C = e.hydrationData ? e.hydrationData.loaderData : null, L = e.hydrationData ? e.hydrationData.errors : null;
      if (L) {
        let j = m.findIndex(
          ($) => L[$.route.id] !== void 0
        );
        S = m.slice(0, j + 1).every(
          ($) => !mg($.route, C, L)
        );
      } else
        S = m.every(
          (j) => !mg(j.route, C, L)
        );
    }
  else {
    S = !1, m = [];
    let C = xu(
      null,
      s,
      e.history.location.pathname
    );
    C.active && C.matches && (w = !0, m = C.matches);
  }
  let T, E = {
    historyAction: e.history.action,
    location: e.history.location,
    matches: m,
    initialized: S,
    navigation: hp,
    // Don't restore on initial updateState() if we were SSR'd
    restoreScrollPosition: e.hydrationData != null ? !1 : null,
    preventScrollReset: !1,
    revalidation: "idle",
    loaderData: e.hydrationData && e.hydrationData.loaderData || {},
    actionData: e.hydrationData && e.hydrationData.actionData || null,
    errors: e.hydrationData && e.hydrationData.errors || x,
    fetchers: /* @__PURE__ */ new Map(),
    blockers: /* @__PURE__ */ new Map()
  }, O = "POP", D = !1, A, U = !1, R = /* @__PURE__ */ new Map(), q = null, z = !1, Q = !1, k = /* @__PURE__ */ new Set(), P = /* @__PURE__ */ new Map(), F = 0, H = -1, K = /* @__PURE__ */ new Map(), Z = /* @__PURE__ */ new Set(), I = /* @__PURE__ */ new Map(), G = /* @__PURE__ */ new Map(), ee = /* @__PURE__ */ new Set(), J = /* @__PURE__ */ new Map(), we, Se = null;
  function Tt() {
    if (d = e.history.listen(
      ({ action: C, location: L, delta: j }) => {
        if (we) {
          we(), we = void 0;
          return;
        }
        Je(
          J.size === 0 || j != null,
          "You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL."
        );
        let $ = jb({
          currentLocation: E.location,
          nextLocation: L,
          historyAction: C
        });
        if ($ && j != null) {
          let Y = new Promise((ae) => {
            we = ae;
          });
          e.history.go(j * -1), wu($, {
            state: "blocked",
            location: L,
            proceed() {
              wu($, {
                state: "proceeding",
                proceed: void 0,
                reset: void 0,
                location: L
              }), Y.then(() => e.history.go(j));
            },
            reset() {
              let ae = new Map(E.blockers);
              ae.set($, yl), yt({ blockers: ae });
            }
          });
          return;
        }
        return wr(C, L);
      }
    ), n) {
      hL(t, R);
      let C = () => pL(t, R);
      t.addEventListener("pagehide", C), q = () => t.removeEventListener("pagehide", C);
    }
    return E.initialized || wr("POP", E.location, {
      initialHydration: !0
    }), T;
  }
  function ft() {
    d && d(), q && q(), h.clear(), A && A.abort(), E.fetchers.forEach((C, L) => Th(L)), E.blockers.forEach((C, L) => zb(L));
  }
  function yr(C) {
    return h.add(C), () => h.delete(C);
  }
  function yt(C, L = {}) {
    C.matches && (C.matches = C.matches.map((Y) => {
      let ae = o[Y.route.id], ie = Y.route;
      return ie.element !== ae.element || ie.errorElement !== ae.errorElement || ie.hydrateFallbackElement !== ae.hydrateFallbackElement ? {
        ...Y,
        route: ae
      } : Y;
    })), E = {
      ...E,
      ...C
    };
    let j = [], $ = [];
    E.fetchers.forEach((Y, ae) => {
      Y.state === "idle" && (ee.has(ae) ? j.push(ae) : $.push(ae));
    }), ee.forEach((Y) => {
      !E.fetchers.has(Y) && !P.has(Y) && j.push(Y);
    }), [...h].forEach(
      (Y) => Y(E, {
        deletedFetchers: j,
        viewTransitionOpts: L.viewTransitionOpts,
        flushSync: L.flushSync === !0
      })
    ), j.forEach((Y) => Th(Y)), $.forEach((Y) => E.fetchers.delete(Y));
  }
  function br(C, L, { flushSync: j } = {}) {
    var ue, se;
    let $ = E.actionData != null && E.navigation.formMethod != null && Ht(E.navigation.formMethod) && E.navigation.state === "loading" && ((ue = C.state) == null ? void 0 : ue._isRedirect) !== !0, Y;
    L.actionData ? Object.keys(L.actionData).length > 0 ? Y = L.actionData : Y = null : $ ? Y = E.actionData : Y = null;
    let ae = L.loaderData ? qw(
      E.loaderData,
      L.loaderData,
      L.matches || [],
      L.errors
    ) : E.loaderData, ie = E.blockers;
    ie.size > 0 && (ie = new Map(ie), ie.forEach((me, Ue) => ie.set(Ue, yl)));
    let re = z ? !1 : Ib(C, L.matches || E.matches), oe = D === !0 || E.navigation.formMethod != null && Ht(E.navigation.formMethod) && ((se = C.state) == null ? void 0 : se._isRedirect) !== !0;
    l && (s = l, l = void 0), z || O === "POP" || (O === "PUSH" ? e.history.push(C, C.state) : O === "REPLACE" && e.history.replace(C, C.state));
    let le;
    if (O === "POP") {
      let me = R.get(E.location.pathname);
      me && me.has(C.pathname) ? le = {
        currentLocation: E.location,
        nextLocation: C
      } : R.has(C.pathname) && (le = {
        currentLocation: C,
        nextLocation: E.location
      });
    } else if (U) {
      let me = R.get(E.location.pathname);
      me ? me.add(C.pathname) : (me = /* @__PURE__ */ new Set([C.pathname]), R.set(E.location.pathname, me)), le = {
        currentLocation: E.location,
        nextLocation: C
      };
    }
    yt(
      {
        ...L,
        // matches, errors, fetchers go through as-is
        actionData: Y,
        loaderData: ae,
        historyAction: O,
        location: C,
        initialized: !0,
        navigation: hp,
        revalidation: "idle",
        restoreScrollPosition: re,
        preventScrollReset: oe,
        blockers: ie
      },
      {
        viewTransitionOpts: le,
        flushSync: j === !0
      }
    ), O = "POP", D = !1, U = !1, z = !1, Q = !1, Se == null || Se.resolve(), Se = null;
  }
  async function ra(C, L) {
    if (typeof C == "number") {
      e.history.go(C);
      return;
    }
    let j = pg(
      E.location,
      E.matches,
      c,
      C,
      L == null ? void 0 : L.fromRouteId,
      L == null ? void 0 : L.relative
    ), { path: $, submission: Y, error: ae } = kw(
      !1,
      j,
      L
    ), ie = E.location, re = dg(E.location, $, L && L.state);
    re = {
      ...re,
      ...e.history.encodeLocation(re)
    };
    let oe = L && L.replace != null ? L.replace : void 0, le = "PUSH";
    oe === !0 ? le = "REPLACE" : oe === !1 || Y != null && Ht(Y.formMethod) && Y.formAction === E.location.pathname + E.location.search && (le = "REPLACE");
    let ue = L && "preventScrollReset" in L ? L.preventScrollReset === !0 : void 0, se = (L && L.flushSync) === !0, me = jb({
      currentLocation: ie,
      nextLocation: re,
      historyAction: le
    });
    if (me) {
      wu(me, {
        state: "blocked",
        location: re,
        proceed() {
          wu(me, {
            state: "proceeding",
            proceed: void 0,
            reset: void 0,
            location: re
          }), ra(C, L);
        },
        reset() {
          let Ue = new Map(E.blockers);
          Ue.set(me, yl), yt({ blockers: Ue });
        }
      });
      return;
    }
    await wr(le, re, {
      submission: Y,
      // Send through the formData serialization error if we have one so we can
      // render at the right error boundary after we match routes
      pendingError: ae,
      preventScrollReset: ue,
      replace: L && L.replace,
      enableViewTransition: L && L.viewTransition,
      flushSync: se
    });
  }
  function yu() {
    Se || (Se = mL()), Sh(), yt({ revalidation: "loading" });
    let C = Se.promise;
    return E.navigation.state === "submitting" ? C : E.navigation.state === "idle" ? (wr(E.historyAction, E.location, {
      startUninterruptedRevalidation: !0
    }), C) : (wr(
      O || E.historyAction,
      E.navigation.location,
      {
        overrideNavigation: E.navigation,
        // Proxy through any rending view transition
        enableViewTransition: U === !0
      }
    ), C);
  }
  async function wr(C, L, j) {
    A && A.abort(), A = null, O = C, z = (j && j.startUninterruptedRevalidation) === !0, ED(E.location, E.matches), D = (j && j.preventScrollReset) === !0, U = (j && j.enableViewTransition) === !0;
    let $ = l || s, Y = j && j.overrideNavigation, ae = j != null && j.initialHydration && E.matches && E.matches.length > 0 && !w ? (
      // `matchRoutes()` has already been called if we're in here via `router.initialize()`
      E.matches
    ) : Ea($, L, c), ie = (j && j.flushSync) === !0;
    if (ae && E.initialized && !Q && oL(E.location, L) && !(j && j.submission && Ht(j.submission.formMethod))) {
      br(L, { matches: ae }, { flushSync: ie });
      return;
    }
    let re = xu(ae, $, L.pathname);
    if (re.active && re.matches && (ae = re.matches), !ae) {
      let { error: Ct, notFoundMatches: Ve, route: Qe } = Ch(
        L.pathname
      );
      br(
        L,
        {
          matches: Ve,
          loaderData: {},
          errors: {
            [Qe.id]: Ct
          }
        },
        { flushSync: ie }
      );
      return;
    }
    A = new AbortController();
    let oe = Ao(
      e.history,
      L,
      A.signal,
      j && j.submission
    ), le = e.getContext ? await e.getContext() : new Ow(), ue;
    if (j && j.pendingError)
      ue = [
        Sa(ae).route.id,
        { type: "error", error: j.pendingError }
      ];
    else if (j && j.submission && Ht(j.submission.formMethod)) {
      let Ct = await xh(
        oe,
        L,
        j.submission,
        ae,
        le,
        re.active,
        j && j.initialHydration === !0,
        { replace: j.replace, flushSync: ie }
      );
      if (Ct.shortCircuited)
        return;
      if (Ct.pendingActionResult) {
        let [Ve, Qe] = Ct.pendingActionResult;
        if (un(Qe) && Rc(Qe.error) && Qe.error.status === 404) {
          A = null, br(L, {
            matches: Ct.matches,
            loaderData: {},
            errors: {
              [Ve]: Qe.error
            }
          });
          return;
        }
      }
      ae = Ct.matches || ae, ue = Ct.pendingActionResult, Y = pp(L, j.submission), ie = !1, re.active = !1, oe = Ao(
        e.history,
        oe.url,
        oe.signal
      );
    }
    let {
      shortCircuited: se,
      matches: me,
      loaderData: Ue,
      errors: bt
    } = await Eh(
      oe,
      L,
      ae,
      le,
      re.active,
      Y,
      j && j.submission,
      j && j.fetcherSubmission,
      j && j.replace,
      j && j.initialHydration === !0,
      ie,
      ue
    );
    se || (A = null, br(L, {
      matches: me || ae,
      ...Bw(ue),
      loaderData: Ue,
      errors: bt
    }));
  }
  async function xh(C, L, j, $, Y, ae, ie, re = {}) {
    Sh();
    let oe = fL(L, j);
    if (yt({ navigation: oe }, { flushSync: re.flushSync === !0 }), ae) {
      let se = await Eu(
        $,
        L.pathname,
        C.signal
      );
      if (se.type === "aborted")
        return { shortCircuited: !0 };
      if (se.type === "error") {
        if (se.partialMatches.length === 0) {
          let { matches: Ue, route: bt } = Qu(s);
          return {
            matches: Ue,
            pendingActionResult: [
              bt.id,
              {
                type: "error",
                error: se.error
              }
            ]
          };
        }
        let me = Sa(se.partialMatches).route.id;
        return {
          matches: se.partialMatches,
          pendingActionResult: [
            me,
            {
              type: "error",
              error: se.error
            }
          ]
        };
      } else if (se.matches)
        $ = se.matches;
      else {
        let { notFoundMatches: me, error: Ue, route: bt } = Ch(
          L.pathname
        );
        return {
          matches: me,
          pendingActionResult: [
            bt.id,
            {
              type: "error",
              error: Ue
            }
          ]
        };
      }
    }
    let le, ue = xf($, L);
    if (!ue.route.action && !ue.route.lazy)
      le = {
        type: "error",
        error: Tn(405, {
          method: C.method,
          pathname: L.pathname,
          routeId: ue.route.id
        })
      };
    else {
      let se = rs(
        i,
        o,
        C,
        $,
        ue,
        ie ? [] : r,
        Y
      ), me = await ll(
        C,
        se,
        Y,
        null
      );
      if (le = me[ue.route.id], !le) {
        for (let Ue of $)
          if (me[Ue.route.id]) {
            le = me[Ue.route.id];
            break;
          }
      }
      if (C.signal.aborted)
        return { shortCircuited: !0 };
    }
    if (Ri(le)) {
      let se;
      return re && re.replace != null ? se = re.replace : se = Iw(
        le.response.headers.get("Location"),
        new URL(C.url),
        c
      ) === E.location.pathname + E.location.search, await pi(C, le, !0, {
        submission: j,
        replace: se
      }), { shortCircuited: !0 };
    }
    if (un(le)) {
      let se = Sa($, ue.route.id);
      return (re && re.replace) !== !0 && (O = "PUSH"), {
        matches: $,
        pendingActionResult: [
          se.route.id,
          le,
          ue.route.id
        ]
      };
    }
    return {
      matches: $,
      pendingActionResult: [ue.route.id, le]
    };
  }
  async function Eh(C, L, j, $, Y, ae, ie, re, oe, le, ue, se) {
    let me = ae || pp(L, ie), Ue = ie || re || Qw(me), bt = !z && !le;
    if (Y) {
      if (bt) {
        let Ft = bu(se);
        yt(
          {
            navigation: me,
            ...Ft !== void 0 ? { actionData: Ft } : {}
          },
          {
            flushSync: ue
          }
        );
      }
      let Re = await Eu(
        j,
        L.pathname,
        C.signal
      );
      if (Re.type === "aborted")
        return { shortCircuited: !0 };
      if (Re.type === "error") {
        if (Re.partialMatches.length === 0) {
          let { matches: po, route: vi } = Qu(s);
          return {
            matches: po,
            loaderData: {},
            errors: {
              [vi.id]: Re.error
            }
          };
        }
        let Ft = Sa(Re.partialMatches).route.id;
        return {
          matches: Re.partialMatches,
          loaderData: {},
          errors: {
            [Ft]: Re.error
          }
        };
      } else if (Re.matches)
        j = Re.matches;
      else {
        let { error: Ft, notFoundMatches: po, route: vi } = Ch(
          L.pathname
        );
        return {
          matches: po,
          loaderData: {},
          errors: {
            [vi.id]: Ft
          }
        };
      }
    }
    let Ct = l || s, { dsMatches: Ve, revalidatingFetchers: Qe } = Mw(
      C,
      $,
      i,
      o,
      e.history,
      E,
      j,
      Ue,
      L,
      le ? [] : r,
      le === !0,
      Q,
      k,
      ee,
      I,
      Z,
      Ct,
      c,
      e.patchRoutesOnNavigation != null,
      se
    );
    if (H = ++F, !e.dataStrategy && !Ve.some((Re) => Re.shouldLoad) && !Ve.some(
      (Re) => Re.route.middleware && Re.route.middleware.length > 0
    ) && Qe.length === 0) {
      let Re = Mb();
      return br(
        L,
        {
          matches: j,
          loaderData: {},
          // Commit pending error if we're short circuiting
          errors: se && un(se[1]) ? { [se[0]]: se[1].error } : null,
          ...Bw(se),
          ...Re ? { fetchers: new Map(E.fetchers) } : {}
        },
        { flushSync: ue }
      ), { shortCircuited: !0 };
    }
    if (bt) {
      let Re = {};
      if (!Y) {
        Re.navigation = me;
        let Ft = bu(se);
        Ft !== void 0 && (Re.actionData = Ft);
      }
      Qe.length > 0 && (Re.fetchers = ho(Qe)), yt(Re, { flushSync: ue });
    }
    Qe.forEach((Re) => {
      Sr(Re.key), Re.controller && P.set(Re.key, Re.controller);
    });
    let mi = () => Qe.forEach((Re) => Sr(Re.key));
    A && A.signal.addEventListener(
      "abort",
      mi
    );
    let { loaderResults: cl, fetcherResults: aa } = await Db(
      Ve,
      Qe,
      C,
      $
    );
    if (C.signal.aborted)
      return { shortCircuited: !0 };
    A && A.signal.removeEventListener(
      "abort",
      mi
    ), Qe.forEach((Re) => P.delete(Re.key));
    let Xn = Hu(cl);
    if (Xn)
      return await pi(C, Xn.result, !0, {
        replace: oe
      }), { shortCircuited: !0 };
    if (Xn = Hu(aa), Xn)
      return Z.add(Xn.key), await pi(C, Xn.result, !0, {
        replace: oe
      }), { shortCircuited: !0 };
    let { loaderData: Oh, errors: ul } = Uw(
      E,
      j,
      cl,
      se,
      Qe,
      aa
    );
    le && E.errors && (ul = { ...E.errors, ...ul });
    let gi = Mb(), Su = Lb(H), Tu = gi || Su || Qe.length > 0;
    return {
      matches: j,
      loaderData: Oh,
      errors: ul,
      ...Tu ? { fetchers: new Map(E.fetchers) } : {}
    };
  }
  function bu(C) {
    if (C && !un(C[1]))
      return {
        [C[0]]: C[1].data
      };
    if (E.actionData)
      return Object.keys(E.actionData).length === 0 ? null : E.actionData;
  }
  function ho(C) {
    return C.forEach((L) => {
      let j = E.fetchers.get(L.key), $ = bl(
        void 0,
        j ? j.data : void 0
      );
      E.fetchers.set(L.key, $);
    }), new Map(E.fetchers);
  }
  async function mD(C, L, j, $) {
    Sr(C);
    let Y = ($ && $.flushSync) === !0, ae = l || s, ie = pg(
      E.location,
      E.matches,
      c,
      j,
      L,
      $ == null ? void 0 : $.relative
    ), re = Ea(ae, ie, c), oe = xu(re, ae, ie);
    if (oe.active && oe.matches && (re = oe.matches), !re) {
      Er(
        C,
        L,
        Tn(404, { pathname: ie }),
        { flushSync: Y }
      );
      return;
    }
    let { path: le, submission: ue, error: se } = kw(
      !0,
      ie,
      $
    );
    if (se) {
      Er(C, L, se, { flushSync: Y });
      return;
    }
    let me = e.getContext ? await e.getContext() : new Ow(), Ue = ($ && $.preventScrollReset) === !0;
    if (ue && Ht(ue.formMethod)) {
      await gD(
        C,
        L,
        le,
        re,
        me,
        oe.active,
        Y,
        Ue,
        ue
      );
      return;
    }
    I.set(C, { routeId: L, path: le }), await vD(
      C,
      L,
      le,
      re,
      me,
      oe.active,
      Y,
      Ue,
      ue
    );
  }
  async function gD(C, L, j, $, Y, ae, ie, re, oe) {
    Sh(), I.delete(C);
    let le = E.fetchers.get(C);
    xr(C, dL(oe, le), {
      flushSync: ie
    });
    let ue = new AbortController(), se = Ao(
      e.history,
      j,
      ue.signal,
      oe
    );
    if (ae) {
      let et = await Eu(
        $,
        new URL(se.url).pathname,
        se.signal,
        C
      );
      if (et.type === "aborted")
        return;
      if (et.type === "error") {
        Er(C, L, et.error, { flushSync: ie });
        return;
      } else if (et.matches)
        $ = et.matches;
      else {
        Er(
          C,
          L,
          Tn(404, { pathname: j }),
          { flushSync: ie }
        );
        return;
      }
    }
    let me = xf($, j);
    if (!me.route.action && !me.route.lazy) {
      let et = Tn(405, {
        method: oe.formMethod,
        pathname: j,
        routeId: L
      });
      Er(C, L, et, { flushSync: ie });
      return;
    }
    P.set(C, ue);
    let Ue = F, bt = rs(
      i,
      o,
      se,
      $,
      me,
      r,
      Y
    ), Ct = await ll(
      se,
      bt,
      Y,
      C
    ), Ve = Ct[me.route.id];
    if (!Ve) {
      for (let et of bt)
        if (Ct[et.route.id]) {
          Ve = Ct[et.route.id];
          break;
        }
    }
    if (se.signal.aborted) {
      P.get(C) === ue && P.delete(C);
      return;
    }
    if (ee.has(C)) {
      if (Ri(Ve) || un(Ve)) {
        xr(C, kr(void 0));
        return;
      }
    } else {
      if (Ri(Ve))
        if (P.delete(C), H > Ue) {
          xr(C, kr(void 0));
          return;
        } else
          return Z.add(C), xr(C, bl(oe)), pi(se, Ve, !1, {
            fetcherSubmission: oe,
            preventScrollReset: re
          });
      if (un(Ve)) {
        Er(C, L, Ve.error);
        return;
      }
    }
    let Qe = E.navigation.location || E.location, mi = Ao(
      e.history,
      Qe,
      ue.signal
    ), cl = l || s, aa = E.navigation.state !== "idle" ? Ea(cl, E.navigation.location, c) : E.matches;
    be(aa, "Didn't find any matches after fetcher action");
    let Xn = ++F;
    K.set(C, Xn);
    let Oh = bl(oe, Ve.data);
    E.fetchers.set(C, Oh);
    let { dsMatches: ul, revalidatingFetchers: gi } = Mw(
      mi,
      Y,
      i,
      o,
      e.history,
      E,
      aa,
      oe,
      Qe,
      r,
      !1,
      Q,
      k,
      ee,
      I,
      Z,
      cl,
      c,
      e.patchRoutesOnNavigation != null,
      [me.route.id, Ve]
    );
    gi.filter((et) => et.key !== C).forEach((et) => {
      let Cu = et.key, Ub = E.fetchers.get(Cu), CD = bl(
        void 0,
        Ub ? Ub.data : void 0
      );
      E.fetchers.set(Cu, CD), Sr(Cu), et.controller && P.set(Cu, et.controller);
    }), yt({ fetchers: new Map(E.fetchers) });
    let Su = () => gi.forEach((et) => Sr(et.key));
    ue.signal.addEventListener(
      "abort",
      Su
    );
    let { loaderResults: Tu, fetcherResults: Re } = await Db(
      ul,
      gi,
      mi,
      Y
    );
    if (ue.signal.aborted)
      return;
    if (ue.signal.removeEventListener(
      "abort",
      Su
    ), K.delete(C), P.delete(C), gi.forEach((et) => P.delete(et.key)), E.fetchers.has(C)) {
      let et = kr(Ve.data);
      E.fetchers.set(C, et);
    }
    let Ft = Hu(Tu);
    if (Ft)
      return pi(
        mi,
        Ft.result,
        !1,
        { preventScrollReset: re }
      );
    if (Ft = Hu(Re), Ft)
      return Z.add(Ft.key), pi(
        mi,
        Ft.result,
        !1,
        { preventScrollReset: re }
      );
    let { loaderData: po, errors: vi } = Uw(
      E,
      aa,
      Tu,
      void 0,
      gi,
      Re
    );
    Lb(Xn), E.navigation.state === "loading" && Xn > H ? (be(O, "Expected pending action"), A && A.abort(), br(E.navigation.location, {
      matches: aa,
      loaderData: po,
      errors: vi,
      fetchers: new Map(E.fetchers)
    })) : (yt({
      errors: vi,
      loaderData: qw(
        E.loaderData,
        po,
        aa,
        vi
      ),
      fetchers: new Map(E.fetchers)
    }), Q = !1);
  }
  async function vD(C, L, j, $, Y, ae, ie, re, oe) {
    let le = E.fetchers.get(C);
    xr(
      C,
      bl(
        oe,
        le ? le.data : void 0
      ),
      { flushSync: ie }
    );
    let ue = new AbortController(), se = Ao(
      e.history,
      j,
      ue.signal
    );
    if (ae) {
      let Qe = await Eu(
        $,
        new URL(se.url).pathname,
        se.signal,
        C
      );
      if (Qe.type === "aborted")
        return;
      if (Qe.type === "error") {
        Er(C, L, Qe.error, { flushSync: ie });
        return;
      } else if (Qe.matches)
        $ = Qe.matches;
      else {
        Er(
          C,
          L,
          Tn(404, { pathname: j }),
          { flushSync: ie }
        );
        return;
      }
    }
    let me = xf($, j);
    P.set(C, ue);
    let Ue = F, bt = rs(
      i,
      o,
      se,
      $,
      me,
      r,
      Y
    ), Ve = (await ll(
      se,
      bt,
      Y,
      C
    ))[me.route.id];
    if (P.get(C) === ue && P.delete(C), !se.signal.aborted) {
      if (ee.has(C)) {
        xr(C, kr(void 0));
        return;
      }
      if (Ri(Ve))
        if (H > Ue) {
          xr(C, kr(void 0));
          return;
        } else {
          Z.add(C), await pi(se, Ve, !1, {
            preventScrollReset: re
          });
          return;
        }
      if (un(Ve)) {
        Er(C, L, Ve.error);
        return;
      }
      xr(C, kr(Ve.data));
    }
  }
  async function pi(C, L, j, {
    submission: $,
    fetcherSubmission: Y,
    preventScrollReset: ae,
    replace: ie
  } = {}) {
    L.response.headers.has("X-Remix-Revalidate") && (Q = !0);
    let re = L.response.headers.get("Location");
    be(re, "Expected a Location header on the redirect Response"), re = Iw(
      re,
      new URL(C.url),
      c
    );
    let oe = dg(E.location, re, {
      _isRedirect: !0
    });
    if (n) {
      let bt = !1;
      if (L.response.headers.has("X-Remix-Reload-Document"))
        bt = !0;
      else if (Kd(re)) {
        const Ct = c2(re, !0);
        bt = // Hard reload if it's an absolute URL to a new origin
        Ct.origin !== t.location.origin || // Hard reload if it's an absolute URL that does not match our basename
        jn(Ct.pathname, c) == null;
      }
      if (bt) {
        ie ? t.location.replace(re) : t.location.assign(re);
        return;
      }
    }
    A = null;
    let le = ie === !0 || L.response.headers.has("X-Remix-Replace") ? "REPLACE" : "PUSH", { formMethod: ue, formAction: se, formEncType: me } = E.navigation;
    !$ && !Y && ue && se && me && ($ = Qw(E.navigation));
    let Ue = $ || Y;
    if (Q2.has(L.response.status) && Ue && Ht(Ue.formMethod))
      await wr(le, oe, {
        submission: {
          ...Ue,
          formAction: re
        },
        // Preserve these flags across redirects
        preventScrollReset: ae || D,
        enableViewTransition: j ? U : void 0
      });
    else {
      let bt = pp(
        oe,
        $
      );
      await wr(le, oe, {
        overrideNavigation: bt,
        // Send fetcher submissions through for shouldRevalidate
        fetcherSubmission: Y,
        // Preserve these flags across redirects
        preventScrollReset: ae || D,
        enableViewTransition: j ? U : void 0
      });
    }
  }
  async function ll(C, L, j, $) {
    let Y, ae = {};
    try {
      Y = await eL(
        u,
        C,
        L,
        $,
        j,
        !1
      );
    } catch (ie) {
      return L.filter((re) => re.shouldLoad).forEach((re) => {
        ae[re.route.id] = {
          type: "error",
          error: ie
        };
      }), ae;
    }
    if (C.signal.aborted)
      return ae;
    for (let [ie, re] of Object.entries(Y))
      if (cL(re)) {
        let oe = re.result;
        ae[ie] = {
          type: "redirect",
          response: aL(
            oe,
            C,
            ie,
            L,
            c
          )
        };
      } else
        ae[ie] = await rL(re);
    return ae;
  }
  async function Db(C, L, j, $) {
    let Y = ll(
      j,
      C,
      $,
      null
    ), ae = Promise.all(
      L.map(async (oe) => {
        if (oe.matches && oe.match && oe.request && oe.controller) {
          let ue = (await ll(
            oe.request,
            oe.matches,
            $,
            oe.key
          ))[oe.match.route.id];
          return { [oe.key]: ue };
        } else
          return Promise.resolve({
            [oe.key]: {
              type: "error",
              error: Tn(404, {
                pathname: oe.path
              })
            }
          });
      })
    ), ie = await Y, re = (await ae).reduce(
      (oe, le) => Object.assign(oe, le),
      {}
    );
    return {
      loaderResults: ie,
      fetcherResults: re
    };
  }
  function Sh() {
    Q = !0, I.forEach((C, L) => {
      P.has(L) && k.add(L), Sr(L);
    });
  }
  function xr(C, L, j = {}) {
    E.fetchers.set(C, L), yt(
      { fetchers: new Map(E.fetchers) },
      { flushSync: (j && j.flushSync) === !0 }
    );
  }
  function Er(C, L, j, $ = {}) {
    let Y = Sa(E.matches, L);
    Th(C), yt(
      {
        errors: {
          [Y.route.id]: j
        },
        fetchers: new Map(E.fetchers)
      },
      { flushSync: ($ && $.flushSync) === !0 }
    );
  }
  function Nb(C) {
    return G.set(C, (G.get(C) || 0) + 1), ee.has(C) && ee.delete(C), E.fetchers.get(C) || H2;
  }
  function yD(C, L) {
    Sr(C, L == null ? void 0 : L.reason), xr(C, kr(null));
  }
  function Th(C) {
    let L = E.fetchers.get(C);
    P.has(C) && !(L && L.state === "loading" && K.has(C)) && Sr(C), I.delete(C), K.delete(C), Z.delete(C), ee.delete(C), k.delete(C), E.fetchers.delete(C);
  }
  function bD(C) {
    let L = (G.get(C) || 0) - 1;
    L <= 0 ? (G.delete(C), ee.add(C)) : G.set(C, L), yt({ fetchers: new Map(E.fetchers) });
  }
  function Sr(C, L) {
    let j = P.get(C);
    j && (j.abort(L), P.delete(C));
  }
  function kb(C) {
    for (let L of C) {
      let j = Nb(L), $ = kr(j.data);
      E.fetchers.set(L, $);
    }
  }
  function Mb() {
    let C = [], L = !1;
    for (let j of Z) {
      let $ = E.fetchers.get(j);
      be($, `Expected fetcher: ${j}`), $.state === "loading" && (Z.delete(j), C.push(j), L = !0);
    }
    return kb(C), L;
  }
  function Lb(C) {
    let L = [];
    for (let [j, $] of K)
      if ($ < C) {
        let Y = E.fetchers.get(j);
        be(Y, `Expected fetcher: ${j}`), Y.state === "loading" && (Sr(j), K.delete(j), L.push(j));
      }
    return kb(L), L.length > 0;
  }
  function wD(C, L) {
    let j = E.blockers.get(C) || yl;
    return J.get(C) !== L && J.set(C, L), j;
  }
  function zb(C) {
    E.blockers.delete(C), J.delete(C);
  }
  function wu(C, L) {
    let j = E.blockers.get(C) || yl;
    be(
      j.state === "unblocked" && L.state === "blocked" || j.state === "blocked" && L.state === "blocked" || j.state === "blocked" && L.state === "proceeding" || j.state === "blocked" && L.state === "unblocked" || j.state === "proceeding" && L.state === "unblocked",
      `Invalid blocker state transition: ${j.state} -> ${L.state}`
    );
    let $ = new Map(E.blockers);
    $.set(C, L), yt({ blockers: $ });
  }
  function jb({
    currentLocation: C,
    nextLocation: L,
    historyAction: j
  }) {
    if (J.size === 0)
      return;
    J.size > 1 && Je(!1, "A router only supports one blocker at a time");
    let $ = Array.from(J.entries()), [Y, ae] = $[$.length - 1], ie = E.blockers.get(Y);
    if (!(ie && ie.state === "proceeding") && ae({ currentLocation: C, nextLocation: L, historyAction: j }))
      return Y;
  }
  function Ch(C) {
    let L = Tn(404, { pathname: C }), j = l || s, { matches: $, route: Y } = Qu(j);
    return { notFoundMatches: $, route: Y, error: L };
  }
  function xD(C, L, j) {
    if (g = C, b = L, v = j || null, !p && E.navigation === hp) {
      p = !0;
      let $ = Ib(E.location, E.matches);
      $ != null && yt({ restoreScrollPosition: $ });
    }
    return () => {
      g = null, b = null, v = null;
    };
  }
  function Pb(C, L) {
    return v && v(
      C,
      L.map(($) => m2($, E.loaderData))
    ) || C.key;
  }
  function ED(C, L) {
    if (g && b) {
      let j = Pb(C, L);
      g[j] = b();
    }
  }
  function Ib(C, L) {
    if (g) {
      let j = Pb(C, L), $ = g[j];
      if (typeof $ == "number")
        return $;
    }
    return null;
  }
  function xu(C, L, j) {
    if (e.patchRoutesOnNavigation)
      if (C) {
        if (Object.keys(C[0].params).length > 0)
          return { active: !0, matches: Fl(
            L,
            j,
            c,
            !0
          ) };
      } else
        return { active: !0, matches: Fl(
          L,
          j,
          c,
          !0
        ) || [] };
    return { active: !1, matches: null };
  }
  async function Eu(C, L, j, $) {
    if (!e.patchRoutesOnNavigation)
      return { type: "success", matches: C };
    let Y = C;
    for (; ; ) {
      let ae = l == null, ie = l || s, re = o;
      try {
        await e.patchRoutesOnNavigation({
          signal: j,
          path: L,
          matches: Y,
          fetcherKey: $,
          patch: (ue, se) => {
            j.aborted || Lw(
              ue,
              se,
              ie,
              re,
              i,
              !1
            );
          }
        });
      } catch (ue) {
        return { type: "error", error: ue, partialMatches: Y };
      } finally {
        ae && !j.aborted && (s = [...s]);
      }
      if (j.aborted)
        return { type: "aborted" };
      let oe = Ea(ie, L, c), le = null;
      if (oe) {
        if (Object.keys(oe[0].params).length === 0)
          return { type: "success", matches: oe };
        if (le = Fl(
          ie,
          L,
          c,
          !0
        ), !(le && Y.length < le.length && Fb(
          Y,
          le.slice(0, Y.length)
        )))
          return { type: "success", matches: oe };
      }
      if (le || (le = Fl(
        ie,
        L,
        c,
        !0
      )), !le || Fb(Y, le))
        return { type: "success", matches: null };
      Y = le;
    }
  }
  function Fb(C, L) {
    return C.length === L.length && C.every((j, $) => j.route.id === L[$].route.id);
  }
  function SD(C) {
    o = {}, l = Ac(
      C,
      i,
      void 0,
      o
    );
  }
  function TD(C, L, j = !1) {
    let $ = l == null;
    Lw(
      C,
      L,
      l || s,
      o,
      i,
      j
    ), $ && (s = [...s], yt({}));
  }
  return T = {
    get basename() {
      return c;
    },
    get future() {
      return f;
    },
    get state() {
      return E;
    },
    get routes() {
      return s;
    },
    get window() {
      return t;
    },
    initialize: Tt,
    subscribe: yr,
    enableScrollRestoration: xD,
    navigate: ra,
    fetch: mD,
    revalidate: yu,
    // Passthrough to history-aware createHref used by useHref so we get proper
    // hash-aware URLs in DOM paths
    createHref: (C) => e.history.createHref(C),
    encodeLocation: (C) => e.history.encodeLocation(C),
    getFetcher: Nb,
    resetFetcher: yD,
    deleteFetcher: bD,
    dispose: ft,
    getBlocker: wD,
    deleteBlocker: zb,
    patchRoutes: TD,
    _internalFetchControllers: P,
    // TODO: Remove setRoutes, it's temporary to avoid dealing with
    // updating the tree while validating the update algorithm.
    _internalSetRoutes: SD,
    _internalSetStateDoNotUseOrYouWillBreakYourApp(C) {
      yt(C);
    }
  }, e.unstable_instrumentations && (T = z2(
    T,
    e.unstable_instrumentations.map((C) => C.router).filter(Boolean)
  )), T;
}
function Y2(e) {
  return e != null && ("formData" in e && e.formData != null || "body" in e && e.body !== void 0);
}
function pg(e, t, n, r, a, i) {
  let o, s;
  if (a) {
    o = [];
    for (let c of t)
      if (o.push(c), c.route.id === a) {
        s = c;
        break;
      }
  } else
    o = t, s = t[t.length - 1];
  let l = Cy(
    r || ".",
    Ty(o),
    jn(e.pathname, n) || e.pathname,
    i === "path"
  );
  if (r == null && (l.search = e.search, l.hash = e.hash), (r == null || r === "" || r === ".") && s) {
    let c = Ry(l.search);
    if (s.route.index && !c)
      l.search = l.search ? l.search.replace(/^\?/, "?index&") : "?index";
    else if (!s.route.index && c) {
      let u = new URLSearchParams(l.search), f = u.getAll("index");
      u.delete("index"), f.filter((h) => h).forEach((h) => u.append("index", h));
      let d = u.toString();
      l.search = d ? `?${d}` : "";
    }
  }
  return n !== "/" && (l.pathname = R2({ basename: n, pathname: l.pathname })), cr(l);
}
function kw(e, t, n) {
  if (!n || !Y2(n))
    return { path: t };
  if (n.formMethod && !uL(n.formMethod))
    return {
      path: t,
      error: Tn(405, { method: n.formMethod })
    };
  let r = () => ({
    path: t,
    error: Tn(400, { type: "invalid-body" })
  }), i = (n.formMethod || "get").toUpperCase(), o = YO(t);
  if (n.body !== void 0) {
    if (n.formEncType === "text/plain") {
      if (!Ht(i))
        return r();
      let f = typeof n.body == "string" ? n.body : n.body instanceof FormData || n.body instanceof URLSearchParams ? (
        // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data
        Array.from(n.body.entries()).reduce(
          (d, [h, g]) => `${d}${h}=${g}
`,
          ""
        )
      ) : String(n.body);
      return {
        path: t,
        submission: {
          formMethod: i,
          formAction: o,
          formEncType: n.formEncType,
          formData: void 0,
          json: void 0,
          text: f
        }
      };
    } else if (n.formEncType === "application/json") {
      if (!Ht(i))
        return r();
      try {
        let f = typeof n.body == "string" ? JSON.parse(n.body) : n.body;
        return {
          path: t,
          submission: {
            formMethod: i,
            formAction: o,
            formEncType: n.formEncType,
            formData: void 0,
            json: f,
            text: void 0
          }
        };
      } catch {
        return r();
      }
    }
  }
  be(
    typeof FormData == "function",
    "FormData is not available in this environment"
  );
  let s, l;
  if (n.formData)
    s = vg(n.formData), l = n.formData;
  else if (n.body instanceof FormData)
    s = vg(n.body), l = n.body;
  else if (n.body instanceof URLSearchParams)
    s = n.body, l = Fw(s);
  else if (n.body == null)
    s = new URLSearchParams(), l = new FormData();
  else
    try {
      s = new URLSearchParams(n.body), l = Fw(s);
    } catch {
      return r();
    }
  let c = {
    formMethod: i,
    formAction: o,
    formEncType: n && n.formEncType || "application/x-www-form-urlencoded",
    formData: l,
    json: void 0,
    text: void 0
  };
  if (Ht(c.formMethod))
    return { path: t, submission: c };
  let u = ta(t);
  return e && u.search && Ry(u.search) && s.append("index", ""), u.search = `?${s}`, { path: cr(u), submission: c };
}
function Mw(e, t, n, r, a, i, o, s, l, c, u, f, d, h, g, v, b, p, m, w) {
  var z;
  let x = w ? un(w[1]) ? w[1].error : w[1].data : void 0, S = a.createURL(i.location), T = a.createURL(l), E;
  if (u && i.errors) {
    let Q = Object.keys(i.errors)[0];
    E = o.findIndex((k) => k.route.id === Q);
  } else if (w && un(w[1])) {
    let Q = w[0];
    E = o.findIndex((k) => k.route.id === Q) - 1;
  }
  let O = w ? w[1].statusCode : void 0, D = O && O >= 400, A = {
    currentUrl: S,
    currentParams: ((z = i.matches[0]) == null ? void 0 : z.params) || {},
    nextUrl: T,
    nextParams: o[0].params,
    ...s,
    actionResult: x,
    actionStatus: O
  }, U = Oy(o.map((Q) => Q.route.path)), R = o.map((Q, k) => {
    let { route: P } = Q, F = null;
    if (E != null && k > E ? F = !1 : P.lazy ? F = !0 : Ay(P) ? u ? F = mg(
      P,
      i.loaderData,
      i.errors
    ) : K2(i.loaderData, i.matches[k], Q) && (F = !0) : F = !1, F !== null)
      return gg(
        n,
        r,
        e,
        U,
        Q,
        c,
        t,
        F
      );
    let H = D ? !1 : (
      // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate
      f || S.pathname + S.search === T.pathname + T.search || // Search params affect all loaders
      S.search !== T.search || X2(i.matches[k], Q)
    ), K = {
      ...A,
      defaultShouldRevalidate: H
    }, Z = dd(Q, K);
    return gg(
      n,
      r,
      e,
      U,
      Q,
      c,
      t,
      Z,
      K
    );
  }), q = [];
  return g.forEach((Q, k) => {
    if (u || !o.some((ee) => ee.route.id === Q.routeId) || h.has(k))
      return;
    let P = i.fetchers.get(k), F = P && P.state !== "idle" && P.data === void 0, H = Ea(b, Q.path, p);
    if (!H) {
      if (m && F)
        return;
      q.push({
        key: k,
        routeId: Q.routeId,
        path: Q.path,
        matches: null,
        match: null,
        request: null,
        controller: null
      });
      return;
    }
    if (v.has(k))
      return;
    let K = xf(H, Q.path), Z = new AbortController(), I = Ao(
      a,
      Q.path,
      Z.signal
    ), G = null;
    if (d.has(k))
      d.delete(k), G = rs(
        n,
        r,
        I,
        H,
        K,
        c,
        t
      );
    else if (F)
      f && (G = rs(
        n,
        r,
        I,
        H,
        K,
        c,
        t
      ));
    else {
      let ee = {
        ...A,
        defaultShouldRevalidate: D ? !1 : f
      };
      dd(K, ee) && (G = rs(
        n,
        r,
        I,
        H,
        K,
        c,
        t,
        ee
      ));
    }
    G && q.push({
      key: k,
      routeId: Q.routeId,
      path: Q.path,
      matches: G,
      match: K,
      request: I,
      controller: Z
    });
  }), { dsMatches: R, revalidatingFetchers: q };
}
function Ay(e) {
  return e.loader != null || e.middleware != null && e.middleware.length > 0;
}
function mg(e, t, n) {
  if (e.lazy)
    return !0;
  if (!Ay(e))
    return !1;
  let r = t != null && e.id in t, a = n != null && n[e.id] !== void 0;
  return !r && a ? !1 : typeof e.loader == "function" && e.loader.hydrate === !0 ? !0 : !r && !a;
}
function K2(e, t, n) {
  let r = (
    // [a] -> [a, b]
    !t || // [a, b] -> [a, c]
    n.route.id !== t.route.id
  ), a = !e.hasOwnProperty(n.route.id);
  return r || a;
}
function X2(e, t) {
  let n = e.route.path;
  return (
    // param change for this match, /users/123 -> /users/456
    e.pathname !== t.pathname || // splat param changed, which is not present in match.path
    // e.g. /files/images/avatar.jpg -> files/finances.xls
    n != null && n.endsWith("*") && e.params["*"] !== t.params["*"]
  );
}
function dd(e, t) {
  if (e.route.shouldRevalidate) {
    let n = e.route.shouldRevalidate(t);
    if (typeof n == "boolean")
      return n;
  }
  return t.defaultShouldRevalidate;
}
function Lw(e, t, n, r, a, i) {
  let o;
  if (e) {
    let c = r[e];
    be(
      c,
      `No route found to patch children into: routeId = ${e}`
    ), c.children || (c.children = []), o = c.children;
  } else
    o = n;
  let s = [], l = [];
  if (t.forEach((c) => {
    let u = o.find(
      (f) => VO(c, f)
    );
    u ? l.push({ existingRoute: u, newRoute: c }) : s.push(c);
  }), s.length > 0) {
    let c = Ac(
      s,
      a,
      [e || "_", "patch", String((o == null ? void 0 : o.length) || "0")],
      r
    );
    o.push(...c);
  }
  if (i && l.length > 0)
    for (let c = 0; c < l.length; c++) {
      let { existingRoute: u, newRoute: f } = l[c], d = u, [h] = Ac(
        [f],
        a,
        [],
        // Doesn't matter for mutated routes since they already have an id
        {},
        // Don't touch the manifest here since we're updating in place
        !0
      );
      Object.assign(d, {
        element: h.element ? h.element : d.element,
        errorElement: h.errorElement ? h.errorElement : d.errorElement,
        hydrateFallbackElement: h.hydrateFallbackElement ? h.hydrateFallbackElement : d.hydrateFallbackElement
      });
    }
}
function VO(e, t) {
  return "id" in e && "id" in t && e.id === t.id ? !0 : e.index === t.index && e.path === t.path && e.caseSensitive === t.caseSensitive ? (!e.children || e.children.length === 0) && (!t.children || t.children.length === 0) ? !0 : e.children.every(
    (n, r) => {
      var a;
      return (a = t.children) == null ? void 0 : a.some((i) => VO(n, i));
    }
  ) : !1;
}
var zw = /* @__PURE__ */ new WeakMap(), QO = ({
  key: e,
  route: t,
  manifest: n,
  mapRouteProperties: r
}) => {
  let a = n[t.id];
  if (be(a, "No route found in manifest"), !a.lazy || typeof a.lazy != "object")
    return;
  let i = a.lazy[e];
  if (!i)
    return;
  let o = zw.get(a);
  o || (o = {}, zw.set(a, o));
  let s = o[e];
  if (s)
    return s;
  let l = (async () => {
    let c = f2(e), f = a[e] !== void 0 && e !== "hasErrorBoundary";
    if (c)
      Je(
        !c,
        "Route property " + e + " is not a supported lazy route property. This property will be ignored."
      ), o[e] = Promise.resolve();
    else if (f)
      Je(
        !1,
        `Route "${a.id}" has a static property "${e}" defined. The lazy property will be ignored.`
      );
    else {
      let d = await i();
      d != null && (Object.assign(a, { [e]: d }), Object.assign(a, r(a)));
    }
    typeof a.lazy == "object" && (a.lazy[e] = void 0, Object.values(a.lazy).every((d) => d === void 0) && (a.lazy = void 0));
  })();
  return o[e] = l, l;
}, jw = /* @__PURE__ */ new WeakMap();
function W2(e, t, n, r, a) {
  let i = n[e.id];
  if (be(i, "No route found in manifest"), !e.lazy)
    return {
      lazyRoutePromise: void 0,
      lazyHandlerPromise: void 0
    };
  if (typeof e.lazy == "function") {
    let u = jw.get(i);
    if (u)
      return {
        lazyRoutePromise: u,
        lazyHandlerPromise: u
      };
    let f = (async () => {
      be(
        typeof e.lazy == "function",
        "No lazy route function found"
      );
      let d = await e.lazy(), h = {};
      for (let g in d) {
        let v = d[g];
        if (v === void 0)
          continue;
        let b = h2(g), m = i[g] !== void 0 && // This property isn't static since it should always be updated based
        // on the route updates
        g !== "hasErrorBoundary";
        b ? Je(
          !b,
          "Route property " + g + " is not a supported property to be returned from a lazy route function. This property will be ignored."
        ) : m ? Je(
          !m,
          `Route "${i.id}" has a static property "${g}" defined but its lazy function is also returning a value for this property. The lazy route property "${g}" will be ignored.`
        ) : h[g] = v;
      }
      Object.assign(i, h), Object.assign(i, {
        // To keep things framework agnostic, we use the provided `mapRouteProperties`
        // function to set the framework-aware properties (`element`/`hasErrorBoundary`)
        // since the logic will differ between frameworks.
        ...r(i),
        lazy: void 0
      });
    })();
    return jw.set(i, f), f.catch(() => {
    }), {
      lazyRoutePromise: f,
      lazyHandlerPromise: f
    };
  }
  let o = Object.keys(e.lazy), s = [], l;
  for (let u of o) {
    if (a && a.includes(u))
      continue;
    let f = QO({
      key: u,
      route: e,
      manifest: n,
      mapRouteProperties: r
    });
    f && (s.push(f), u === t && (l = f));
  }
  let c = s.length > 0 ? Promise.all(s).then(() => {
  }) : void 0;
  return c == null || c.catch(() => {
  }), l == null || l.catch(() => {
  }), {
    lazyRoutePromise: c,
    lazyHandlerPromise: l
  };
}
async function Pw(e) {
  let t = e.matches.filter((a) => a.shouldLoad), n = {};
  return (await Promise.all(t.map((a) => a.resolve()))).forEach((a, i) => {
    n[t[i].route.id] = a;
  }), n;
}
async function Z2(e) {
  return e.matches.some((t) => t.route.middleware) ? HO(e, () => Pw(e)) : Pw(e);
}
function HO(e, t) {
  return J2(
    e,
    t,
    (r) => r,
    // No post-processing needed on the client
    sL,
    n
  );
  function n(r, a, i) {
    if (i)
      return Promise.resolve(
        Object.assign(i.value, {
          [a]: { type: "error", result: r }
        })
      );
    {
      let { matches: o } = e, s = Math.min(
        // Throwing route
        Math.max(
          o.findIndex((c) => c.route.id === a),
          0
        ),
        // or the shallowest route that needs to load data
        Math.max(
          o.findIndex((c) => c.unstable_shouldCallHandler()),
          0
        )
      ), l = Sa(
        o,
        o[s].route.id
      ).route.id;
      return Promise.resolve({
        [l]: { type: "error", result: r }
      });
    }
  }
}
async function J2(e, t, n, r, a) {
  let { matches: i, request: o, params: s, context: l, unstable_pattern: c } = e, u = i.flatMap(
    (d) => d.route.middleware ? d.route.middleware.map((h) => [d.route.id, h]) : []
  );
  return await $O(
    {
      request: o,
      params: s,
      context: l,
      unstable_pattern: c
    },
    u,
    t,
    n,
    r,
    a
  );
}
async function $O(e, t, n, r, a, i, o = 0) {
  let { request: s } = e;
  if (s.signal.aborted)
    throw s.signal.reason ?? new Error(`Request aborted: ${s.method} ${s.url}`);
  let l = t[o];
  if (!l)
    return await n();
  let [c, u] = l, f, d = async () => {
    if (f)
      throw new Error("You may only call `next()` once per middleware");
    try {
      return f = { value: await $O(
        e,
        t,
        n,
        r,
        a,
        i,
        o + 1
      ) }, f.value;
    } catch (h) {
      return f = { value: await i(h, c, f) }, f.value;
    }
  };
  try {
    let h = await u(e, d), g = h != null ? r(h) : void 0;
    return a(g) ? g : f ? g ?? f.value : (f = { value: await d() }, f.value);
  } catch (h) {
    return await i(h, c, f);
  }
}
function GO(e, t, n, r, a) {
  let i = QO({
    key: "middleware",
    route: r.route,
    manifest: t,
    mapRouteProperties: e
  }), o = W2(
    r.route,
    Ht(n.method) ? "action" : "loader",
    t,
    e,
    a
  );
  return {
    middleware: i,
    route: o.lazyRoutePromise,
    handler: o.lazyHandlerPromise
  };
}
function gg(e, t, n, r, a, i, o, s, l = null) {
  let c = !1, u = GO(
    e,
    t,
    n,
    a,
    i
  );
  return {
    ...a,
    _lazyPromises: u,
    shouldLoad: s,
    unstable_shouldRevalidateArgs: l,
    unstable_shouldCallHandler(f) {
      return c = !0, l ? typeof f == "boolean" ? dd(a, {
        ...l,
        defaultShouldRevalidate: f
      }) : dd(a, l) : s;
    },
    resolve(f) {
      let { lazy: d, loader: h, middleware: g } = a.route, v = c || s || f && !Ht(n.method) && (d || h), b = g && g.length > 0 && !h && !d;
      return v && (Ht(n.method) || !b) ? tL({
        request: n,
        unstable_pattern: r,
        match: a,
        lazyHandlerPromise: u == null ? void 0 : u.handler,
        lazyRoutePromise: u == null ? void 0 : u.route,
        handlerOverride: f,
        scopedContext: o
      }) : Promise.resolve({ type: "data", result: void 0 });
    }
  };
}
function rs(e, t, n, r, a, i, o, s = null) {
  return r.map((l) => l.route.id !== a.route.id ? {
    ...l,
    shouldLoad: !1,
    unstable_shouldRevalidateArgs: s,
    unstable_shouldCallHandler: () => !1,
    _lazyPromises: GO(
      e,
      t,
      n,
      l,
      i
    ),
    resolve: () => Promise.resolve({ type: "data", result: void 0 })
  } : gg(
    e,
    t,
    n,
    Oy(r.map((c) => c.route.path)),
    l,
    i,
    o,
    !0,
    s
  ));
}
async function eL(e, t, n, r, a, i) {
  n.some((c) => {
    var u;
    return (u = c._lazyPromises) == null ? void 0 : u.middleware;
  }) && await Promise.all(n.map((c) => {
    var u;
    return (u = c._lazyPromises) == null ? void 0 : u.middleware;
  }));
  let o = {
    request: t,
    unstable_pattern: Oy(n.map((c) => c.route.path)),
    params: n[0].params,
    context: a,
    matches: n
  }, l = await e({
    ...o,
    fetcherKey: r,
    runClientMiddleware: (c) => {
      let u = o;
      return HO(u, () => c({
        ...u,
        fetcherKey: r,
        runClientMiddleware: () => {
          throw new Error(
            "Cannot call `runClientMiddleware()` from within an `runClientMiddleware` handler"
          );
        }
      }));
    }
  });
  try {
    await Promise.all(
      n.flatMap((c) => {
        var u, f;
        return [
          (u = c._lazyPromises) == null ? void 0 : u.handler,
          (f = c._lazyPromises) == null ? void 0 : f.route
        ];
      })
    );
  } catch {
  }
  return l;
}
async function tL({
  request: e,
  unstable_pattern: t,
  match: n,
  lazyHandlerPromise: r,
  lazyRoutePromise: a,
  handlerOverride: i,
  scopedContext: o
}) {
  let s, l, c = Ht(e.method), u = c ? "action" : "loader", f = (d) => {
    let h, g = new Promise((p, m) => h = m);
    l = () => h(), e.signal.addEventListener("abort", l);
    let v = (p) => typeof d != "function" ? Promise.reject(
      new Error(
        `You cannot call the handler for a route which defines a boolean "${u}" [routeId: ${n.route.id}]`
      )
    ) : d(
      {
        request: e,
        unstable_pattern: t,
        params: n.params,
        context: o
      },
      ...p !== void 0 ? [p] : []
    ), b = (async () => {
      try {
        return { type: "data", result: await (i ? i((m) => v(m)) : v()) };
      } catch (p) {
        return { type: "error", result: p };
      }
    })();
    return Promise.race([b, g]);
  };
  try {
    let d = c ? n.route.action : n.route.loader;
    if (r || a)
      if (d) {
        let h, [g] = await Promise.all([
          // If the handler throws, don't let it immediately bubble out,
          // since we need to let the lazy() execution finish so we know if this
          // route has a boundary that can handle the error
          f(d).catch((v) => {
            h = v;
          }),
          // Ensure all lazy route promises are resolved before continuing
          r,
          a
        ]);
        if (h !== void 0)
          throw h;
        s = g;
      } else {
        await r;
        let h = c ? n.route.action : n.route.loader;
        if (h)
          [s] = await Promise.all([f(h), a]);
        else if (u === "action") {
          let g = new URL(e.url), v = g.pathname + g.search;
          throw Tn(405, {
            method: e.method,
            pathname: v,
            routeId: n.route.id
          });
        } else
          return { type: "data", result: void 0 };
      }
    else if (d)
      s = await f(d);
    else {
      let h = new URL(e.url), g = h.pathname + h.search;
      throw Tn(404, {
        pathname: g
      });
    }
  } catch (d) {
    return { type: "error", result: d };
  } finally {
    l && e.signal.removeEventListener("abort", l);
  }
  return s;
}
async function nL(e) {
  let t = e.headers.get("Content-Type");
  return t && /\bapplication\/json\b/.test(t) ? e.body == null ? null : e.json() : e.text();
}
async function rL(e) {
  var r, a, i, o, s, l;
  let { result: t, type: n } = e;
  if (KO(t)) {
    let c;
    try {
      c = await nL(t);
    } catch (u) {
      return { type: "error", error: u };
    }
    return n === "error" ? {
      type: "error",
      error: new hg(t.status, t.statusText, c),
      statusCode: t.status,
      headers: t.headers
    } : {
      type: "data",
      data: c,
      statusCode: t.status,
      headers: t.headers
    };
  }
  return n === "error" ? Vw(t) ? t.data instanceof Error ? {
    type: "error",
    error: t.data,
    statusCode: (r = t.init) == null ? void 0 : r.status,
    headers: (a = t.init) != null && a.headers ? new Headers(t.init.headers) : void 0
  } : {
    type: "error",
    error: new hg(
      ((i = t.init) == null ? void 0 : i.status) || 500,
      void 0,
      t.data
    ),
    statusCode: Rc(t) ? t.status : void 0,
    headers: (o = t.init) != null && o.headers ? new Headers(t.init.headers) : void 0
  } : {
    type: "error",
    error: t,
    statusCode: Rc(t) ? t.status : void 0
  } : Vw(t) ? {
    type: "data",
    data: t.data,
    statusCode: (s = t.init) == null ? void 0 : s.status,
    headers: (l = t.init) != null && l.headers ? new Headers(t.init.headers) : void 0
  } : { type: "data", data: t };
}
function aL(e, t, n, r, a) {
  let i = e.headers.get("Location");
  if (be(
    i,
    "Redirects returned/thrown from loaders/actions must have a Location header"
  ), !Kd(i)) {
    let o = r.slice(
      0,
      r.findIndex((s) => s.route.id === n) + 1
    );
    i = pg(
      new URL(t.url),
      o,
      a,
      i
    ), e.headers.set("Location", i);
  }
  return e;
}
function Iw(e, t, n) {
  if (Kd(e)) {
    let r = e, a = r.startsWith("//") ? new URL(t.protocol + r) : new URL(r), i = jn(a.pathname, n) != null;
    if (a.origin === t.origin && i)
      return a.pathname + a.search + a.hash;
  }
  return e;
}
function Ao(e, t, n, r) {
  let a = e.createURL(YO(t)).toString(), i = { signal: n };
  if (r && Ht(r.formMethod)) {
    let { formMethod: o, formEncType: s } = r;
    i.method = o.toUpperCase(), s === "application/json" ? (i.headers = new Headers({ "Content-Type": s }), i.body = JSON.stringify(r.json)) : s === "text/plain" ? i.body = r.text : s === "application/x-www-form-urlencoded" && r.formData ? i.body = vg(r.formData) : i.body = r.formData;
  }
  return new Request(a, i);
}
function vg(e) {
  let t = new URLSearchParams();
  for (let [n, r] of e.entries())
    t.append(n, typeof r == "string" ? r : r.name);
  return t;
}
function Fw(e) {
  let t = new FormData();
  for (let [n, r] of e.entries())
    t.append(n, r);
  return t;
}
function iL(e, t, n, r = !1, a = !1) {
  let i = {}, o = null, s, l = !1, c = {}, u = n && un(n[1]) ? n[1].error : void 0;
  return e.forEach((f) => {
    if (!(f.route.id in t))
      return;
    let d = f.route.id, h = t[d];
    if (be(
      !Ri(h),
      "Cannot handle redirect results in processLoaderData"
    ), un(h)) {
      let g = h.error;
      if (u !== void 0 && (g = u, u = void 0), o = o || {}, a)
        o[d] = g;
      else {
        let v = Sa(e, d);
        o[v.route.id] == null && (o[v.route.id] = g);
      }
      r || (i[d] = BO), l || (l = !0, s = Rc(h.error) ? h.error.status : 500), h.headers && (c[d] = h.headers);
    } else
      i[d] = h.data, h.statusCode && h.statusCode !== 200 && !l && (s = h.statusCode), h.headers && (c[d] = h.headers);
  }), u !== void 0 && n && (o = { [n[0]]: u }, n[2] && (i[n[2]] = void 0)), {
    loaderData: i,
    errors: o,
    statusCode: s || 200,
    loaderHeaders: c
  };
}
function Uw(e, t, n, r, a, i) {
  let { loaderData: o, errors: s } = iL(
    t,
    n,
    r
  );
  return a.filter((l) => !l.matches || l.matches.some((c) => c.shouldLoad)).forEach((l) => {
    let { key: c, match: u, controller: f } = l;
    if (f && f.signal.aborted)
      return;
    let d = i[c];
    if (be(d, "Did not find corresponding fetcher result"), un(d)) {
      let h = Sa(e.matches, u == null ? void 0 : u.route.id);
      s && s[h.route.id] || (s = {
        ...s,
        [h.route.id]: d.error
      }), e.fetchers.delete(c);
    } else if (Ri(d))
      be(!1, "Unhandled fetcher revalidation redirect");
    else {
      let h = kr(d.data);
      e.fetchers.set(c, h);
    }
  }), { loaderData: o, errors: s };
}
function qw(e, t, n, r) {
  let a = Object.entries(t).filter(([, i]) => i !== BO).reduce((i, [o, s]) => (i[o] = s, i), {});
  for (let i of n) {
    let o = i.route.id;
    if (!t.hasOwnProperty(o) && e.hasOwnProperty(o) && i.route.loader && (a[o] = e[o]), r && r.hasOwnProperty(o))
      break;
  }
  return a;
}
function Bw(e) {
  return e ? un(e[1]) ? {
    // Clear out prior actionData on errors
    actionData: {}
  } : {
    actionData: {
      [e[0]]: e[1].data
    }
  } : {};
}
function Sa(e, t) {
  return (t ? e.slice(0, e.findIndex((r) => r.route.id === t) + 1) : [...e]).reverse().find((r) => r.route.hasErrorBoundary === !0) || e[0];
}
function Qu(e) {
  let t = e.length === 1 ? e[0] : e.find((n) => n.index || !n.path || n.path === "/") || {
    id: "__shim-error-route__"
  };
  return {
    matches: [
      {
        params: {},
        pathname: "",
        pathnameBase: "",
        route: t
      }
    ],
    route: t
  };
}
function Tn(e, {
  pathname: t,
  routeId: n,
  method: r,
  type: a,
  message: i
} = {}) {
  let o = "Unknown Server Error", s = "Unknown @remix-run/router error";
  return e === 400 ? (o = "Bad Request", r && t && n ? s = `You made a ${r} request to "${t}" but did not provide a \`loader\` for route "${n}", so there is no way to handle the request.` : a === "invalid-body" && (s = "Unable to encode submission body")) : e === 403 ? (o = "Forbidden", s = `Route "${n}" does not match URL "${t}"`) : e === 404 ? (o = "Not Found", s = `No route matches URL "${t}"`) : e === 405 && (o = "Method Not Allowed", r && t && n ? s = `You made a ${r.toUpperCase()} request to "${t}" but did not provide an \`action\` for route "${n}", so there is no way to handle the request.` : r && (s = `Invalid request method "${r.toUpperCase()}"`)), new hg(
    e || 500,
    o,
    new Error(s),
    !0
  );
}
function Hu(e) {
  let t = Object.entries(e);
  for (let n = t.length - 1; n >= 0; n--) {
    let [r, a] = t[n];
    if (Ri(a))
      return { key: r, result: a };
  }
}
function YO(e) {
  let t = typeof e == "string" ? ta(e) : e;
  return cr({ ...t, hash: "" });
}
function oL(e, t) {
  return e.pathname !== t.pathname || e.search !== t.search ? !1 : e.hash === "" ? t.hash !== "" : e.hash === t.hash ? !0 : t.hash !== "";
}
function sL(e) {
  return e != null && typeof e == "object" && Object.entries(e).every(
    ([t, n]) => typeof t == "string" && lL(n)
  );
}
function lL(e) {
  return e != null && typeof e == "object" && "type" in e && "result" in e && (e.type === "data" || e.type === "error");
}
function cL(e) {
  return KO(e.result) && V2.has(e.result.status);
}
function un(e) {
  return e.type === "error";
}
function Ri(e) {
  return (e && e.type) === "redirect";
}
function Vw(e) {
  return typeof e == "object" && e != null && "type" in e && "data" in e && "init" in e && e.type === "DataWithResponseInit";
}
function KO(e) {
  return e != null && typeof e.status == "number" && typeof e.statusText == "string" && typeof e.headers == "object" && typeof e.body < "u";
}
function uL(e) {
  return B2.has(e.toUpperCase());
}
function Ht(e) {
  return U2.has(e.toUpperCase());
}
function Ry(e) {
  return new URLSearchParams(e).getAll("index").some((t) => t === "");
}
function xf(e, t) {
  let n = typeof t == "string" ? ta(t).search : t.search;
  if (e[e.length - 1].route.index && Ry(n || ""))
    return e[e.length - 1];
  let r = IO(e);
  return r[r.length - 1];
}
function Qw(e) {
  let { formMethod: t, formAction: n, formEncType: r, text: a, formData: i, json: o } = e;
  if (!(!t || !n || !r)) {
    if (a != null)
      return {
        formMethod: t,
        formAction: n,
        formEncType: r,
        formData: void 0,
        json: void 0,
        text: a
      };
    if (i != null)
      return {
        formMethod: t,
        formAction: n,
        formEncType: r,
        formData: i,
        json: void 0,
        text: void 0
      };
    if (o !== void 0)
      return {
        formMethod: t,
        formAction: n,
        formEncType: r,
        formData: void 0,
        json: o,
        text: void 0
      };
  }
}
function pp(e, t) {
  return t ? {
    state: "loading",
    location: e,
    formMethod: t.formMethod,
    formAction: t.formAction,
    formEncType: t.formEncType,
    formData: t.formData,
    json: t.json,
    text: t.text
  } : {
    state: "loading",
    location: e,
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0
  };
}
function fL(e, t) {
  return {
    state: "submitting",
    location: e,
    formMethod: t.formMethod,
    formAction: t.formAction,
    formEncType: t.formEncType,
    formData: t.formData,
    json: t.json,
    text: t.text
  };
}
function bl(e, t) {
  return e ? {
    state: "loading",
    formMethod: e.formMethod,
    formAction: e.formAction,
    formEncType: e.formEncType,
    formData: e.formData,
    json: e.json,
    text: e.text,
    data: t
  } : {
    state: "loading",
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0,
    data: t
  };
}
function dL(e, t) {
  return {
    state: "submitting",
    formMethod: e.formMethod,
    formAction: e.formAction,
    formEncType: e.formEncType,
    formData: e.formData,
    json: e.json,
    text: e.text,
    data: t ? t.data : void 0
  };
}
function kr(e) {
  return {
    state: "idle",
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0,
    data: e
  };
}
function hL(e, t) {
  try {
    let n = e.sessionStorage.getItem(
      qO
    );
    if (n) {
      let r = JSON.parse(n);
      for (let [a, i] of Object.entries(r || {}))
        i && Array.isArray(i) && t.set(a, new Set(i || []));
    }
  } catch {
  }
}
function pL(e, t) {
  if (t.size > 0) {
    let n = {};
    for (let [r, a] of t)
      n[r] = [...a];
    try {
      e.sessionStorage.setItem(
        qO,
        JSON.stringify(n)
      );
    } catch (r) {
      Je(
        !1,
        `Failed to save applied view transitions in sessionStorage (${r}).`
      );
    }
  }
}
function mL() {
  let e, t, n = new Promise((r, a) => {
    e = async (i) => {
      r(i);
      try {
        await n;
      } catch {
      }
    }, t = async (i) => {
      a(i);
      try {
        await n;
      } catch {
      }
    };
  });
  return {
    promise: n,
    //@ts-ignore
    resolve: e,
    //@ts-ignore
    reject: t
  };
}
var co = y.createContext(null);
co.displayName = "DataRouter";
var su = y.createContext(null);
su.displayName = "DataRouterState";
y.createContext(!1);
var _y = y.createContext({
  isTransitioning: !1
});
_y.displayName = "ViewTransition";
var XO = y.createContext(
  /* @__PURE__ */ new Map()
);
XO.displayName = "Fetchers";
var gL = y.createContext(null);
gL.displayName = "Await";
var mr = y.createContext(
  null
);
mr.displayName = "Navigation";
var Xd = y.createContext(
  null
);
Xd.displayName = "Location";
var Gn = y.createContext({
  outlet: null,
  matches: [],
  isDataRoute: !1
});
Gn.displayName = "Route";
var Dy = y.createContext(null);
Dy.displayName = "RouteError";
function vL(e, { relative: t } = {}) {
  be(
    lu(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useHref() may be used only in the context of a <Router> component."
  );
  let { basename: n, navigator: r } = y.useContext(mr), { hash: a, pathname: i, search: o } = cu(e, { relative: t }), s = i;
  return n !== "/" && (s = i === "/" ? n : or([n, i])), r.createHref({ pathname: s, search: o, hash: a });
}
function lu() {
  return y.useContext(Xd) != null;
}
function fi() {
  return be(
    lu(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useLocation() may be used only in the context of a <Router> component."
  ), y.useContext(Xd).location;
}
var WO = "You should call navigate() in a React.useEffect(), not when your component is first rendered.";
function ZO(e) {
  y.useContext(mr).static || y.useLayoutEffect(e);
}
function JO() {
  let { isDataRoute: e } = y.useContext(Gn);
  return e ? NL() : yL();
}
function yL() {
  be(
    lu(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useNavigate() may be used only in the context of a <Router> component."
  );
  let e = y.useContext(co), { basename: t, navigator: n } = y.useContext(mr), { matches: r } = y.useContext(Gn), { pathname: a } = fi(), i = JSON.stringify(Ty(r)), o = y.useRef(!1);
  return ZO(() => {
    o.current = !0;
  }), y.useCallback(
    (l, c = {}) => {
      if (Je(o.current, WO), !o.current) return;
      if (typeof l == "number") {
        n.go(l);
        return;
      }
      let u = Cy(
        l,
        JSON.parse(i),
        a,
        c.relative === "path"
      );
      e == null && t !== "/" && (u.pathname = u.pathname === "/" ? t : or([t, u.pathname])), (c.replace ? n.replace : n.push)(
        u,
        c.state,
        c
      );
    },
    [
      t,
      n,
      i,
      a,
      e
    ]
  );
}
var e1 = y.createContext(null);
function _8() {
  return y.useContext(e1);
}
function bL(e) {
  let t = y.useContext(Gn).outlet;
  return y.useMemo(
    () => t && /* @__PURE__ */ y.createElement(e1.Provider, { value: e }, t),
    [t, e]
  );
}
function D8() {
  let { matches: e } = y.useContext(Gn), t = e[e.length - 1];
  return t ? t.params : {};
}
function cu(e, { relative: t } = {}) {
  let { matches: n } = y.useContext(Gn), { pathname: r } = fi(), a = JSON.stringify(Ty(n));
  return y.useMemo(
    () => Cy(
      e,
      JSON.parse(a),
      r,
      t === "path"
    ),
    [e, a, r, t]
  );
}
function wL(e, t, n, r, a) {
  be(
    lu(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useRoutes() may be used only in the context of a <Router> component."
  );
  let { navigator: i } = y.useContext(mr), { matches: o } = y.useContext(Gn), s = o[o.length - 1], l = s ? s.params : {}, c = s ? s.pathname : "/", u = s ? s.pathnameBase : "/", f = s && s.route;
  {
    let m = f && f.path || "";
    t1(
      c,
      !f || m.endsWith("*") || m.endsWith("*?"),
      `You rendered descendant <Routes> (or called \`useRoutes()\`) at "${c}" (under <Route path="${m}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${m}"> to <Route path="${m === "/" ? "*" : `${m}/*`}">.`
    );
  }
  let d = fi(), h;
  h = d;
  let g = h.pathname || "/", v = g;
  if (u !== "/") {
    let m = u.replace(/^\//, "").split("/");
    v = "/" + g.replace(/^\//, "").split("/").slice(m.length).join("/");
  }
  let b = Ea(e, { pathname: v });
  return Je(
    f || b != null,
    `No routes matched location "${h.pathname}${h.search}${h.hash}" `
  ), Je(
    b == null || b[b.length - 1].route.element !== void 0 || b[b.length - 1].route.Component !== void 0 || b[b.length - 1].route.lazy !== void 0,
    `Matched leaf route at location "${h.pathname}${h.search}${h.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`
  ), CL(
    b && b.map(
      (m) => Object.assign({}, m, {
        params: Object.assign({}, l, m.params),
        pathname: or([
          u,
          // Re-encode pathnames that were decoded inside matchRoutes.
          // Pre-encode `?` and `#` ahead of `encodeLocation` because it uses
          // `new URL()` internally and we need to prevent it from treating
          // them as separators
          i.encodeLocation ? i.encodeLocation(
            m.pathname.replace(/\?/g, "%3F").replace(/#/g, "%23")
          ).pathname : m.pathname
        ]),
        pathnameBase: m.pathnameBase === "/" ? u : or([
          u,
          // Re-encode pathnames that were decoded inside matchRoutes
          // Pre-encode `?` and `#` ahead of `encodeLocation` because it uses
          // `new URL()` internally and we need to prevent it from treating
          // them as separators
          i.encodeLocation ? i.encodeLocation(
            m.pathnameBase.replace(/\?/g, "%3F").replace(/#/g, "%23")
          ).pathname : m.pathnameBase
        ])
      })
    ),
    o,
    n,
    r,
    a
  );
}
function xL() {
  let e = DL(), t = Rc(e) ? `${e.status} ${e.statusText}` : e instanceof Error ? e.message : JSON.stringify(e), n = e instanceof Error ? e.stack : null, r = "rgba(200,200,200, 0.5)", a = { padding: "0.5rem", backgroundColor: r }, i = { padding: "2px 4px", backgroundColor: r }, o = null;
  return console.error(
    "Error handled by React Router default ErrorBoundary:",
    e
  ), o = /* @__PURE__ */ y.createElement(y.Fragment, null, /* @__PURE__ */ y.createElement("p", null, " Hey developer "), /* @__PURE__ */ y.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", /* @__PURE__ */ y.createElement("code", { style: i }, "ErrorBoundary"), " or", " ", /* @__PURE__ */ y.createElement("code", { style: i }, "errorElement"), " prop on your route.")), /* @__PURE__ */ y.createElement(y.Fragment, null, /* @__PURE__ */ y.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ y.createElement("h3", { style: { fontStyle: "italic" } }, t), n ? /* @__PURE__ */ y.createElement("pre", { style: a }, n) : null, o);
}
var EL = /* @__PURE__ */ y.createElement(xL, null), SL = class extends y.Component {
  constructor(e) {
    super(e), this.state = {
      location: e.location,
      revalidation: e.revalidation,
      error: e.error
    };
  }
  static getDerivedStateFromError(e) {
    return { error: e };
  }
  static getDerivedStateFromProps(e, t) {
    return t.location !== e.location || t.revalidation !== "idle" && e.revalidation === "idle" ? {
      error: e.error,
      location: e.location,
      revalidation: e.revalidation
    } : {
      error: e.error !== void 0 ? e.error : t.error,
      location: t.location,
      revalidation: e.revalidation || t.revalidation
    };
  }
  componentDidCatch(e, t) {
    this.props.onError ? this.props.onError(e, t) : console.error(
      "React Router caught the following error during render",
      e
    );
  }
  render() {
    return this.state.error !== void 0 ? /* @__PURE__ */ y.createElement(Gn.Provider, { value: this.props.routeContext }, /* @__PURE__ */ y.createElement(
      Dy.Provider,
      {
        value: this.state.error,
        children: this.props.component
      }
    )) : this.props.children;
  }
};
function TL({ routeContext: e, match: t, children: n }) {
  let r = y.useContext(co);
  return r && r.static && r.staticContext && (t.route.errorElement || t.route.ErrorBoundary) && (r.staticContext._deepestRenderedBoundaryId = t.route.id), /* @__PURE__ */ y.createElement(Gn.Provider, { value: e }, n);
}
function CL(e, t = [], n = null, r = null, a = null) {
  if (e == null) {
    if (!n)
      return null;
    if (n.errors)
      e = n.matches;
    else if (t.length === 0 && !n.initialized && n.matches.length > 0)
      e = n.matches;
    else
      return null;
  }
  let i = e, o = n == null ? void 0 : n.errors;
  if (o != null) {
    let u = i.findIndex(
      (f) => f.route.id && (o == null ? void 0 : o[f.route.id]) !== void 0
    );
    be(
      u >= 0,
      `Could not find a matching route for errors on route IDs: ${Object.keys(
        o
      ).join(",")}`
    ), i = i.slice(
      0,
      Math.min(i.length, u + 1)
    );
  }
  let s = !1, l = -1;
  if (n)
    for (let u = 0; u < i.length; u++) {
      let f = i[u];
      if ((f.route.HydrateFallback || f.route.hydrateFallbackElement) && (l = u), f.route.id) {
        let { loaderData: d, errors: h } = n, g = f.route.loader && !d.hasOwnProperty(f.route.id) && (!h || h[f.route.id] === void 0);
        if (f.route.lazy || g) {
          s = !0, l >= 0 ? i = i.slice(0, l + 1) : i = [i[0]];
          break;
        }
      }
    }
  let c = n && r ? (u, f) => {
    var d, h;
    r(u, {
      location: n.location,
      params: ((h = (d = n.matches) == null ? void 0 : d[0]) == null ? void 0 : h.params) ?? {},
      errorInfo: f
    });
  } : void 0;
  return i.reduceRight(
    (u, f, d) => {
      let h, g = !1, v = null, b = null;
      n && (h = o && f.route.id ? o[f.route.id] : void 0, v = f.route.errorElement || EL, s && (l < 0 && d === 0 ? (t1(
        "route-fallback",
        !1,
        "No `HydrateFallback` element provided to render during initial hydration"
      ), g = !0, b = null) : l === d && (g = !0, b = f.route.hydrateFallbackElement || null)));
      let p = t.concat(i.slice(0, d + 1)), m = () => {
        let w;
        return h ? w = v : g ? w = b : f.route.Component ? w = /* @__PURE__ */ y.createElement(f.route.Component, null) : f.route.element ? w = f.route.element : w = u, /* @__PURE__ */ y.createElement(
          TL,
          {
            match: f,
            routeContext: {
              outlet: u,
              matches: p,
              isDataRoute: n != null
            },
            children: w
          }
        );
      };
      return n && (f.route.ErrorBoundary || f.route.errorElement || d === 0) ? /* @__PURE__ */ y.createElement(
        SL,
        {
          location: n.location,
          revalidation: n.revalidation,
          component: v,
          error: h,
          children: m(),
          routeContext: { outlet: null, matches: p, isDataRoute: !0 },
          onError: c
        }
      ) : m();
    },
    null
  );
}
function Ny(e) {
  return `${e} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
}
function OL(e) {
  let t = y.useContext(co);
  return be(t, Ny(e)), t;
}
function AL(e) {
  let t = y.useContext(su);
  return be(t, Ny(e)), t;
}
function RL(e) {
  let t = y.useContext(Gn);
  return be(t, Ny(e)), t;
}
function ky(e) {
  let t = RL(e), n = t.matches[t.matches.length - 1];
  return be(
    n.route.id,
    `${e} can only be used on routes that contain a unique "id"`
  ), n.route.id;
}
function _L() {
  return ky(
    "useRouteId"
    /* UseRouteId */
  );
}
function DL() {
  var r;
  let e = y.useContext(Dy), t = AL(
    "useRouteError"
    /* UseRouteError */
  ), n = ky(
    "useRouteError"
    /* UseRouteError */
  );
  return e !== void 0 ? e : (r = t.errors) == null ? void 0 : r[n];
}
function NL() {
  let { router: e } = OL(
    "useNavigate"
    /* UseNavigateStable */
  ), t = ky(
    "useNavigate"
    /* UseNavigateStable */
  ), n = y.useRef(!1);
  return ZO(() => {
    n.current = !0;
  }), y.useCallback(
    async (a, i = {}) => {
      Je(n.current, WO), n.current && (typeof a == "number" ? e.navigate(a) : await e.navigate(a, { fromRouteId: t, ...i }));
    },
    [e, t]
  );
}
var Hw = {};
function t1(e, t, n) {
  !t && !Hw[e] && (Hw[e] = !0, Je(!1, n));
}
var $w = {};
function Gw(e, t) {
  !e && !$w[t] && ($w[t] = !0, console.warn(t));
}
function kL(e) {
  let t = {
    // Note: this check also occurs in createRoutesFromChildren so update
    // there if you change this -- please and thank you!
    hasErrorBoundary: e.hasErrorBoundary || e.ErrorBoundary != null || e.errorElement != null
  };
  return e.Component && (e.element && Je(
    !1,
    "You should not include both `Component` and `element` on your route - `Component` will be used."
  ), Object.assign(t, {
    element: y.createElement(e.Component),
    Component: void 0
  })), e.HydrateFallback && (e.hydrateFallbackElement && Je(
    !1,
    "You should not include both `HydrateFallback` and `hydrateFallbackElement` on your route - `HydrateFallback` will be used."
  ), Object.assign(t, {
    hydrateFallbackElement: y.createElement(e.HydrateFallback),
    HydrateFallback: void 0
  })), e.ErrorBoundary && (e.errorElement && Je(
    !1,
    "You should not include both `ErrorBoundary` and `errorElement` on your route - `ErrorBoundary` will be used."
  ), Object.assign(t, {
    errorElement: y.createElement(e.ErrorBoundary),
    ErrorBoundary: void 0
  })), t;
}
var ML = [
  "HydrateFallback",
  "hydrateFallbackElement"
];
function LL(e, t) {
  return G2({
    basename: t == null ? void 0 : t.basename,
    getContext: t == null ? void 0 : t.getContext,
    future: t == null ? void 0 : t.future,
    history: s2({
      initialEntries: t == null ? void 0 : t.initialEntries,
      initialIndex: t == null ? void 0 : t.initialIndex
    }),
    hydrationData: t == null ? void 0 : t.hydrationData,
    routes: e,
    hydrationRouteProperties: ML,
    mapRouteProperties: kL,
    dataStrategy: t == null ? void 0 : t.dataStrategy,
    patchRoutesOnNavigation: t == null ? void 0 : t.patchRoutesOnNavigation,
    unstable_instrumentations: t == null ? void 0 : t.unstable_instrumentations
  }).initialize();
}
var zL = class {
  constructor() {
    this.status = "pending", this.promise = new Promise((e, t) => {
      this.resolve = (n) => {
        this.status === "pending" && (this.status = "resolved", e(n));
      }, this.reject = (n) => {
        this.status === "pending" && (this.status = "rejected", t(n));
      };
    });
  }
};
function jL({
  router: e,
  flushSync: t,
  unstable_onError: n
}) {
  let [r, a] = y.useState(e.state), [i, o] = y.useState(), [s, l] = y.useState({
    isTransitioning: !1
  }), [c, u] = y.useState(), [f, d] = y.useState(), [h, g] = y.useState(), v = y.useRef(/* @__PURE__ */ new Map()), b = y.useCallback(
    (S) => {
      a((T) => (S.errors && n && Object.entries(S.errors).forEach(([E, O]) => {
        var D, A;
        ((D = T.errors) == null ? void 0 : D[E]) !== O && n(O, {
          location: S.location,
          params: ((A = S.matches[0]) == null ? void 0 : A.params) ?? {}
        });
      }), S));
    },
    [n]
  ), p = y.useCallback(
    (S, { deletedFetchers: T, flushSync: E, viewTransitionOpts: O }) => {
      S.fetchers.forEach((A, U) => {
        A.data !== void 0 && v.current.set(U, A.data);
      }), T.forEach((A) => v.current.delete(A)), Gw(
        E === !1 || t != null,
        'You provided the `flushSync` option to a router update, but you are not using the `<RouterProvider>` from `react-router/dom` so `ReactDOM.flushSync()` is unavailable.  Please update your app to `import { RouterProvider } from "react-router/dom"` and ensure you have `react-dom` installed as a dependency to use the `flushSync` option.'
      );
      let D = e.window != null && e.window.document != null && typeof e.window.document.startViewTransition == "function";
      if (Gw(
        O == null || D,
        "You provided the `viewTransition` option to a router update, but you do not appear to be running in a DOM environment as `window.startViewTransition` is not available."
      ), !O || !D) {
        t && E ? t(() => b(S)) : y.startTransition(() => b(S));
        return;
      }
      if (t && E) {
        t(() => {
          f && (c && c.resolve(), f.skipTransition()), l({
            isTransitioning: !0,
            flushSync: !0,
            currentLocation: O.currentLocation,
            nextLocation: O.nextLocation
          });
        });
        let A = e.window.document.startViewTransition(() => {
          t(() => b(S));
        });
        A.finished.finally(() => {
          t(() => {
            u(void 0), d(void 0), o(void 0), l({ isTransitioning: !1 });
          });
        }), t(() => d(A));
        return;
      }
      f ? (c && c.resolve(), f.skipTransition(), g({
        state: S,
        currentLocation: O.currentLocation,
        nextLocation: O.nextLocation
      })) : (o(S), l({
        isTransitioning: !0,
        flushSync: !1,
        currentLocation: O.currentLocation,
        nextLocation: O.nextLocation
      }));
    },
    [
      e.window,
      t,
      f,
      c,
      b
    ]
  );
  y.useLayoutEffect(() => e.subscribe(p), [e, p]), y.useEffect(() => {
    s.isTransitioning && !s.flushSync && u(new zL());
  }, [s]), y.useEffect(() => {
    if (c && i && e.window) {
      let S = i, T = c.promise, E = e.window.document.startViewTransition(async () => {
        y.startTransition(() => b(S)), await T;
      });
      E.finished.finally(() => {
        u(void 0), d(void 0), o(void 0), l({ isTransitioning: !1 });
      }), d(E);
    }
  }, [i, c, e.window, b]), y.useEffect(() => {
    c && i && r.location.key === i.location.key && c.resolve();
  }, [c, f, r.location, i]), y.useEffect(() => {
    !s.isTransitioning && h && (o(h.state), l({
      isTransitioning: !0,
      flushSync: !1,
      currentLocation: h.currentLocation,
      nextLocation: h.nextLocation
    }), g(void 0));
  }, [s.isTransitioning, h]);
  let m = y.useMemo(() => ({
    createHref: e.createHref,
    encodeLocation: e.encodeLocation,
    go: (S) => e.navigate(S),
    push: (S, T, E) => e.navigate(S, {
      state: T,
      preventScrollReset: E == null ? void 0 : E.preventScrollReset
    }),
    replace: (S, T, E) => e.navigate(S, {
      replace: !0,
      state: T,
      preventScrollReset: E == null ? void 0 : E.preventScrollReset
    })
  }), [e]), w = e.basename || "/", x = y.useMemo(
    () => ({
      router: e,
      navigator: m,
      static: !1,
      basename: w,
      unstable_onError: n
    }),
    [e, m, w, n]
  );
  return /* @__PURE__ */ y.createElement(y.Fragment, null, /* @__PURE__ */ y.createElement(co.Provider, { value: x }, /* @__PURE__ */ y.createElement(su.Provider, { value: r }, /* @__PURE__ */ y.createElement(XO.Provider, { value: v.current }, /* @__PURE__ */ y.createElement(_y.Provider, { value: s }, /* @__PURE__ */ y.createElement(
    FL,
    {
      basename: w,
      location: r.location,
      navigationType: r.historyAction,
      navigator: m
    },
    /* @__PURE__ */ y.createElement(
      PL,
      {
        routes: e.routes,
        future: e.future,
        state: r,
        unstable_onError: n
      }
    )
  ))))), null);
}
var PL = y.memo(IL);
function IL({
  routes: e,
  future: t,
  state: n,
  unstable_onError: r
}) {
  return wL(e, void 0, n, r, t);
}
function N8(e) {
  return bL(e.context);
}
function FL({
  basename: e = "/",
  children: t = null,
  location: n,
  navigationType: r = "POP",
  navigator: a,
  static: i = !1
}) {
  be(
    !lu(),
    "You cannot render a <Router> inside another <Router>. You should never have more than one in your app."
  );
  let o = e.replace(/^\/*/, "/"), s = y.useMemo(
    () => ({
      basename: o,
      navigator: a,
      static: i,
      future: {}
    }),
    [o, a, i]
  );
  typeof n == "string" && (n = ta(n));
  let {
    pathname: l = "/",
    search: c = "",
    hash: u = "",
    state: f = null,
    key: d = "default"
  } = n, h = y.useMemo(() => {
    let g = jn(l, o);
    return g == null ? null : {
      location: {
        pathname: g,
        search: c,
        hash: u,
        state: f,
        key: d
      },
      navigationType: r
    };
  }, [o, l, c, u, f, d, r]);
  return Je(
    h != null,
    `<Router basename="${o}"> is not able to match the URL "${l}${c}${u}" because it does not start with the basename, so the <Router> won't render anything.`
  ), h == null ? null : /* @__PURE__ */ y.createElement(mr.Provider, { value: s }, /* @__PURE__ */ y.createElement(Xd.Provider, { children: t, value: h }));
}
var Ef = "get", Sf = "application/x-www-form-urlencoded";
function Wd(e) {
  return e != null && typeof e.tagName == "string";
}
function UL(e) {
  return Wd(e) && e.tagName.toLowerCase() === "button";
}
function qL(e) {
  return Wd(e) && e.tagName.toLowerCase() === "form";
}
function BL(e) {
  return Wd(e) && e.tagName.toLowerCase() === "input";
}
function VL(e) {
  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);
}
function QL(e, t) {
  return e.button === 0 && // Ignore everything but left clicks
  (!t || t === "_self") && // Let browser handle "target=_blank" etc.
  !VL(e);
}
function yg(e = "") {
  return new URLSearchParams(
    typeof e == "string" || Array.isArray(e) || e instanceof URLSearchParams ? e : Object.keys(e).reduce((t, n) => {
      let r = e[n];
      return t.concat(
        Array.isArray(r) ? r.map((a) => [n, a]) : [[n, r]]
      );
    }, [])
  );
}
function HL(e, t) {
  let n = yg(e);
  return t && t.forEach((r, a) => {
    n.has(a) || t.getAll(a).forEach((i) => {
      n.append(a, i);
    });
  }), n;
}
var $u = null;
function $L() {
  if ($u === null)
    try {
      new FormData(
        document.createElement("form"),
        // @ts-expect-error if FormData supports the submitter parameter, this will throw
        0
      ), $u = !1;
    } catch {
      $u = !0;
    }
  return $u;
}
var GL = /* @__PURE__ */ new Set([
  "application/x-www-form-urlencoded",
  "multipart/form-data",
  "text/plain"
]);
function mp(e) {
  return e != null && !GL.has(e) ? (Je(
    !1,
    `"${e}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${Sf}"`
  ), null) : e;
}
function YL(e, t) {
  let n, r, a, i, o;
  if (qL(e)) {
    let s = e.getAttribute("action");
    r = s ? jn(s, t) : null, n = e.getAttribute("method") || Ef, a = mp(e.getAttribute("enctype")) || Sf, i = new FormData(e);
  } else if (UL(e) || BL(e) && (e.type === "submit" || e.type === "image")) {
    let s = e.form;
    if (s == null)
      throw new Error(
        'Cannot submit a <button> or <input type="submit"> without a <form>'
      );
    let l = e.getAttribute("formaction") || s.getAttribute("action");
    if (r = l ? jn(l, t) : null, n = e.getAttribute("formmethod") || s.getAttribute("method") || Ef, a = mp(e.getAttribute("formenctype")) || mp(s.getAttribute("enctype")) || Sf, i = new FormData(s, e), !$L()) {
      let { name: c, type: u, value: f } = e;
      if (u === "image") {
        let d = c ? `${c}.` : "";
        i.append(`${d}x`, "0"), i.append(`${d}y`, "0");
      } else c && i.append(c, f);
    }
  } else {
    if (Wd(e))
      throw new Error(
        'Cannot submit element that is not <form>, <button>, or <input type="submit|image">'
      );
    n = Ef, r = null, a = Sf, o = e;
  }
  return i && a === "text/plain" && (o = i, i = void 0), { action: r, method: n.toLowerCase(), encType: a, formData: i, body: o };
}
Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
function My(e, t) {
  if (e === !1 || e === null || typeof e > "u")
    throw new Error(t);
}
function KL(e, t, n) {
  let r = typeof e == "string" ? new URL(
    e,
    // This can be called during the SSR flow via PrefetchPageLinksImpl so
    // don't assume window is available
    typeof window > "u" ? "server://singlefetch/" : window.location.origin
  ) : e;
  return r.pathname === "/" ? r.pathname = `_root.${n}` : t && jn(r.pathname, t) === "/" ? r.pathname = `${t.replace(/\/$/, "")}/_root.${n}` : r.pathname = `${r.pathname.replace(/\/$/, "")}.${n}`, r;
}
async function XL(e, t) {
  if (e.id in t)
    return t[e.id];
  try {
    let n = await import(
      /* @vite-ignore */
      /* webpackIgnore: true */
      e.module
    );
    return t[e.id] = n, n;
  } catch (n) {
    return console.error(
      `Error loading route module \`${e.module}\`, reloading page...`
    ), console.error(n), window.__reactRouterContext && window.__reactRouterContext.isSpaMode, window.location.reload(), new Promise(() => {
    });
  }
}
function WL(e) {
  return e == null ? !1 : e.href == null ? e.rel === "preload" && typeof e.imageSrcSet == "string" && typeof e.imageSizes == "string" : typeof e.rel == "string" && typeof e.href == "string";
}
async function ZL(e, t, n) {
  let r = await Promise.all(
    e.map(async (a) => {
      let i = t.routes[a.route.id];
      if (i) {
        let o = await XL(i, n);
        return o.links ? o.links() : [];
      }
      return [];
    })
  );
  return nz(
    r.flat(1).filter(WL).filter((a) => a.rel === "stylesheet" || a.rel === "preload").map(
      (a) => a.rel === "stylesheet" ? { ...a, rel: "prefetch", as: "style" } : { ...a, rel: "prefetch" }
    )
  );
}
function Yw(e, t, n, r, a, i) {
  let o = (l, c) => n[c] ? l.route.id !== n[c].route.id : !0, s = (l, c) => {
    var u;
    return (
      // param change, /users/123 -> /users/456
      n[c].pathname !== l.pathname || // splat param changed, which is not present in match.path
      // e.g. /files/images/avatar.jpg -> files/finances.xls
      ((u = n[c].route.path) == null ? void 0 : u.endsWith("*")) && n[c].params["*"] !== l.params["*"]
    );
  };
  return i === "assets" ? t.filter(
    (l, c) => o(l, c) || s(l, c)
  ) : i === "data" ? t.filter((l, c) => {
    var f;
    let u = r.routes[l.route.id];
    if (!u || !u.hasLoader)
      return !1;
    if (o(l, c) || s(l, c))
      return !0;
    if (l.route.shouldRevalidate) {
      let d = l.route.shouldRevalidate({
        currentUrl: new URL(
          a.pathname + a.search + a.hash,
          window.origin
        ),
        currentParams: ((f = n[0]) == null ? void 0 : f.params) || {},
        nextUrl: new URL(e, window.origin),
        nextParams: l.params,
        defaultShouldRevalidate: !0
      });
      if (typeof d == "boolean")
        return d;
    }
    return !0;
  }) : [];
}
function JL(e, t, { includeHydrateFallback: n } = {}) {
  return ez(
    e.map((r) => {
      let a = t.routes[r.route.id];
      if (!a) return [];
      let i = [a.module];
      return a.clientActionModule && (i = i.concat(a.clientActionModule)), a.clientLoaderModule && (i = i.concat(a.clientLoaderModule)), n && a.hydrateFallbackModule && (i = i.concat(a.hydrateFallbackModule)), a.imports && (i = i.concat(a.imports)), i;
    }).flat(1)
  );
}
function ez(e) {
  return [...new Set(e)];
}
function tz(e) {
  let t = {}, n = Object.keys(e).sort();
  for (let r of n)
    t[r] = e[r];
  return t;
}
function nz(e, t) {
  let n = /* @__PURE__ */ new Set();
  return new Set(t), e.reduce((r, a) => {
    let i = JSON.stringify(tz(a));
    return n.has(i) || (n.add(i), r.push({ key: i, link: a })), r;
  }, []);
}
function n1() {
  let e = y.useContext(co);
  return My(
    e,
    "You must render this element inside a <DataRouterContext.Provider> element"
  ), e;
}
function rz() {
  let e = y.useContext(su);
  return My(
    e,
    "You must render this element inside a <DataRouterStateContext.Provider> element"
  ), e;
}
var Ly = y.createContext(void 0);
Ly.displayName = "FrameworkContext";
function r1() {
  let e = y.useContext(Ly);
  return My(
    e,
    "You must render this element inside a <HydratedRouter> element"
  ), e;
}
function az(e, t) {
  let n = y.useContext(Ly), [r, a] = y.useState(!1), [i, o] = y.useState(!1), { onFocus: s, onBlur: l, onMouseEnter: c, onMouseLeave: u, onTouchStart: f } = t, d = y.useRef(null);
  y.useEffect(() => {
    if (e === "render" && o(!0), e === "viewport") {
      let v = (p) => {
        p.forEach((m) => {
          o(m.isIntersecting);
        });
      }, b = new IntersectionObserver(v, { threshold: 0.5 });
      return d.current && b.observe(d.current), () => {
        b.disconnect();
      };
    }
  }, [e]), y.useEffect(() => {
    if (r) {
      let v = setTimeout(() => {
        o(!0);
      }, 100);
      return () => {
        clearTimeout(v);
      };
    }
  }, [r]);
  let h = () => {
    a(!0);
  }, g = () => {
    a(!1), o(!1);
  };
  return n ? e !== "intent" ? [i, d, {}] : [
    i,
    d,
    {
      onFocus: wl(s, h),
      onBlur: wl(l, g),
      onMouseEnter: wl(c, h),
      onMouseLeave: wl(u, g),
      onTouchStart: wl(f, h)
    }
  ] : [!1, d, {}];
}
function wl(e, t) {
  return (n) => {
    e && e(n), n.defaultPrevented || t(n);
  };
}
function iz({ page: e, ...t }) {
  let { router: n } = n1(), r = y.useMemo(
    () => Ea(n.routes, e, n.basename),
    [n.routes, e, n.basename]
  );
  return r ? /* @__PURE__ */ y.createElement(sz, { page: e, matches: r, ...t }) : null;
}
function oz(e) {
  let { manifest: t, routeModules: n } = r1(), [r, a] = y.useState([]);
  return y.useEffect(() => {
    let i = !1;
    return ZL(e, t, n).then(
      (o) => {
        i || a(o);
      }
    ), () => {
      i = !0;
    };
  }, [e, t, n]), r;
}
function sz({
  page: e,
  matches: t,
  ...n
}) {
  let r = fi(), { manifest: a, routeModules: i } = r1(), { basename: o } = n1(), { loaderData: s, matches: l } = rz(), c = y.useMemo(
    () => Yw(
      e,
      t,
      l,
      a,
      r,
      "data"
    ),
    [e, t, l, a, r]
  ), u = y.useMemo(
    () => Yw(
      e,
      t,
      l,
      a,
      r,
      "assets"
    ),
    [e, t, l, a, r]
  ), f = y.useMemo(() => {
    if (e === r.pathname + r.search + r.hash)
      return [];
    let g = /* @__PURE__ */ new Set(), v = !1;
    if (t.forEach((p) => {
      var w;
      let m = a.routes[p.route.id];
      !m || !m.hasLoader || (!c.some((x) => x.route.id === p.route.id) && p.route.id in s && ((w = i[p.route.id]) != null && w.shouldRevalidate) || m.hasClientLoader ? v = !0 : g.add(p.route.id));
    }), g.size === 0)
      return [];
    let b = KL(e, o, "data");
    return v && g.size > 0 && b.searchParams.set(
      "_routes",
      t.filter((p) => g.has(p.route.id)).map((p) => p.route.id).join(",")
    ), [b.pathname + b.search];
  }, [
    o,
    s,
    r,
    a,
    c,
    t,
    e,
    i
  ]), d = y.useMemo(
    () => JL(u, a),
    [u, a]
  ), h = oz(u);
  return /* @__PURE__ */ y.createElement(y.Fragment, null, f.map((g) => /* @__PURE__ */ y.createElement("link", { key: g, rel: "prefetch", as: "fetch", href: g, ...n })), d.map((g) => /* @__PURE__ */ y.createElement("link", { key: g, rel: "modulepreload", href: g, ...n })), h.map(({ key: g, link: v }) => (
    // these don't spread `linkProps` because they are full link descriptors
    // already with their own props
    /* @__PURE__ */ y.createElement("link", { key: g, nonce: n.nonce, ...v })
  )));
}
function lz(...e) {
  return (t) => {
    e.forEach((n) => {
      typeof n == "function" ? n(t) : n != null && (n.current = t);
    });
  };
}
var a1 = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
try {
  a1 && (window.__reactRouterVersion = // @ts-expect-error
  "7.9.6");
} catch {
}
var i1 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, o1 = y.forwardRef(
  function({
    onClick: t,
    discover: n = "render",
    prefetch: r = "none",
    relative: a,
    reloadDocument: i,
    replace: o,
    state: s,
    target: l,
    to: c,
    preventScrollReset: u,
    viewTransition: f,
    ...d
  }, h) {
    let { basename: g } = y.useContext(mr), v = typeof c == "string" && i1.test(c), b, p = !1;
    if (typeof c == "string" && v && (b = c, a1))
      try {
        let D = new URL(window.location.href), A = c.startsWith("//") ? new URL(D.protocol + c) : new URL(c), U = jn(A.pathname, g);
        A.origin === D.origin && U != null ? c = U + A.search + A.hash : p = !0;
      } catch {
        Je(
          !1,
          `<Link to="${c}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`
        );
      }
    let m = vL(c, { relative: a }), [w, x, S] = az(
      r,
      d
    ), T = dz(c, {
      replace: o,
      state: s,
      target: l,
      preventScrollReset: u,
      relative: a,
      viewTransition: f
    });
    function E(D) {
      t && t(D), D.defaultPrevented || T(D);
    }
    let O = (
      // eslint-disable-next-line jsx-a11y/anchor-has-content
      /* @__PURE__ */ y.createElement(
        "a",
        {
          ...d,
          ...S,
          href: b || m,
          onClick: p || i ? t : E,
          ref: lz(h, x),
          target: l,
          "data-discover": !v && n === "render" ? "true" : void 0
        }
      )
    );
    return w && !v ? /* @__PURE__ */ y.createElement(y.Fragment, null, O, /* @__PURE__ */ y.createElement(iz, { page: m })) : O;
  }
);
o1.displayName = "Link";
var cz = y.forwardRef(
  function({
    "aria-current": t = "page",
    caseSensitive: n = !1,
    className: r = "",
    end: a = !1,
    style: i,
    to: o,
    viewTransition: s,
    children: l,
    ...c
  }, u) {
    let f = cu(o, { relative: c.relative }), d = fi(), h = y.useContext(su), { navigator: g, basename: v } = y.useContext(mr), b = h != null && // Conditional usage is OK here because the usage of a data router is static
    // eslint-disable-next-line react-hooks/rules-of-hooks
    vz(f) && s === !0, p = g.encodeLocation ? g.encodeLocation(f).pathname : f.pathname, m = d.pathname, w = h && h.navigation && h.navigation.location ? h.navigation.location.pathname : null;
    n || (m = m.toLowerCase(), w = w ? w.toLowerCase() : null, p = p.toLowerCase()), w && v && (w = jn(w, v) || w);
    const x = p !== "/" && p.endsWith("/") ? p.length - 1 : p.length;
    let S = m === p || !a && m.startsWith(p) && m.charAt(x) === "/", T = w != null && (w === p || !a && w.startsWith(p) && w.charAt(p.length) === "/"), E = {
      isActive: S,
      isPending: T,
      isTransitioning: b
    }, O = S ? t : void 0, D;
    typeof r == "function" ? D = r(E) : D = [
      r,
      S ? "active" : null,
      T ? "pending" : null,
      b ? "transitioning" : null
    ].filter(Boolean).join(" ");
    let A = typeof i == "function" ? i(E) : i;
    return /* @__PURE__ */ y.createElement(
      o1,
      {
        ...c,
        "aria-current": O,
        className: D,
        ref: u,
        style: A,
        to: o,
        viewTransition: s
      },
      typeof l == "function" ? l(E) : l
    );
  }
);
cz.displayName = "NavLink";
var uz = y.forwardRef(
  ({
    discover: e = "render",
    fetcherKey: t,
    navigate: n,
    reloadDocument: r,
    replace: a,
    state: i,
    method: o = Ef,
    action: s,
    onSubmit: l,
    relative: c,
    preventScrollReset: u,
    viewTransition: f,
    ...d
  }, h) => {
    let g = mz(), v = gz(s, { relative: c }), b = o.toLowerCase() === "get" ? "get" : "post", p = typeof s == "string" && i1.test(s), m = (w) => {
      if (l && l(w), w.defaultPrevented) return;
      w.preventDefault();
      let x = w.nativeEvent.submitter, S = (x == null ? void 0 : x.getAttribute("formmethod")) || o;
      g(x || w.currentTarget, {
        fetcherKey: t,
        method: S,
        navigate: n,
        replace: a,
        state: i,
        relative: c,
        preventScrollReset: u,
        viewTransition: f
      });
    };
    return /* @__PURE__ */ y.createElement(
      "form",
      {
        ref: h,
        method: b,
        action: v,
        onSubmit: r ? l : m,
        ...d,
        "data-discover": !p && e === "render" ? "true" : void 0
      }
    );
  }
);
uz.displayName = "Form";
function fz(e) {
  return `${e} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
}
function s1(e) {
  let t = y.useContext(co);
  return be(t, fz(e)), t;
}
function dz(e, {
  target: t,
  replace: n,
  state: r,
  preventScrollReset: a,
  relative: i,
  viewTransition: o
} = {}) {
  let s = JO(), l = fi(), c = cu(e, { relative: i });
  return y.useCallback(
    (u) => {
      if (QL(u, t)) {
        u.preventDefault();
        let f = n !== void 0 ? n : cr(l) === cr(c);
        s(e, {
          replace: f,
          state: r,
          preventScrollReset: a,
          relative: i,
          viewTransition: o
        });
      }
    },
    [
      l,
      s,
      c,
      n,
      r,
      t,
      e,
      a,
      i,
      o
    ]
  );
}
function k8(e) {
  Je(
    typeof URLSearchParams < "u",
    "You cannot use the `useSearchParams` hook in a browser that does not support the URLSearchParams API. If you need to support Internet Explorer 11, we recommend you load a polyfill such as https://github.com/ungap/url-search-params."
  );
  let t = y.useRef(yg(e)), n = y.useRef(!1), r = fi(), a = y.useMemo(
    () => (
      // Only merge in the defaults if we haven't yet called setSearchParams.
      // Once we call that we want those to take precedence, otherwise you can't
      // remove a param with setSearchParams({}) if it has an initial value
      HL(
        r.search,
        n.current ? null : t.current
      )
    ),
    [r.search]
  ), i = JO(), o = y.useCallback(
    (s, l) => {
      const c = yg(
        typeof s == "function" ? s(new URLSearchParams(a)) : s
      );
      n.current = !0, i("?" + c, l);
    },
    [i, a]
  );
  return [a, o];
}
var hz = 0, pz = () => `__${String(++hz)}__`;
function mz() {
  let { router: e } = s1(
    "useSubmit"
    /* UseSubmit */
  ), { basename: t } = y.useContext(mr), n = _L();
  return y.useCallback(
    async (r, a = {}) => {
      let { action: i, method: o, encType: s, formData: l, body: c } = YL(
        r,
        t
      );
      if (a.navigate === !1) {
        let u = a.fetcherKey || pz();
        await e.fetch(u, n, a.action || i, {
          preventScrollReset: a.preventScrollReset,
          formData: l,
          body: c,
          formMethod: a.method || o,
          formEncType: a.encType || s,
          flushSync: a.flushSync
        });
      } else
        await e.navigate(a.action || i, {
          preventScrollReset: a.preventScrollReset,
          formData: l,
          body: c,
          formMethod: a.method || o,
          formEncType: a.encType || s,
          replace: a.replace,
          state: a.state,
          fromRouteId: n,
          flushSync: a.flushSync,
          viewTransition: a.viewTransition
        });
    },
    [e, t, n]
  );
}
function gz(e, { relative: t } = {}) {
  let { basename: n } = y.useContext(mr), r = y.useContext(Gn);
  be(r, "useFormAction must be used inside a RouteContext");
  let [a] = r.matches.slice(-1), i = { ...cu(e || ".", { relative: t }) }, o = fi();
  if (e == null) {
    i.search = o.search;
    let s = new URLSearchParams(i.search), l = s.getAll("index");
    if (l.some((u) => u === "")) {
      s.delete("index"), l.filter((f) => f).forEach((f) => s.append("index", f));
      let u = s.toString();
      i.search = u ? `?${u}` : "";
    }
  }
  return (!e || e === ".") && a.route.index && (i.search = i.search ? i.search.replace(/^\?/, "?index&") : "?index"), n !== "/" && (i.pathname = i.pathname === "/" ? n : or([n, i.pathname])), cr(i);
}
function vz(e, { relative: t } = {}) {
  let n = y.useContext(_y);
  be(
    n != null,
    "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?"
  );
  let { basename: r } = s1(
    "useViewTransitionState"
    /* useViewTransitionState */
  ), a = cu(e, { relative: t });
  if (!n.isTransitioning)
    return !1;
  let i = jn(n.currentLocation.pathname, r) || n.currentLocation.pathname, o = jn(n.nextLocation.pathname, r) || n.nextLocation.pathname;
  return fd(a.pathname, o) != null || fd(a.pathname, i) != null;
}
var bg = function(e, t) {
  return bg = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, r) {
    n.__proto__ = r;
  } || function(n, r) {
    for (var a in r) Object.prototype.hasOwnProperty.call(r, a) && (n[a] = r[a]);
  }, bg(e, t);
};
function Yn(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  bg(e, t);
  function n() {
    this.constructor = e;
  }
  e.prototype = t === null ? Object.create(t) : (n.prototype = t.prototype, new n());
}
var M = function() {
  return M = Object.assign || function(t) {
    for (var n, r = 1, a = arguments.length; r < a; r++) {
      n = arguments[r];
      for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]);
    }
    return t;
  }, M.apply(this, arguments);
};
function Ln(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var a = 0, r = Object.getOwnPropertySymbols(e); a < r.length; a++)
      t.indexOf(r[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[a]) && (n[r[a]] = e[r[a]]);
  return n;
}
function ma(e, t, n, r) {
  function a(i) {
    return i instanceof n ? i : new n(function(o) {
      o(i);
    });
  }
  return new (n || (n = Promise))(function(i, o) {
    function s(u) {
      try {
        c(r.next(u));
      } catch (f) {
        o(f);
      }
    }
    function l(u) {
      try {
        c(r.throw(u));
      } catch (f) {
        o(f);
      }
    }
    function c(u) {
      u.done ? i(u.value) : a(u.value).then(s, l);
    }
    c((r = r.apply(e, t || [])).next());
  });
}
function ga(e, t) {
  var n = { label: 0, sent: function() {
    if (i[0] & 1) throw i[1];
    return i[1];
  }, trys: [], ops: [] }, r, a, i, o = Object.create((typeof Iterator == "function" ? Iterator : Object).prototype);
  return o.next = s(0), o.throw = s(1), o.return = s(2), typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function s(c) {
    return function(u) {
      return l([c, u]);
    };
  }
  function l(c) {
    if (r) throw new TypeError("Generator is already executing.");
    for (; o && (o = 0, c[0] && (n = 0)), n; ) try {
      if (r = 1, a && (i = c[0] & 2 ? a.return : c[0] ? a.throw || ((i = a.return) && i.call(a), 0) : a.next) && !(i = i.call(a, c[1])).done) return i;
      switch (a = 0, i && (c = [c[0] & 2, i.value]), c[0]) {
        case 0:
        case 1:
          i = c;
          break;
        case 4:
          return n.label++, { value: c[1], done: !1 };
        case 5:
          n.label++, a = c[1], c = [0];
          continue;
        case 7:
          c = n.ops.pop(), n.trys.pop();
          continue;
        default:
          if (i = n.trys, !(i = i.length > 0 && i[i.length - 1]) && (c[0] === 6 || c[0] === 2)) {
            n = 0;
            continue;
          }
          if (c[0] === 3 && (!i || c[1] > i[0] && c[1] < i[3])) {
            n.label = c[1];
            break;
          }
          if (c[0] === 6 && n.label < i[1]) {
            n.label = i[1], i = c;
            break;
          }
          if (i && n.label < i[2]) {
            n.label = i[2], n.ops.push(c);
            break;
          }
          i[2] && n.ops.pop(), n.trys.pop();
          continue;
      }
      c = t.call(e, n);
    } catch (u) {
      c = [6, u], a = 0;
    } finally {
      r = i = 0;
    }
    if (c[0] & 5) throw c[1];
    return { value: c[0] ? c[1] : void 0, done: !0 };
  }
}
function Nt(e, t, n) {
  if (n || arguments.length === 2) for (var r = 0, a = t.length, i; r < a; r++)
    (i || !(r in t)) && (i || (i = Array.prototype.slice.call(t, 0, r)), i[r] = t[r]);
  return e.concat(i || Array.prototype.slice.call(t));
}
var gp = "Invariant Violation", Kw = Object.setPrototypeOf, yz = Kw === void 0 ? function(e, t) {
  return e.__proto__ = t, e;
} : Kw, l1 = (
  /** @class */
  function(e) {
    Yn(t, e);
    function t(n) {
      n === void 0 && (n = gp);
      var r = e.call(this, typeof n == "number" ? gp + ": " + n + " (see https://github.com/apollographql/invariant-packages)" : n) || this;
      return r.framesToPop = 1, r.name = gp, yz(r, t.prototype), r;
    }
    return t;
  }(Error)
);
function Ci(e, t) {
  if (!e)
    throw new l1(t);
}
var c1 = ["debug", "log", "warn", "error", "silent"], bz = c1.indexOf("log");
function Gu(e) {
  return function() {
    if (c1.indexOf(e) >= bz) {
      var t = console[e] || console.log;
      return t.apply(console, arguments);
    }
  };
}
(function(e) {
  e.debug = Gu("debug"), e.log = Gu("log"), e.warn = Gu("warn"), e.error = Gu("error");
})(Ci || (Ci = {}));
var zy = "3.14.0";
function Bn(e) {
  try {
    return e();
  } catch {
  }
}
const hd = Bn(function() {
  return globalThis;
}) || Bn(function() {
  return window;
}) || Bn(function() {
  return self;
}) || Bn(function() {
  return global;
}) || // We don't expect the Function constructor ever to be invoked at runtime, as
// long as at least one of globalThis, window, self, or global is defined, so
// we are under no obligation to make it easy for static analysis tools to
// detect syntactic usage of the Function constructor. If you think you can
// improve your static analysis to detect this obfuscation, think again. This
// is an arms race you cannot win, at least not in JavaScript.
Bn(function() {
  return Bn.constructor("return this")();
});
var Xw = /* @__PURE__ */ new Map();
function wg(e) {
  var t = Xw.get(e) || 1;
  return Xw.set(e, t + 1), "".concat(e, ":").concat(t, ":").concat(Math.random().toString(36).slice(2));
}
function u1(e, t) {
  t === void 0 && (t = 0);
  var n = wg("stringifyForDisplay");
  return JSON.stringify(e, function(r, a) {
    return a === void 0 ? n : a;
  }, t).split(JSON.stringify(n)).join("<undefined>");
}
function Yu(e) {
  return function(t) {
    for (var n = [], r = 1; r < arguments.length; r++)
      n[r - 1] = arguments[r];
    if (typeof t == "number") {
      var a = t;
      t = jy(a), t || (t = Py(a, n), n = []);
    }
    e.apply(void 0, [t].concat(n));
  };
}
var W = Object.assign(function(t, n) {
  for (var r = [], a = 2; a < arguments.length; a++)
    r[a - 2] = arguments[a];
  t || Ci(t, jy(n, r) || Py(n, r));
}, {
  debug: Yu(Ci.debug),
  log: Yu(Ci.log),
  warn: Yu(Ci.warn),
  error: Yu(Ci.error)
});
function Gt(e) {
  for (var t = [], n = 1; n < arguments.length; n++)
    t[n - 1] = arguments[n];
  return new l1(jy(e, t) || Py(e, t));
}
var Ww = Symbol.for("ApolloErrorMessageHandler_" + zy);
function f1(e) {
  if (typeof e == "string")
    return e;
  try {
    return u1(e, 2).slice(0, 1e3);
  } catch {
    return "<non-serializable>";
  }
}
function jy(e, t) {
  if (t === void 0 && (t = []), !!e)
    return hd[Ww] && hd[Ww](e, t.map(f1));
}
function Py(e, t) {
  if (t === void 0 && (t = []), !!e)
    return "An error occurred! For more details, see the full error text at https://go.apollo.dev/c/err#".concat(encodeURIComponent(JSON.stringify({
      version: zy,
      message: e,
      args: t.map(f1)
    })));
}
function Tf(e, t) {
  if (!!!e)
    throw new Error(t);
}
function wz(e) {
  return typeof e == "object" && e !== null;
}
function xz(e, t) {
  if (!!!e)
    throw new Error(
      "Unexpected invariant triggered."
    );
}
const Ez = /\r\n|[\n\r]/g;
function xg(e, t) {
  let n = 0, r = 1;
  for (const a of e.body.matchAll(Ez)) {
    if (typeof a.index == "number" || xz(!1), a.index >= t)
      break;
    n = a.index + a[0].length, r += 1;
  }
  return {
    line: r,
    column: t + 1 - n
  };
}
function Sz(e) {
  return d1(
    e.source,
    xg(e.source, e.start)
  );
}
function d1(e, t) {
  const n = e.locationOffset.column - 1, r = "".padStart(n) + e.body, a = t.line - 1, i = e.locationOffset.line - 1, o = t.line + i, s = t.line === 1 ? n : 0, l = t.column + s, c = `${e.name}:${o}:${l}
`, u = r.split(/\r\n|[\n\r]/g), f = u[a];
  if (f.length > 120) {
    const d = Math.floor(l / 80), h = l % 80, g = [];
    for (let v = 0; v < f.length; v += 80)
      g.push(f.slice(v, v + 80));
    return c + Zw([
      [`${o} |`, g[0]],
      ...g.slice(1, d + 1).map((v) => ["|", v]),
      ["|", "^".padStart(h)],
      ["|", g[d + 1]]
    ]);
  }
  return c + Zw([
    // Lines specified like this: ["prefix", "string"],
    [`${o - 1} |`, u[a - 1]],
    [`${o} |`, f],
    ["|", "^".padStart(l)],
    [`${o + 1} |`, u[a + 1]]
  ]);
}
function Zw(e) {
  const t = e.filter(([r, a]) => a !== void 0), n = Math.max(...t.map(([r]) => r.length));
  return t.map(([r, a]) => r.padStart(n) + (a ? " " + a : "")).join(`
`);
}
function Tz(e) {
  const t = e[0];
  return t == null || "kind" in t || "length" in t ? {
    nodes: t,
    source: e[1],
    positions: e[2],
    path: e[3],
    originalError: e[4],
    extensions: e[5]
  } : t;
}
class Iy extends Error {
  /**
   * An array of `{ line, column }` locations within the source GraphQL document
   * which correspond to this error.
   *
   * Errors during validation often contain multiple locations, for example to
   * point out two things with the same name. Errors during execution include a
   * single location, the field which produced the error.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array describing the JSON-path into the execution response which
   * corresponds to this error. Only included for errors during execution.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array of GraphQL AST Nodes corresponding to this error.
   */
  /**
   * The source GraphQL document for the first location of this error.
   *
   * Note that if this Error represents more than one node, the source may not
   * represent nodes after the first node.
   */
  /**
   * An array of character offsets within the source GraphQL document
   * which correspond to this error.
   */
  /**
   * The original error thrown from a field resolver during execution.
   */
  /**
   * Extension fields to add to the formatted error.
   */
  /**
   * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.
   */
  constructor(t, ...n) {
    var r, a, i;
    const { nodes: o, source: s, positions: l, path: c, originalError: u, extensions: f } = Tz(n);
    super(t), this.name = "GraphQLError", this.path = c ?? void 0, this.originalError = u ?? void 0, this.nodes = Jw(
      Array.isArray(o) ? o : o ? [o] : void 0
    );
    const d = Jw(
      (r = this.nodes) === null || r === void 0 ? void 0 : r.map((g) => g.loc).filter((g) => g != null)
    );
    this.source = s ?? (d == null || (a = d[0]) === null || a === void 0 ? void 0 : a.source), this.positions = l ?? (d == null ? void 0 : d.map((g) => g.start)), this.locations = l && s ? l.map((g) => xg(s, g)) : d == null ? void 0 : d.map((g) => xg(g.source, g.start));
    const h = wz(
      u == null ? void 0 : u.extensions
    ) ? u == null ? void 0 : u.extensions : void 0;
    this.extensions = (i = f ?? h) !== null && i !== void 0 ? i : /* @__PURE__ */ Object.create(null), Object.defineProperties(this, {
      message: {
        writable: !0,
        enumerable: !0
      },
      name: {
        enumerable: !1
      },
      nodes: {
        enumerable: !1
      },
      source: {
        enumerable: !1
      },
      positions: {
        enumerable: !1
      },
      originalError: {
        enumerable: !1
      }
    }), u != null && u.stack ? Object.defineProperty(this, "stack", {
      value: u.stack,
      writable: !0,
      configurable: !0
    }) : Error.captureStackTrace ? Error.captureStackTrace(this, Iy) : Object.defineProperty(this, "stack", {
      value: Error().stack,
      writable: !0,
      configurable: !0
    });
  }
  get [Symbol.toStringTag]() {
    return "GraphQLError";
  }
  toString() {
    let t = this.message;
    if (this.nodes)
      for (const n of this.nodes)
        n.loc && (t += `

` + Sz(n.loc));
    else if (this.source && this.locations)
      for (const n of this.locations)
        t += `

` + d1(this.source, n);
    return t;
  }
  toJSON() {
    const t = {
      message: this.message
    };
    return this.locations != null && (t.locations = this.locations), this.path != null && (t.path = this.path), this.extensions != null && Object.keys(this.extensions).length > 0 && (t.extensions = this.extensions), t;
  }
}
function Jw(e) {
  return e === void 0 || e.length === 0 ? void 0 : e;
}
function xt(e, t, n) {
  return new Iy(`Syntax Error: ${n}`, {
    source: e,
    positions: [t]
  });
}
class Cz {
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The Token at which this Node begins.
   */
  /**
   * The Token at which this Node ends.
   */
  /**
   * The Source document the AST represents.
   */
  constructor(t, n, r) {
    this.start = t.start, this.end = n.end, this.startToken = t, this.endToken = n, this.source = r;
  }
  get [Symbol.toStringTag]() {
    return "Location";
  }
  toJSON() {
    return {
      start: this.start,
      end: this.end
    };
  }
}
class h1 {
  /**
   * The kind of Token.
   */
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The 1-indexed line number on which this Token appears.
   */
  /**
   * The 1-indexed column number at which this Token begins.
   */
  /**
   * For non-punctuation tokens, represents the interpreted value of the token.
   *
   * Note: is undefined for punctuation tokens, but typed as string for
   * convenience in the parser.
   */
  /**
   * Tokens exist as nodes in a double-linked-list amongst all tokens
   * including ignored tokens. <SOF> is always the first node and <EOF>
   * the last.
   */
  constructor(t, n, r, a, i, o) {
    this.kind = t, this.start = n, this.end = r, this.line = a, this.column = i, this.value = o, this.prev = null, this.next = null;
  }
  get [Symbol.toStringTag]() {
    return "Token";
  }
  toJSON() {
    return {
      kind: this.kind,
      value: this.value,
      line: this.line,
      column: this.column
    };
  }
}
const p1 = {
  Name: [],
  Document: ["definitions"],
  OperationDefinition: [
    "description",
    "name",
    "variableDefinitions",
    "directives",
    "selectionSet"
  ],
  VariableDefinition: [
    "description",
    "variable",
    "type",
    "defaultValue",
    "directives"
  ],
  Variable: ["name"],
  SelectionSet: ["selections"],
  Field: ["alias", "name", "arguments", "directives", "selectionSet"],
  Argument: ["name", "value"],
  FragmentSpread: ["name", "directives"],
  InlineFragment: ["typeCondition", "directives", "selectionSet"],
  FragmentDefinition: [
    "description",
    "name",
    // Note: fragment variable definitions are deprecated and will removed in v17.0.0
    "variableDefinitions",
    "typeCondition",
    "directives",
    "selectionSet"
  ],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ["values"],
  ObjectValue: ["fields"],
  ObjectField: ["name", "value"],
  Directive: ["name", "arguments"],
  NamedType: ["name"],
  ListType: ["type"],
  NonNullType: ["type"],
  SchemaDefinition: ["description", "directives", "operationTypes"],
  OperationTypeDefinition: ["type"],
  ScalarTypeDefinition: ["description", "name", "directives"],
  ObjectTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  FieldDefinition: ["description", "name", "arguments", "type", "directives"],
  InputValueDefinition: [
    "description",
    "name",
    "type",
    "defaultValue",
    "directives"
  ],
  InterfaceTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  UnionTypeDefinition: ["description", "name", "directives", "types"],
  EnumTypeDefinition: ["description", "name", "directives", "values"],
  EnumValueDefinition: ["description", "name", "directives"],
  InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
  DirectiveDefinition: ["description", "name", "arguments", "locations"],
  SchemaExtension: ["directives", "operationTypes"],
  ScalarTypeExtension: ["name", "directives"],
  ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
  InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
  UnionTypeExtension: ["name", "directives", "types"],
  EnumTypeExtension: ["name", "directives", "values"],
  InputObjectTypeExtension: ["name", "directives", "fields"],
  TypeCoordinate: ["name"],
  MemberCoordinate: ["name", "memberName"],
  ArgumentCoordinate: ["name", "fieldName", "argumentName"],
  DirectiveCoordinate: ["name"],
  DirectiveArgumentCoordinate: ["name", "argumentName"]
}, Oz = new Set(Object.keys(p1));
function ex(e) {
  const t = e == null ? void 0 : e.kind;
  return typeof t == "string" && Oz.has(t);
}
var Ho;
(function(e) {
  e.QUERY = "query", e.MUTATION = "mutation", e.SUBSCRIPTION = "subscription";
})(Ho || (Ho = {}));
var Eg;
(function(e) {
  e.QUERY = "QUERY", e.MUTATION = "MUTATION", e.SUBSCRIPTION = "SUBSCRIPTION", e.FIELD = "FIELD", e.FRAGMENT_DEFINITION = "FRAGMENT_DEFINITION", e.FRAGMENT_SPREAD = "FRAGMENT_SPREAD", e.INLINE_FRAGMENT = "INLINE_FRAGMENT", e.VARIABLE_DEFINITION = "VARIABLE_DEFINITION", e.SCHEMA = "SCHEMA", e.SCALAR = "SCALAR", e.OBJECT = "OBJECT", e.FIELD_DEFINITION = "FIELD_DEFINITION", e.ARGUMENT_DEFINITION = "ARGUMENT_DEFINITION", e.INTERFACE = "INTERFACE", e.UNION = "UNION", e.ENUM = "ENUM", e.ENUM_VALUE = "ENUM_VALUE", e.INPUT_OBJECT = "INPUT_OBJECT", e.INPUT_FIELD_DEFINITION = "INPUT_FIELD_DEFINITION";
})(Eg || (Eg = {}));
var X;
(function(e) {
  e.NAME = "Name", e.DOCUMENT = "Document", e.OPERATION_DEFINITION = "OperationDefinition", e.VARIABLE_DEFINITION = "VariableDefinition", e.SELECTION_SET = "SelectionSet", e.FIELD = "Field", e.ARGUMENT = "Argument", e.FRAGMENT_SPREAD = "FragmentSpread", e.INLINE_FRAGMENT = "InlineFragment", e.FRAGMENT_DEFINITION = "FragmentDefinition", e.VARIABLE = "Variable", e.INT = "IntValue", e.FLOAT = "FloatValue", e.STRING = "StringValue", e.BOOLEAN = "BooleanValue", e.NULL = "NullValue", e.ENUM = "EnumValue", e.LIST = "ListValue", e.OBJECT = "ObjectValue", e.OBJECT_FIELD = "ObjectField", e.DIRECTIVE = "Directive", e.NAMED_TYPE = "NamedType", e.LIST_TYPE = "ListType", e.NON_NULL_TYPE = "NonNullType", e.SCHEMA_DEFINITION = "SchemaDefinition", e.OPERATION_TYPE_DEFINITION = "OperationTypeDefinition", e.SCALAR_TYPE_DEFINITION = "ScalarTypeDefinition", e.OBJECT_TYPE_DEFINITION = "ObjectTypeDefinition", e.FIELD_DEFINITION = "FieldDefinition", e.INPUT_VALUE_DEFINITION = "InputValueDefinition", e.INTERFACE_TYPE_DEFINITION = "InterfaceTypeDefinition", e.UNION_TYPE_DEFINITION = "UnionTypeDefinition", e.ENUM_TYPE_DEFINITION = "EnumTypeDefinition", e.ENUM_VALUE_DEFINITION = "EnumValueDefinition", e.INPUT_OBJECT_TYPE_DEFINITION = "InputObjectTypeDefinition", e.DIRECTIVE_DEFINITION = "DirectiveDefinition", e.SCHEMA_EXTENSION = "SchemaExtension", e.SCALAR_TYPE_EXTENSION = "ScalarTypeExtension", e.OBJECT_TYPE_EXTENSION = "ObjectTypeExtension", e.INTERFACE_TYPE_EXTENSION = "InterfaceTypeExtension", e.UNION_TYPE_EXTENSION = "UnionTypeExtension", e.ENUM_TYPE_EXTENSION = "EnumTypeExtension", e.INPUT_OBJECT_TYPE_EXTENSION = "InputObjectTypeExtension", e.TYPE_COORDINATE = "TypeCoordinate", e.MEMBER_COORDINATE = "MemberCoordinate", e.ARGUMENT_COORDINATE = "ArgumentCoordinate", e.DIRECTIVE_COORDINATE = "DirectiveCoordinate", e.DIRECTIVE_ARGUMENT_COORDINATE = "DirectiveArgumentCoordinate";
})(X || (X = {}));
function Sg(e) {
  return e === 9 || e === 32;
}
function _c(e) {
  return e >= 48 && e <= 57;
}
function m1(e) {
  return e >= 97 && e <= 122 || // A-Z
  e >= 65 && e <= 90;
}
function g1(e) {
  return m1(e) || e === 95;
}
function Az(e) {
  return m1(e) || _c(e) || e === 95;
}
function Rz(e) {
  var t;
  let n = Number.MAX_SAFE_INTEGER, r = null, a = -1;
  for (let o = 0; o < e.length; ++o) {
    var i;
    const s = e[o], l = _z(s);
    l !== s.length && (r = (i = r) !== null && i !== void 0 ? i : o, a = o, o !== 0 && l < n && (n = l));
  }
  return e.map((o, s) => s === 0 ? o : o.slice(n)).slice(
    (t = r) !== null && t !== void 0 ? t : 0,
    a + 1
  );
}
function _z(e) {
  let t = 0;
  for (; t < e.length && Sg(e.charCodeAt(t)); )
    ++t;
  return t;
}
function Dz(e, t) {
  const n = e.replace(/"""/g, '\\"""'), r = n.split(/\r\n|[\n\r]/g), a = r.length === 1, i = r.length > 1 && r.slice(1).every((h) => h.length === 0 || Sg(h.charCodeAt(0))), o = n.endsWith('\\"""'), s = e.endsWith('"') && !o, l = e.endsWith("\\"), c = s || l, u = (
    // add leading and trailing new lines only if it improves readability
    !a || e.length > 70 || c || i || o
  );
  let f = "";
  const d = a && Sg(e.charCodeAt(0));
  return (u && !d || i) && (f += `
`), f += n, (u || c) && (f += `
`), '"""' + f + '"""';
}
var B;
(function(e) {
  e.SOF = "<SOF>", e.EOF = "<EOF>", e.BANG = "!", e.DOLLAR = "$", e.AMP = "&", e.PAREN_L = "(", e.PAREN_R = ")", e.DOT = ".", e.SPREAD = "...", e.COLON = ":", e.EQUALS = "=", e.AT = "@", e.BRACKET_L = "[", e.BRACKET_R = "]", e.BRACE_L = "{", e.PIPE = "|", e.BRACE_R = "}", e.NAME = "Name", e.INT = "Int", e.FLOAT = "Float", e.STRING = "String", e.BLOCK_STRING = "BlockString", e.COMMENT = "Comment";
})(B || (B = {}));
class Nz {
  /**
   * The previously focused non-ignored token.
   */
  /**
   * The currently focused non-ignored token.
   */
  /**
   * The (1-indexed) line containing the current token.
   */
  /**
   * The character offset at which the current line begins.
   */
  constructor(t) {
    const n = new h1(B.SOF, 0, 0, 0, 0);
    this.source = t, this.lastToken = n, this.token = n, this.line = 1, this.lineStart = 0;
  }
  get [Symbol.toStringTag]() {
    return "Lexer";
  }
  /**
   * Advances the token stream to the next non-ignored token.
   */
  advance() {
    return this.lastToken = this.token, this.token = this.lookahead();
  }
  /**
   * Looks ahead and returns the next non-ignored token, but does not change
   * the state of Lexer.
   */
  lookahead() {
    let t = this.token;
    if (t.kind !== B.EOF)
      do
        if (t.next)
          t = t.next;
        else {
          const n = Mz(this, t.end);
          t.next = n, n.prev = t, t = n;
        }
      while (t.kind === B.COMMENT);
    return t;
  }
}
function kz(e) {
  return e === B.BANG || e === B.DOLLAR || e === B.AMP || e === B.PAREN_L || e === B.PAREN_R || e === B.DOT || e === B.SPREAD || e === B.COLON || e === B.EQUALS || e === B.AT || e === B.BRACKET_L || e === B.BRACKET_R || e === B.BRACE_L || e === B.PIPE || e === B.BRACE_R;
}
function Ws(e) {
  return e >= 0 && e <= 55295 || e >= 57344 && e <= 1114111;
}
function Zd(e, t) {
  return v1(e.charCodeAt(t)) && y1(e.charCodeAt(t + 1));
}
function v1(e) {
  return e >= 55296 && e <= 56319;
}
function y1(e) {
  return e >= 56320 && e <= 57343;
}
function Zi(e, t) {
  const n = e.source.body.codePointAt(t);
  if (n === void 0)
    return B.EOF;
  if (n >= 32 && n <= 126) {
    const r = String.fromCodePoint(n);
    return r === '"' ? `'"'` : `"${r}"`;
  }
  return "U+" + n.toString(16).toUpperCase().padStart(4, "0");
}
function dt(e, t, n, r, a) {
  const i = e.line, o = 1 + n - e.lineStart;
  return new h1(t, n, r, i, o, a);
}
function Mz(e, t) {
  const n = e.source.body, r = n.length;
  let a = t;
  for (; a < r; ) {
    const i = n.charCodeAt(a);
    switch (i) {
      case 65279:
      case 9:
      case 32:
      case 44:
        ++a;
        continue;
      case 10:
        ++a, ++e.line, e.lineStart = a;
        continue;
      case 13:
        n.charCodeAt(a + 1) === 10 ? a += 2 : ++a, ++e.line, e.lineStart = a;
        continue;
      case 35:
        return Lz(e, a);
      case 33:
        return dt(e, B.BANG, a, a + 1);
      case 36:
        return dt(e, B.DOLLAR, a, a + 1);
      case 38:
        return dt(e, B.AMP, a, a + 1);
      case 40:
        return dt(e, B.PAREN_L, a, a + 1);
      case 41:
        return dt(e, B.PAREN_R, a, a + 1);
      case 46:
        if (n.charCodeAt(a + 1) === 46 && n.charCodeAt(a + 2) === 46)
          return dt(e, B.SPREAD, a, a + 3);
        break;
      case 58:
        return dt(e, B.COLON, a, a + 1);
      case 61:
        return dt(e, B.EQUALS, a, a + 1);
      case 64:
        return dt(e, B.AT, a, a + 1);
      case 91:
        return dt(e, B.BRACKET_L, a, a + 1);
      case 93:
        return dt(e, B.BRACKET_R, a, a + 1);
      case 123:
        return dt(e, B.BRACE_L, a, a + 1);
      case 124:
        return dt(e, B.PIPE, a, a + 1);
      case 125:
        return dt(e, B.BRACE_R, a, a + 1);
      case 34:
        return n.charCodeAt(a + 1) === 34 && n.charCodeAt(a + 2) === 34 ? Uz(e, a) : jz(e, a);
    }
    if (_c(i) || i === 45)
      return zz(e, a, i);
    if (g1(i))
      return qz(e, a);
    throw xt(
      e.source,
      a,
      i === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : Ws(i) || Zd(n, a) ? `Unexpected character: ${Zi(e, a)}.` : `Invalid character: ${Zi(e, a)}.`
    );
  }
  return dt(e, B.EOF, r, r);
}
function Lz(e, t) {
  const n = e.source.body, r = n.length;
  let a = t + 1;
  for (; a < r; ) {
    const i = n.charCodeAt(a);
    if (i === 10 || i === 13)
      break;
    if (Ws(i))
      ++a;
    else if (Zd(n, a))
      a += 2;
    else
      break;
  }
  return dt(
    e,
    B.COMMENT,
    t,
    a,
    n.slice(t + 1, a)
  );
}
function zz(e, t, n) {
  const r = e.source.body;
  let a = t, i = n, o = !1;
  if (i === 45 && (i = r.charCodeAt(++a)), i === 48) {
    if (i = r.charCodeAt(++a), _c(i))
      throw xt(
        e.source,
        a,
        `Invalid number, unexpected digit after 0: ${Zi(
          e,
          a
        )}.`
      );
  } else
    a = vp(e, a, i), i = r.charCodeAt(a);
  if (i === 46 && (o = !0, i = r.charCodeAt(++a), a = vp(e, a, i), i = r.charCodeAt(a)), (i === 69 || i === 101) && (o = !0, i = r.charCodeAt(++a), (i === 43 || i === 45) && (i = r.charCodeAt(++a)), a = vp(e, a, i), i = r.charCodeAt(a)), i === 46 || g1(i))
    throw xt(
      e.source,
      a,
      `Invalid number, expected digit but got: ${Zi(
        e,
        a
      )}.`
    );
  return dt(
    e,
    o ? B.FLOAT : B.INT,
    t,
    a,
    r.slice(t, a)
  );
}
function vp(e, t, n) {
  if (!_c(n))
    throw xt(
      e.source,
      t,
      `Invalid number, expected digit but got: ${Zi(
        e,
        t
      )}.`
    );
  const r = e.source.body;
  let a = t + 1;
  for (; _c(r.charCodeAt(a)); )
    ++a;
  return a;
}
function jz(e, t) {
  const n = e.source.body, r = n.length;
  let a = t + 1, i = a, o = "";
  for (; a < r; ) {
    const s = n.charCodeAt(a);
    if (s === 34)
      return o += n.slice(i, a), dt(e, B.STRING, t, a + 1, o);
    if (s === 92) {
      o += n.slice(i, a);
      const l = n.charCodeAt(a + 1) === 117 ? n.charCodeAt(a + 2) === 123 ? Pz(e, a) : Iz(e, a) : Fz(e, a);
      o += l.value, a += l.size, i = a;
      continue;
    }
    if (s === 10 || s === 13)
      break;
    if (Ws(s))
      ++a;
    else if (Zd(n, a))
      a += 2;
    else
      throw xt(
        e.source,
        a,
        `Invalid character within String: ${Zi(
          e,
          a
        )}.`
      );
  }
  throw xt(e.source, a, "Unterminated string.");
}
function Pz(e, t) {
  const n = e.source.body;
  let r = 0, a = 3;
  for (; a < 12; ) {
    const i = n.charCodeAt(t + a++);
    if (i === 125) {
      if (a < 5 || !Ws(r))
        break;
      return {
        value: String.fromCodePoint(r),
        size: a
      };
    }
    if (r = r << 4 | Ul(i), r < 0)
      break;
  }
  throw xt(
    e.source,
    t,
    `Invalid Unicode escape sequence: "${n.slice(
      t,
      t + a
    )}".`
  );
}
function Iz(e, t) {
  const n = e.source.body, r = tx(n, t + 2);
  if (Ws(r))
    return {
      value: String.fromCodePoint(r),
      size: 6
    };
  if (v1(r) && n.charCodeAt(t + 6) === 92 && n.charCodeAt(t + 7) === 117) {
    const a = tx(n, t + 8);
    if (y1(a))
      return {
        value: String.fromCodePoint(r, a),
        size: 12
      };
  }
  throw xt(
    e.source,
    t,
    `Invalid Unicode escape sequence: "${n.slice(t, t + 6)}".`
  );
}
function tx(e, t) {
  return Ul(e.charCodeAt(t)) << 12 | Ul(e.charCodeAt(t + 1)) << 8 | Ul(e.charCodeAt(t + 2)) << 4 | Ul(e.charCodeAt(t + 3));
}
function Ul(e) {
  return e >= 48 && e <= 57 ? e - 48 : e >= 65 && e <= 70 ? e - 55 : e >= 97 && e <= 102 ? e - 87 : -1;
}
function Fz(e, t) {
  const n = e.source.body;
  switch (n.charCodeAt(t + 1)) {
    case 34:
      return {
        value: '"',
        size: 2
      };
    case 92:
      return {
        value: "\\",
        size: 2
      };
    case 47:
      return {
        value: "/",
        size: 2
      };
    case 98:
      return {
        value: "\b",
        size: 2
      };
    case 102:
      return {
        value: "\f",
        size: 2
      };
    case 110:
      return {
        value: `
`,
        size: 2
      };
    case 114:
      return {
        value: "\r",
        size: 2
      };
    case 116:
      return {
        value: "	",
        size: 2
      };
  }
  throw xt(
    e.source,
    t,
    `Invalid character escape sequence: "${n.slice(
      t,
      t + 2
    )}".`
  );
}
function Uz(e, t) {
  const n = e.source.body, r = n.length;
  let a = e.lineStart, i = t + 3, o = i, s = "";
  const l = [];
  for (; i < r; ) {
    const c = n.charCodeAt(i);
    if (c === 34 && n.charCodeAt(i + 1) === 34 && n.charCodeAt(i + 2) === 34) {
      s += n.slice(o, i), l.push(s);
      const u = dt(
        e,
        B.BLOCK_STRING,
        t,
        i + 3,
        // Return a string of the lines joined with U+000A.
        Rz(l).join(`
`)
      );
      return e.line += l.length - 1, e.lineStart = a, u;
    }
    if (c === 92 && n.charCodeAt(i + 1) === 34 && n.charCodeAt(i + 2) === 34 && n.charCodeAt(i + 3) === 34) {
      s += n.slice(o, i), o = i + 1, i += 4;
      continue;
    }
    if (c === 10 || c === 13) {
      s += n.slice(o, i), l.push(s), c === 13 && n.charCodeAt(i + 1) === 10 ? i += 2 : ++i, s = "", o = i, a = i;
      continue;
    }
    if (Ws(c))
      ++i;
    else if (Zd(n, i))
      i += 2;
    else
      throw xt(
        e.source,
        i,
        `Invalid character within String: ${Zi(
          e,
          i
        )}.`
      );
  }
  throw xt(e.source, i, "Unterminated string.");
}
function qz(e, t) {
  const n = e.source.body, r = n.length;
  let a = t + 1;
  for (; a < r; ) {
    const i = n.charCodeAt(a);
    if (Az(i))
      ++a;
    else
      break;
  }
  return dt(
    e,
    B.NAME,
    t,
    a,
    n.slice(t, a)
  );
}
const Bz = 10, b1 = 2;
function Fy(e) {
  return Jd(e, []);
}
function Jd(e, t) {
  switch (typeof e) {
    case "string":
      return JSON.stringify(e);
    case "function":
      return e.name ? `[function ${e.name}]` : "[function]";
    case "object":
      return Vz(e, t);
    default:
      return String(e);
  }
}
function Vz(e, t) {
  if (e === null)
    return "null";
  if (t.includes(e))
    return "[Circular]";
  const n = [...t, e];
  if (Qz(e)) {
    const r = e.toJSON();
    if (r !== e)
      return typeof r == "string" ? r : Jd(r, n);
  } else if (Array.isArray(e))
    return $z(e, n);
  return Hz(e, n);
}
function Qz(e) {
  return typeof e.toJSON == "function";
}
function Hz(e, t) {
  const n = Object.entries(e);
  return n.length === 0 ? "{}" : t.length > b1 ? "[" + Gz(e) + "]" : "{ " + n.map(
    ([a, i]) => a + ": " + Jd(i, t)
  ).join(", ") + " }";
}
function $z(e, t) {
  if (e.length === 0)
    return "[]";
  if (t.length > b1)
    return "[Array]";
  const n = Math.min(Bz, e.length), r = e.length - n, a = [];
  for (let i = 0; i < n; ++i)
    a.push(Jd(e[i], t));
  return r === 1 ? a.push("... 1 more item") : r > 1 && a.push(`... ${r} more items`), "[" + a.join(", ") + "]";
}
function Gz(e) {
  const t = Object.prototype.toString.call(e).replace(/^\[object /, "").replace(/]$/, "");
  if (t === "Object" && typeof e.constructor == "function") {
    const n = e.constructor.name;
    if (typeof n == "string" && n !== "")
      return n;
  }
  return t;
}
const Yz = globalThis.process && // eslint-disable-next-line no-undef
!0, Kz = (
  /* c8 ignore next 6 */
  // FIXME: https://github.com/graphql/graphql-js/issues/2317
  Yz ? function(t, n) {
    return t instanceof n;
  } : function(t, n) {
    if (t instanceof n)
      return !0;
    if (typeof t == "object" && t !== null) {
      var r;
      const a = n.prototype[Symbol.toStringTag], i = (
        // We still need to support constructor's name to detect conflicts with older versions of this library.
        Symbol.toStringTag in t ? t[Symbol.toStringTag] : (r = t.constructor) === null || r === void 0 ? void 0 : r.name
      );
      if (a === i) {
        const o = Fy(t);
        throw new Error(`Cannot use ${a} "${o}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
      }
    }
    return !1;
  }
);
class w1 {
  constructor(t, n = "GraphQL request", r = {
    line: 1,
    column: 1
  }) {
    typeof t == "string" || Tf(!1, `Body must be a string. Received: ${Fy(t)}.`), this.body = t, this.name = n, this.locationOffset = r, this.locationOffset.line > 0 || Tf(
      !1,
      "line in locationOffset is 1-indexed and must be positive."
    ), this.locationOffset.column > 0 || Tf(
      !1,
      "column in locationOffset is 1-indexed and must be positive."
    );
  }
  get [Symbol.toStringTag]() {
    return "Source";
  }
}
function Xz(e) {
  return Kz(e, w1);
}
function Wz(e, t) {
  const n = new Zz(e, t), r = n.parseDocument();
  return Object.defineProperty(r, "tokenCount", {
    enumerable: !1,
    value: n.tokenCount
  }), r;
}
class Zz {
  constructor(t, n = {}) {
    const { lexer: r, ...a } = n;
    if (r)
      this._lexer = r;
    else {
      const i = Xz(t) ? t : new w1(t);
      this._lexer = new Nz(i);
    }
    this._options = a, this._tokenCounter = 0;
  }
  get tokenCount() {
    return this._tokenCounter;
  }
  /**
   * Converts a name lex token into a name parse node.
   */
  parseName() {
    const t = this.expectToken(B.NAME);
    return this.node(t, {
      kind: X.NAME,
      value: t.value
    });
  }
  // Implements the parsing rules in the Document section.
  /**
   * Document : Definition+
   */
  parseDocument() {
    return this.node(this._lexer.token, {
      kind: X.DOCUMENT,
      definitions: this.many(
        B.SOF,
        this.parseDefinition,
        B.EOF
      )
    });
  }
  /**
   * Definition :
   *   - ExecutableDefinition
   *   - TypeSystemDefinition
   *   - TypeSystemExtension
   *
   * ExecutableDefinition :
   *   - OperationDefinition
   *   - FragmentDefinition
   *
   * TypeSystemDefinition :
   *   - SchemaDefinition
   *   - TypeDefinition
   *   - DirectiveDefinition
   *
   * TypeDefinition :
   *   - ScalarTypeDefinition
   *   - ObjectTypeDefinition
   *   - InterfaceTypeDefinition
   *   - UnionTypeDefinition
   *   - EnumTypeDefinition
   *   - InputObjectTypeDefinition
   */
  parseDefinition() {
    if (this.peek(B.BRACE_L))
      return this.parseOperationDefinition();
    const t = this.peekDescription(), n = t ? this._lexer.lookahead() : this._lexer.token;
    if (t && n.kind === B.BRACE_L)
      throw xt(
        this._lexer.source,
        this._lexer.token.start,
        "Unexpected description, descriptions are not supported on shorthand queries."
      );
    if (n.kind === B.NAME) {
      switch (n.value) {
        case "schema":
          return this.parseSchemaDefinition();
        case "scalar":
          return this.parseScalarTypeDefinition();
        case "type":
          return this.parseObjectTypeDefinition();
        case "interface":
          return this.parseInterfaceTypeDefinition();
        case "union":
          return this.parseUnionTypeDefinition();
        case "enum":
          return this.parseEnumTypeDefinition();
        case "input":
          return this.parseInputObjectTypeDefinition();
        case "directive":
          return this.parseDirectiveDefinition();
      }
      switch (n.value) {
        case "query":
        case "mutation":
        case "subscription":
          return this.parseOperationDefinition();
        case "fragment":
          return this.parseFragmentDefinition();
      }
      if (t)
        throw xt(
          this._lexer.source,
          this._lexer.token.start,
          "Unexpected description, only GraphQL definitions support descriptions."
        );
      switch (n.value) {
        case "extend":
          return this.parseTypeSystemExtension();
      }
    }
    throw this.unexpected(n);
  }
  // Implements the parsing rules in the Operations section.
  /**
   * OperationDefinition :
   *  - SelectionSet
   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet
   */
  parseOperationDefinition() {
    const t = this._lexer.token;
    if (this.peek(B.BRACE_L))
      return this.node(t, {
        kind: X.OPERATION_DEFINITION,
        operation: Ho.QUERY,
        description: void 0,
        name: void 0,
        variableDefinitions: [],
        directives: [],
        selectionSet: this.parseSelectionSet()
      });
    const n = this.parseDescription(), r = this.parseOperationType();
    let a;
    return this.peek(B.NAME) && (a = this.parseName()), this.node(t, {
      kind: X.OPERATION_DEFINITION,
      operation: r,
      description: n,
      name: a,
      variableDefinitions: this.parseVariableDefinitions(),
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * OperationType : one of query mutation subscription
   */
  parseOperationType() {
    const t = this.expectToken(B.NAME);
    switch (t.value) {
      case "query":
        return Ho.QUERY;
      case "mutation":
        return Ho.MUTATION;
      case "subscription":
        return Ho.SUBSCRIPTION;
    }
    throw this.unexpected(t);
  }
  /**
   * VariableDefinitions : ( VariableDefinition+ )
   */
  parseVariableDefinitions() {
    return this.optionalMany(
      B.PAREN_L,
      this.parseVariableDefinition,
      B.PAREN_R
    );
  }
  /**
   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?
   */
  parseVariableDefinition() {
    return this.node(this._lexer.token, {
      kind: X.VARIABLE_DEFINITION,
      description: this.parseDescription(),
      variable: this.parseVariable(),
      type: (this.expectToken(B.COLON), this.parseTypeReference()),
      defaultValue: this.expectOptionalToken(B.EQUALS) ? this.parseConstValueLiteral() : void 0,
      directives: this.parseConstDirectives()
    });
  }
  /**
   * Variable : $ Name
   */
  parseVariable() {
    const t = this._lexer.token;
    return this.expectToken(B.DOLLAR), this.node(t, {
      kind: X.VARIABLE,
      name: this.parseName()
    });
  }
  /**
   * ```
   * SelectionSet : { Selection+ }
   * ```
   */
  parseSelectionSet() {
    return this.node(this._lexer.token, {
      kind: X.SELECTION_SET,
      selections: this.many(
        B.BRACE_L,
        this.parseSelection,
        B.BRACE_R
      )
    });
  }
  /**
   * Selection :
   *   - Field
   *   - FragmentSpread
   *   - InlineFragment
   */
  parseSelection() {
    return this.peek(B.SPREAD) ? this.parseFragment() : this.parseField();
  }
  /**
   * Field : Alias? Name Arguments? Directives? SelectionSet?
   *
   * Alias : Name :
   */
  parseField() {
    const t = this._lexer.token, n = this.parseName();
    let r, a;
    return this.expectOptionalToken(B.COLON) ? (r = n, a = this.parseName()) : a = n, this.node(t, {
      kind: X.FIELD,
      alias: r,
      name: a,
      arguments: this.parseArguments(!1),
      directives: this.parseDirectives(!1),
      selectionSet: this.peek(B.BRACE_L) ? this.parseSelectionSet() : void 0
    });
  }
  /**
   * Arguments[Const] : ( Argument[?Const]+ )
   */
  parseArguments(t) {
    const n = t ? this.parseConstArgument : this.parseArgument;
    return this.optionalMany(B.PAREN_L, n, B.PAREN_R);
  }
  /**
   * Argument[Const] : Name : Value[?Const]
   */
  parseArgument(t = !1) {
    const n = this._lexer.token, r = this.parseName();
    return this.expectToken(B.COLON), this.node(n, {
      kind: X.ARGUMENT,
      name: r,
      value: this.parseValueLiteral(t)
    });
  }
  parseConstArgument() {
    return this.parseArgument(!0);
  }
  // Implements the parsing rules in the Fragments section.
  /**
   * Corresponds to both FragmentSpread and InlineFragment in the spec.
   *
   * FragmentSpread : ... FragmentName Directives?
   *
   * InlineFragment : ... TypeCondition? Directives? SelectionSet
   */
  parseFragment() {
    const t = this._lexer.token;
    this.expectToken(B.SPREAD);
    const n = this.expectOptionalKeyword("on");
    return !n && this.peek(B.NAME) ? this.node(t, {
      kind: X.FRAGMENT_SPREAD,
      name: this.parseFragmentName(),
      directives: this.parseDirectives(!1)
    }) : this.node(t, {
      kind: X.INLINE_FRAGMENT,
      typeCondition: n ? this.parseNamedType() : void 0,
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * FragmentDefinition :
   *   - fragment FragmentName on TypeCondition Directives? SelectionSet
   *
   * TypeCondition : NamedType
   */
  parseFragmentDefinition() {
    const t = this._lexer.token, n = this.parseDescription();
    return this.expectKeyword("fragment"), this._options.allowLegacyFragmentVariables === !0 ? this.node(t, {
      kind: X.FRAGMENT_DEFINITION,
      description: n,
      name: this.parseFragmentName(),
      variableDefinitions: this.parseVariableDefinitions(),
      typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    }) : this.node(t, {
      kind: X.FRAGMENT_DEFINITION,
      description: n,
      name: this.parseFragmentName(),
      typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * FragmentName : Name but not `on`
   */
  parseFragmentName() {
    if (this._lexer.token.value === "on")
      throw this.unexpected();
    return this.parseName();
  }
  // Implements the parsing rules in the Values section.
  /**
   * Value[Const] :
   *   - [~Const] Variable
   *   - IntValue
   *   - FloatValue
   *   - StringValue
   *   - BooleanValue
   *   - NullValue
   *   - EnumValue
   *   - ListValue[?Const]
   *   - ObjectValue[?Const]
   *
   * BooleanValue : one of `true` `false`
   *
   * NullValue : `null`
   *
   * EnumValue : Name but not `true`, `false` or `null`
   */
  parseValueLiteral(t) {
    const n = this._lexer.token;
    switch (n.kind) {
      case B.BRACKET_L:
        return this.parseList(t);
      case B.BRACE_L:
        return this.parseObject(t);
      case B.INT:
        return this.advanceLexer(), this.node(n, {
          kind: X.INT,
          value: n.value
        });
      case B.FLOAT:
        return this.advanceLexer(), this.node(n, {
          kind: X.FLOAT,
          value: n.value
        });
      case B.STRING:
      case B.BLOCK_STRING:
        return this.parseStringLiteral();
      case B.NAME:
        switch (this.advanceLexer(), n.value) {
          case "true":
            return this.node(n, {
              kind: X.BOOLEAN,
              value: !0
            });
          case "false":
            return this.node(n, {
              kind: X.BOOLEAN,
              value: !1
            });
          case "null":
            return this.node(n, {
              kind: X.NULL
            });
          default:
            return this.node(n, {
              kind: X.ENUM,
              value: n.value
            });
        }
      case B.DOLLAR:
        if (t)
          if (this.expectToken(B.DOLLAR), this._lexer.token.kind === B.NAME) {
            const r = this._lexer.token.value;
            throw xt(
              this._lexer.source,
              n.start,
              `Unexpected variable "$${r}" in constant value.`
            );
          } else
            throw this.unexpected(n);
        return this.parseVariable();
      default:
        throw this.unexpected();
    }
  }
  parseConstValueLiteral() {
    return this.parseValueLiteral(!0);
  }
  parseStringLiteral() {
    const t = this._lexer.token;
    return this.advanceLexer(), this.node(t, {
      kind: X.STRING,
      value: t.value,
      block: t.kind === B.BLOCK_STRING
    });
  }
  /**
   * ListValue[Const] :
   *   - [ ]
   *   - [ Value[?Const]+ ]
   */
  parseList(t) {
    const n = () => this.parseValueLiteral(t);
    return this.node(this._lexer.token, {
      kind: X.LIST,
      values: this.any(B.BRACKET_L, n, B.BRACKET_R)
    });
  }
  /**
   * ```
   * ObjectValue[Const] :
   *   - { }
   *   - { ObjectField[?Const]+ }
   * ```
   */
  parseObject(t) {
    const n = () => this.parseObjectField(t);
    return this.node(this._lexer.token, {
      kind: X.OBJECT,
      fields: this.any(B.BRACE_L, n, B.BRACE_R)
    });
  }
  /**
   * ObjectField[Const] : Name : Value[?Const]
   */
  parseObjectField(t) {
    const n = this._lexer.token, r = this.parseName();
    return this.expectToken(B.COLON), this.node(n, {
      kind: X.OBJECT_FIELD,
      name: r,
      value: this.parseValueLiteral(t)
    });
  }
  // Implements the parsing rules in the Directives section.
  /**
   * Directives[Const] : Directive[?Const]+
   */
  parseDirectives(t) {
    const n = [];
    for (; this.peek(B.AT); )
      n.push(this.parseDirective(t));
    return n;
  }
  parseConstDirectives() {
    return this.parseDirectives(!0);
  }
  /**
   * ```
   * Directive[Const] : @ Name Arguments[?Const]?
   * ```
   */
  parseDirective(t) {
    const n = this._lexer.token;
    return this.expectToken(B.AT), this.node(n, {
      kind: X.DIRECTIVE,
      name: this.parseName(),
      arguments: this.parseArguments(t)
    });
  }
  // Implements the parsing rules in the Types section.
  /**
   * Type :
   *   - NamedType
   *   - ListType
   *   - NonNullType
   */
  parseTypeReference() {
    const t = this._lexer.token;
    let n;
    if (this.expectOptionalToken(B.BRACKET_L)) {
      const r = this.parseTypeReference();
      this.expectToken(B.BRACKET_R), n = this.node(t, {
        kind: X.LIST_TYPE,
        type: r
      });
    } else
      n = this.parseNamedType();
    return this.expectOptionalToken(B.BANG) ? this.node(t, {
      kind: X.NON_NULL_TYPE,
      type: n
    }) : n;
  }
  /**
   * NamedType : Name
   */
  parseNamedType() {
    return this.node(this._lexer.token, {
      kind: X.NAMED_TYPE,
      name: this.parseName()
    });
  }
  // Implements the parsing rules in the Type Definition section.
  peekDescription() {
    return this.peek(B.STRING) || this.peek(B.BLOCK_STRING);
  }
  /**
   * Description : StringValue
   */
  parseDescription() {
    if (this.peekDescription())
      return this.parseStringLiteral();
  }
  /**
   * ```
   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }
   * ```
   */
  parseSchemaDefinition() {
    const t = this._lexer.token, n = this.parseDescription();
    this.expectKeyword("schema");
    const r = this.parseConstDirectives(), a = this.many(
      B.BRACE_L,
      this.parseOperationTypeDefinition,
      B.BRACE_R
    );
    return this.node(t, {
      kind: X.SCHEMA_DEFINITION,
      description: n,
      directives: r,
      operationTypes: a
    });
  }
  /**
   * OperationTypeDefinition : OperationType : NamedType
   */
  parseOperationTypeDefinition() {
    const t = this._lexer.token, n = this.parseOperationType();
    this.expectToken(B.COLON);
    const r = this.parseNamedType();
    return this.node(t, {
      kind: X.OPERATION_TYPE_DEFINITION,
      operation: n,
      type: r
    });
  }
  /**
   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?
   */
  parseScalarTypeDefinition() {
    const t = this._lexer.token, n = this.parseDescription();
    this.expectKeyword("scalar");
    const r = this.parseName(), a = this.parseConstDirectives();
    return this.node(t, {
      kind: X.SCALAR_TYPE_DEFINITION,
      description: n,
      name: r,
      directives: a
    });
  }
  /**
   * ObjectTypeDefinition :
   *   Description?
   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?
   */
  parseObjectTypeDefinition() {
    const t = this._lexer.token, n = this.parseDescription();
    this.expectKeyword("type");
    const r = this.parseName(), a = this.parseImplementsInterfaces(), i = this.parseConstDirectives(), o = this.parseFieldsDefinition();
    return this.node(t, {
      kind: X.OBJECT_TYPE_DEFINITION,
      description: n,
      name: r,
      interfaces: a,
      directives: i,
      fields: o
    });
  }
  /**
   * ImplementsInterfaces :
   *   - implements `&`? NamedType
   *   - ImplementsInterfaces & NamedType
   */
  parseImplementsInterfaces() {
    return this.expectOptionalKeyword("implements") ? this.delimitedMany(B.AMP, this.parseNamedType) : [];
  }
  /**
   * ```
   * FieldsDefinition : { FieldDefinition+ }
   * ```
   */
  parseFieldsDefinition() {
    return this.optionalMany(
      B.BRACE_L,
      this.parseFieldDefinition,
      B.BRACE_R
    );
  }
  /**
   * FieldDefinition :
   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?
   */
  parseFieldDefinition() {
    const t = this._lexer.token, n = this.parseDescription(), r = this.parseName(), a = this.parseArgumentDefs();
    this.expectToken(B.COLON);
    const i = this.parseTypeReference(), o = this.parseConstDirectives();
    return this.node(t, {
      kind: X.FIELD_DEFINITION,
      description: n,
      name: r,
      arguments: a,
      type: i,
      directives: o
    });
  }
  /**
   * ArgumentsDefinition : ( InputValueDefinition+ )
   */
  parseArgumentDefs() {
    return this.optionalMany(
      B.PAREN_L,
      this.parseInputValueDef,
      B.PAREN_R
    );
  }
  /**
   * InputValueDefinition :
   *   - Description? Name : Type DefaultValue? Directives[Const]?
   */
  parseInputValueDef() {
    const t = this._lexer.token, n = this.parseDescription(), r = this.parseName();
    this.expectToken(B.COLON);
    const a = this.parseTypeReference();
    let i;
    this.expectOptionalToken(B.EQUALS) && (i = this.parseConstValueLiteral());
    const o = this.parseConstDirectives();
    return this.node(t, {
      kind: X.INPUT_VALUE_DEFINITION,
      description: n,
      name: r,
      type: a,
      defaultValue: i,
      directives: o
    });
  }
  /**
   * InterfaceTypeDefinition :
   *   - Description? interface Name Directives[Const]? FieldsDefinition?
   */
  parseInterfaceTypeDefinition() {
    const t = this._lexer.token, n = this.parseDescription();
    this.expectKeyword("interface");
    const r = this.parseName(), a = this.parseImplementsInterfaces(), i = this.parseConstDirectives(), o = this.parseFieldsDefinition();
    return this.node(t, {
      kind: X.INTERFACE_TYPE_DEFINITION,
      description: n,
      name: r,
      interfaces: a,
      directives: i,
      fields: o
    });
  }
  /**
   * UnionTypeDefinition :
   *   - Description? union Name Directives[Const]? UnionMemberTypes?
   */
  parseUnionTypeDefinition() {
    const t = this._lexer.token, n = this.parseDescription();
    this.expectKeyword("union");
    const r = this.parseName(), a = this.parseConstDirectives(), i = this.parseUnionMemberTypes();
    return this.node(t, {
      kind: X.UNION_TYPE_DEFINITION,
      description: n,
      name: r,
      directives: a,
      types: i
    });
  }
  /**
   * UnionMemberTypes :
   *   - = `|`? NamedType
   *   - UnionMemberTypes | NamedType
   */
  parseUnionMemberTypes() {
    return this.expectOptionalToken(B.EQUALS) ? this.delimitedMany(B.PIPE, this.parseNamedType) : [];
  }
  /**
   * EnumTypeDefinition :
   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?
   */
  parseEnumTypeDefinition() {
    const t = this._lexer.token, n = this.parseDescription();
    this.expectKeyword("enum");
    const r = this.parseName(), a = this.parseConstDirectives(), i = this.parseEnumValuesDefinition();
    return this.node(t, {
      kind: X.ENUM_TYPE_DEFINITION,
      description: n,
      name: r,
      directives: a,
      values: i
    });
  }
  /**
   * ```
   * EnumValuesDefinition : { EnumValueDefinition+ }
   * ```
   */
  parseEnumValuesDefinition() {
    return this.optionalMany(
      B.BRACE_L,
      this.parseEnumValueDefinition,
      B.BRACE_R
    );
  }
  /**
   * EnumValueDefinition : Description? EnumValue Directives[Const]?
   */
  parseEnumValueDefinition() {
    const t = this._lexer.token, n = this.parseDescription(), r = this.parseEnumValueName(), a = this.parseConstDirectives();
    return this.node(t, {
      kind: X.ENUM_VALUE_DEFINITION,
      description: n,
      name: r,
      directives: a
    });
  }
  /**
   * EnumValue : Name but not `true`, `false` or `null`
   */
  parseEnumValueName() {
    if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null")
      throw xt(
        this._lexer.source,
        this._lexer.token.start,
        `${Ku(
          this._lexer.token
        )} is reserved and cannot be used for an enum value.`
      );
    return this.parseName();
  }
  /**
   * InputObjectTypeDefinition :
   *   - Description? input Name Directives[Const]? InputFieldsDefinition?
   */
  parseInputObjectTypeDefinition() {
    const t = this._lexer.token, n = this.parseDescription();
    this.expectKeyword("input");
    const r = this.parseName(), a = this.parseConstDirectives(), i = this.parseInputFieldsDefinition();
    return this.node(t, {
      kind: X.INPUT_OBJECT_TYPE_DEFINITION,
      description: n,
      name: r,
      directives: a,
      fields: i
    });
  }
  /**
   * ```
   * InputFieldsDefinition : { InputValueDefinition+ }
   * ```
   */
  parseInputFieldsDefinition() {
    return this.optionalMany(
      B.BRACE_L,
      this.parseInputValueDef,
      B.BRACE_R
    );
  }
  /**
   * TypeSystemExtension :
   *   - SchemaExtension
   *   - TypeExtension
   *
   * TypeExtension :
   *   - ScalarTypeExtension
   *   - ObjectTypeExtension
   *   - InterfaceTypeExtension
   *   - UnionTypeExtension
   *   - EnumTypeExtension
   *   - InputObjectTypeDefinition
   */
  parseTypeSystemExtension() {
    const t = this._lexer.lookahead();
    if (t.kind === B.NAME)
      switch (t.value) {
        case "schema":
          return this.parseSchemaExtension();
        case "scalar":
          return this.parseScalarTypeExtension();
        case "type":
          return this.parseObjectTypeExtension();
        case "interface":
          return this.parseInterfaceTypeExtension();
        case "union":
          return this.parseUnionTypeExtension();
        case "enum":
          return this.parseEnumTypeExtension();
        case "input":
          return this.parseInputObjectTypeExtension();
      }
    throw this.unexpected(t);
  }
  /**
   * ```
   * SchemaExtension :
   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }
   *  - extend schema Directives[Const]
   * ```
   */
  parseSchemaExtension() {
    const t = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("schema");
    const n = this.parseConstDirectives(), r = this.optionalMany(
      B.BRACE_L,
      this.parseOperationTypeDefinition,
      B.BRACE_R
    );
    if (n.length === 0 && r.length === 0)
      throw this.unexpected();
    return this.node(t, {
      kind: X.SCHEMA_EXTENSION,
      directives: n,
      operationTypes: r
    });
  }
  /**
   * ScalarTypeExtension :
   *   - extend scalar Name Directives[Const]
   */
  parseScalarTypeExtension() {
    const t = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("scalar");
    const n = this.parseName(), r = this.parseConstDirectives();
    if (r.length === 0)
      throw this.unexpected();
    return this.node(t, {
      kind: X.SCALAR_TYPE_EXTENSION,
      name: n,
      directives: r
    });
  }
  /**
   * ObjectTypeExtension :
   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend type Name ImplementsInterfaces? Directives[Const]
   *  - extend type Name ImplementsInterfaces
   */
  parseObjectTypeExtension() {
    const t = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("type");
    const n = this.parseName(), r = this.parseImplementsInterfaces(), a = this.parseConstDirectives(), i = this.parseFieldsDefinition();
    if (r.length === 0 && a.length === 0 && i.length === 0)
      throw this.unexpected();
    return this.node(t, {
      kind: X.OBJECT_TYPE_EXTENSION,
      name: n,
      interfaces: r,
      directives: a,
      fields: i
    });
  }
  /**
   * InterfaceTypeExtension :
   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend interface Name ImplementsInterfaces? Directives[Const]
   *  - extend interface Name ImplementsInterfaces
   */
  parseInterfaceTypeExtension() {
    const t = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("interface");
    const n = this.parseName(), r = this.parseImplementsInterfaces(), a = this.parseConstDirectives(), i = this.parseFieldsDefinition();
    if (r.length === 0 && a.length === 0 && i.length === 0)
      throw this.unexpected();
    return this.node(t, {
      kind: X.INTERFACE_TYPE_EXTENSION,
      name: n,
      interfaces: r,
      directives: a,
      fields: i
    });
  }
  /**
   * UnionTypeExtension :
   *   - extend union Name Directives[Const]? UnionMemberTypes
   *   - extend union Name Directives[Const]
   */
  parseUnionTypeExtension() {
    const t = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("union");
    const n = this.parseName(), r = this.parseConstDirectives(), a = this.parseUnionMemberTypes();
    if (r.length === 0 && a.length === 0)
      throw this.unexpected();
    return this.node(t, {
      kind: X.UNION_TYPE_EXTENSION,
      name: n,
      directives: r,
      types: a
    });
  }
  /**
   * EnumTypeExtension :
   *   - extend enum Name Directives[Const]? EnumValuesDefinition
   *   - extend enum Name Directives[Const]
   */
  parseEnumTypeExtension() {
    const t = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("enum");
    const n = this.parseName(), r = this.parseConstDirectives(), a = this.parseEnumValuesDefinition();
    if (r.length === 0 && a.length === 0)
      throw this.unexpected();
    return this.node(t, {
      kind: X.ENUM_TYPE_EXTENSION,
      name: n,
      directives: r,
      values: a
    });
  }
  /**
   * InputObjectTypeExtension :
   *   - extend input Name Directives[Const]? InputFieldsDefinition
   *   - extend input Name Directives[Const]
   */
  parseInputObjectTypeExtension() {
    const t = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("input");
    const n = this.parseName(), r = this.parseConstDirectives(), a = this.parseInputFieldsDefinition();
    if (r.length === 0 && a.length === 0)
      throw this.unexpected();
    return this.node(t, {
      kind: X.INPUT_OBJECT_TYPE_EXTENSION,
      name: n,
      directives: r,
      fields: a
    });
  }
  /**
   * ```
   * DirectiveDefinition :
   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations
   * ```
   */
  parseDirectiveDefinition() {
    const t = this._lexer.token, n = this.parseDescription();
    this.expectKeyword("directive"), this.expectToken(B.AT);
    const r = this.parseName(), a = this.parseArgumentDefs(), i = this.expectOptionalKeyword("repeatable");
    this.expectKeyword("on");
    const o = this.parseDirectiveLocations();
    return this.node(t, {
      kind: X.DIRECTIVE_DEFINITION,
      description: n,
      name: r,
      arguments: a,
      repeatable: i,
      locations: o
    });
  }
  /**
   * DirectiveLocations :
   *   - `|`? DirectiveLocation
   *   - DirectiveLocations | DirectiveLocation
   */
  parseDirectiveLocations() {
    return this.delimitedMany(B.PIPE, this.parseDirectiveLocation);
  }
  /*
   * DirectiveLocation :
   *   - ExecutableDirectiveLocation
   *   - TypeSystemDirectiveLocation
   *
   * ExecutableDirectiveLocation : one of
   *   `QUERY`
   *   `MUTATION`
   *   `SUBSCRIPTION`
   *   `FIELD`
   *   `FRAGMENT_DEFINITION`
   *   `FRAGMENT_SPREAD`
   *   `INLINE_FRAGMENT`
   *
   * TypeSystemDirectiveLocation : one of
   *   `SCHEMA`
   *   `SCALAR`
   *   `OBJECT`
   *   `FIELD_DEFINITION`
   *   `ARGUMENT_DEFINITION`
   *   `INTERFACE`
   *   `UNION`
   *   `ENUM`
   *   `ENUM_VALUE`
   *   `INPUT_OBJECT`
   *   `INPUT_FIELD_DEFINITION`
   */
  parseDirectiveLocation() {
    const t = this._lexer.token, n = this.parseName();
    if (Object.prototype.hasOwnProperty.call(Eg, n.value))
      return n;
    throw this.unexpected(t);
  }
  // Schema Coordinates
  /**
   * SchemaCoordinate :
   *   - Name
   *   - Name . Name
   *   - Name . Name ( Name : )
   *   - \@ Name
   *   - \@ Name ( Name : )
   */
  parseSchemaCoordinate() {
    const t = this._lexer.token, n = this.expectOptionalToken(B.AT), r = this.parseName();
    let a;
    !n && this.expectOptionalToken(B.DOT) && (a = this.parseName());
    let i;
    return (n || a) && this.expectOptionalToken(B.PAREN_L) && (i = this.parseName(), this.expectToken(B.COLON), this.expectToken(B.PAREN_R)), n ? i ? this.node(t, {
      kind: X.DIRECTIVE_ARGUMENT_COORDINATE,
      name: r,
      argumentName: i
    }) : this.node(t, {
      kind: X.DIRECTIVE_COORDINATE,
      name: r
    }) : a ? i ? this.node(t, {
      kind: X.ARGUMENT_COORDINATE,
      name: r,
      fieldName: a,
      argumentName: i
    }) : this.node(t, {
      kind: X.MEMBER_COORDINATE,
      name: r,
      memberName: a
    }) : this.node(t, {
      kind: X.TYPE_COORDINATE,
      name: r
    });
  }
  // Core parsing utility functions
  /**
   * Returns a node that, if configured to do so, sets a "loc" field as a
   * location object, used to identify the place in the source that created a
   * given parsed object.
   */
  node(t, n) {
    return this._options.noLocation !== !0 && (n.loc = new Cz(
      t,
      this._lexer.lastToken,
      this._lexer.source
    )), n;
  }
  /**
   * Determines if the next token is of a given kind
   */
  peek(t) {
    return this._lexer.token.kind === t;
  }
  /**
   * If the next token is of the given kind, return that token after advancing the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */
  expectToken(t) {
    const n = this._lexer.token;
    if (n.kind === t)
      return this.advanceLexer(), n;
    throw xt(
      this._lexer.source,
      n.start,
      `Expected ${x1(t)}, found ${Ku(n)}.`
    );
  }
  /**
   * If the next token is of the given kind, return "true" after advancing the lexer.
   * Otherwise, do not change the parser state and return "false".
   */
  expectOptionalToken(t) {
    return this._lexer.token.kind === t ? (this.advanceLexer(), !0) : !1;
  }
  /**
   * If the next token is a given keyword, advance the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */
  expectKeyword(t) {
    const n = this._lexer.token;
    if (n.kind === B.NAME && n.value === t)
      this.advanceLexer();
    else
      throw xt(
        this._lexer.source,
        n.start,
        `Expected "${t}", found ${Ku(n)}.`
      );
  }
  /**
   * If the next token is a given keyword, return "true" after advancing the lexer.
   * Otherwise, do not change the parser state and return "false".
   */
  expectOptionalKeyword(t) {
    const n = this._lexer.token;
    return n.kind === B.NAME && n.value === t ? (this.advanceLexer(), !0) : !1;
  }
  /**
   * Helper function for creating an error when an unexpected lexed token is encountered.
   */
  unexpected(t) {
    const n = t ?? this._lexer.token;
    return xt(
      this._lexer.source,
      n.start,
      `Unexpected ${Ku(n)}.`
    );
  }
  /**
   * Returns a possibly empty list of parse nodes, determined by the parseFn.
   * This list begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  any(t, n, r) {
    this.expectToken(t);
    const a = [];
    for (; !this.expectOptionalToken(r); )
      a.push(n.call(this));
    return a;
  }
  /**
   * Returns a list of parse nodes, determined by the parseFn.
   * It can be empty only if open token is missing otherwise it will always return non-empty list
   * that begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  optionalMany(t, n, r) {
    if (this.expectOptionalToken(t)) {
      const a = [];
      do
        a.push(n.call(this));
      while (!this.expectOptionalToken(r));
      return a;
    }
    return [];
  }
  /**
   * Returns a non-empty list of parse nodes, determined by the parseFn.
   * This list begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  many(t, n, r) {
    this.expectToken(t);
    const a = [];
    do
      a.push(n.call(this));
    while (!this.expectOptionalToken(r));
    return a;
  }
  /**
   * Returns a non-empty list of parse nodes, determined by the parseFn.
   * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.
   * Advances the parser to the next lex token after last item in the list.
   */
  delimitedMany(t, n) {
    this.expectOptionalToken(t);
    const r = [];
    do
      r.push(n.call(this));
    while (this.expectOptionalToken(t));
    return r;
  }
  advanceLexer() {
    const { maxTokens: t } = this._options, n = this._lexer.advance();
    if (n.kind !== B.EOF && (++this._tokenCounter, t !== void 0 && this._tokenCounter > t))
      throw xt(
        this._lexer.source,
        n.start,
        `Document contains more that ${t} tokens. Parsing aborted.`
      );
  }
}
function Ku(e) {
  const t = e.value;
  return x1(e.kind) + (t != null ? ` "${t}"` : "");
}
function x1(e) {
  return kz(e) ? `"${e}"` : e;
}
function Jz(e) {
  return `"${e.replace(ej, tj)}"`;
}
const ej = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
function tj(e) {
  return nj[e.charCodeAt(0)];
}
const nj = [
  "\\u0000",
  "\\u0001",
  "\\u0002",
  "\\u0003",
  "\\u0004",
  "\\u0005",
  "\\u0006",
  "\\u0007",
  "\\b",
  "\\t",
  "\\n",
  "\\u000B",
  "\\f",
  "\\r",
  "\\u000E",
  "\\u000F",
  "\\u0010",
  "\\u0011",
  "\\u0012",
  "\\u0013",
  "\\u0014",
  "\\u0015",
  "\\u0016",
  "\\u0017",
  "\\u0018",
  "\\u0019",
  "\\u001A",
  "\\u001B",
  "\\u001C",
  "\\u001D",
  "\\u001E",
  "\\u001F",
  "",
  "",
  '\\"',
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 2F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 3F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 4F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\\\",
  "",
  "",
  "",
  // 5F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 6F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\u007F",
  "\\u0080",
  "\\u0081",
  "\\u0082",
  "\\u0083",
  "\\u0084",
  "\\u0085",
  "\\u0086",
  "\\u0087",
  "\\u0088",
  "\\u0089",
  "\\u008A",
  "\\u008B",
  "\\u008C",
  "\\u008D",
  "\\u008E",
  "\\u008F",
  "\\u0090",
  "\\u0091",
  "\\u0092",
  "\\u0093",
  "\\u0094",
  "\\u0095",
  "\\u0096",
  "\\u0097",
  "\\u0098",
  "\\u0099",
  "\\u009A",
  "\\u009B",
  "\\u009C",
  "\\u009D",
  "\\u009E",
  "\\u009F"
], eh = Object.freeze({});
function Vn(e, t, n = p1) {
  const r = /* @__PURE__ */ new Map();
  for (const p of Object.values(X))
    r.set(p, rj(t, p));
  let a, i = Array.isArray(e), o = [e], s = -1, l = [], c = e, u, f;
  const d = [], h = [];
  do {
    s++;
    const p = s === o.length, m = p && l.length !== 0;
    if (p) {
      if (u = h.length === 0 ? void 0 : d[d.length - 1], c = f, f = h.pop(), m)
        if (i) {
          c = c.slice();
          let x = 0;
          for (const [S, T] of l) {
            const E = S - x;
            T === null ? (c.splice(E, 1), x++) : c[E] = T;
          }
        } else {
          c = { ...c };
          for (const [x, S] of l)
            c[x] = S;
        }
      s = a.index, o = a.keys, l = a.edits, i = a.inArray, a = a.prev;
    } else if (f) {
      if (u = i ? s : o[s], c = f[u], c == null)
        continue;
      d.push(u);
    }
    let w;
    if (!Array.isArray(c)) {
      var g, v;
      ex(c) || Tf(!1, `Invalid AST Node: ${Fy(c)}.`);
      const x = p ? (g = r.get(c.kind)) === null || g === void 0 ? void 0 : g.leave : (v = r.get(c.kind)) === null || v === void 0 ? void 0 : v.enter;
      if (w = x == null ? void 0 : x.call(t, c, u, f, d, h), w === eh)
        break;
      if (w === !1) {
        if (!p) {
          d.pop();
          continue;
        }
      } else if (w !== void 0 && (l.push([u, w]), !p))
        if (ex(w))
          c = w;
        else {
          d.pop();
          continue;
        }
    }
    if (w === void 0 && m && l.push([u, c]), p)
      d.pop();
    else {
      var b;
      a = {
        inArray: i,
        index: s,
        keys: o,
        edits: l,
        prev: a
      }, i = Array.isArray(c), o = i ? c : (b = n[c.kind]) !== null && b !== void 0 ? b : [], s = -1, l = [], f && h.push(f), f = c;
    }
  } while (a !== void 0);
  return l.length !== 0 ? l[l.length - 1][1] : e;
}
function rj(e, t) {
  const n = e[t];
  return typeof n == "object" ? n : typeof n == "function" ? {
    enter: n,
    leave: void 0
  } : {
    enter: e.enter,
    leave: e.leave
  };
}
function E1(e) {
  return Vn(e, ij);
}
const aj = 80, ij = {
  Name: {
    leave: (e) => e.value
  },
  Variable: {
    leave: (e) => "$" + e.name
  },
  // Document
  Document: {
    leave: (e) => ne(e.definitions, `

`)
  },
  OperationDefinition: {
    leave(e) {
      const t = yp(e.variableDefinitions) ? he(`(
`, ne(e.variableDefinitions, `
`), `
)`) : he("(", ne(e.variableDefinitions, ", "), ")"), n = he("", e.description, `
`) + ne(
        [
          e.operation,
          ne([e.name, t]),
          ne(e.directives, " ")
        ],
        " "
      );
      return (n === "query" ? "" : n + " ") + e.selectionSet;
    }
  },
  VariableDefinition: {
    leave: ({ variable: e, type: t, defaultValue: n, directives: r, description: a }) => he("", a, `
`) + e + ": " + t + he(" = ", n) + he(" ", ne(r, " "))
  },
  SelectionSet: {
    leave: ({ selections: e }) => In(e)
  },
  Field: {
    leave({ alias: e, name: t, arguments: n, directives: r, selectionSet: a }) {
      const i = he("", e, ": ") + t;
      let o = i + he("(", ne(n, ", "), ")");
      return o.length > aj && (o = i + he(`(
`, Cf(ne(n, `
`)), `
)`)), ne([o, ne(r, " "), a], " ");
    }
  },
  Argument: {
    leave: ({ name: e, value: t }) => e + ": " + t
  },
  // Fragments
  FragmentSpread: {
    leave: ({ name: e, directives: t }) => "..." + e + he(" ", ne(t, " "))
  },
  InlineFragment: {
    leave: ({ typeCondition: e, directives: t, selectionSet: n }) => ne(
      [
        "...",
        he("on ", e),
        ne(t, " "),
        n
      ],
      " "
    )
  },
  FragmentDefinition: {
    leave: ({
      name: e,
      typeCondition: t,
      variableDefinitions: n,
      directives: r,
      selectionSet: a,
      description: i
    }) => he("", i, `
`) + // Note: fragment variable definitions are experimental and may be changed
    // or removed in the future.
    `fragment ${e}${he("(", ne(n, ", "), ")")} on ${t} ${he("", ne(r, " "), " ")}` + a
  },
  // Value
  IntValue: {
    leave: ({ value: e }) => e
  },
  FloatValue: {
    leave: ({ value: e }) => e
  },
  StringValue: {
    leave: ({ value: e, block: t }) => t ? Dz(e) : Jz(e)
  },
  BooleanValue: {
    leave: ({ value: e }) => e ? "true" : "false"
  },
  NullValue: {
    leave: () => "null"
  },
  EnumValue: {
    leave: ({ value: e }) => e
  },
  ListValue: {
    leave: ({ values: e }) => "[" + ne(e, ", ") + "]"
  },
  ObjectValue: {
    leave: ({ fields: e }) => "{" + ne(e, ", ") + "}"
  },
  ObjectField: {
    leave: ({ name: e, value: t }) => e + ": " + t
  },
  // Directive
  Directive: {
    leave: ({ name: e, arguments: t }) => "@" + e + he("(", ne(t, ", "), ")")
  },
  // Type
  NamedType: {
    leave: ({ name: e }) => e
  },
  ListType: {
    leave: ({ type: e }) => "[" + e + "]"
  },
  NonNullType: {
    leave: ({ type: e }) => e + "!"
  },
  // Type System Definitions
  SchemaDefinition: {
    leave: ({ description: e, directives: t, operationTypes: n }) => he("", e, `
`) + ne(["schema", ne(t, " "), In(n)], " ")
  },
  OperationTypeDefinition: {
    leave: ({ operation: e, type: t }) => e + ": " + t
  },
  ScalarTypeDefinition: {
    leave: ({ description: e, name: t, directives: n }) => he("", e, `
`) + ne(["scalar", t, ne(n, " ")], " ")
  },
  ObjectTypeDefinition: {
    leave: ({ description: e, name: t, interfaces: n, directives: r, fields: a }) => he("", e, `
`) + ne(
      [
        "type",
        t,
        he("implements ", ne(n, " & ")),
        ne(r, " "),
        In(a)
      ],
      " "
    )
  },
  FieldDefinition: {
    leave: ({ description: e, name: t, arguments: n, type: r, directives: a }) => he("", e, `
`) + t + (yp(n) ? he(`(
`, Cf(ne(n, `
`)), `
)`) : he("(", ne(n, ", "), ")")) + ": " + r + he(" ", ne(a, " "))
  },
  InputValueDefinition: {
    leave: ({ description: e, name: t, type: n, defaultValue: r, directives: a }) => he("", e, `
`) + ne(
      [t + ": " + n, he("= ", r), ne(a, " ")],
      " "
    )
  },
  InterfaceTypeDefinition: {
    leave: ({ description: e, name: t, interfaces: n, directives: r, fields: a }) => he("", e, `
`) + ne(
      [
        "interface",
        t,
        he("implements ", ne(n, " & ")),
        ne(r, " "),
        In(a)
      ],
      " "
    )
  },
  UnionTypeDefinition: {
    leave: ({ description: e, name: t, directives: n, types: r }) => he("", e, `
`) + ne(
      ["union", t, ne(n, " "), he("= ", ne(r, " | "))],
      " "
    )
  },
  EnumTypeDefinition: {
    leave: ({ description: e, name: t, directives: n, values: r }) => he("", e, `
`) + ne(["enum", t, ne(n, " "), In(r)], " ")
  },
  EnumValueDefinition: {
    leave: ({ description: e, name: t, directives: n }) => he("", e, `
`) + ne([t, ne(n, " ")], " ")
  },
  InputObjectTypeDefinition: {
    leave: ({ description: e, name: t, directives: n, fields: r }) => he("", e, `
`) + ne(["input", t, ne(n, " "), In(r)], " ")
  },
  DirectiveDefinition: {
    leave: ({ description: e, name: t, arguments: n, repeatable: r, locations: a }) => he("", e, `
`) + "directive @" + t + (yp(n) ? he(`(
`, Cf(ne(n, `
`)), `
)`) : he("(", ne(n, ", "), ")")) + (r ? " repeatable" : "") + " on " + ne(a, " | ")
  },
  SchemaExtension: {
    leave: ({ directives: e, operationTypes: t }) => ne(
      ["extend schema", ne(e, " "), In(t)],
      " "
    )
  },
  ScalarTypeExtension: {
    leave: ({ name: e, directives: t }) => ne(["extend scalar", e, ne(t, " ")], " ")
  },
  ObjectTypeExtension: {
    leave: ({ name: e, interfaces: t, directives: n, fields: r }) => ne(
      [
        "extend type",
        e,
        he("implements ", ne(t, " & ")),
        ne(n, " "),
        In(r)
      ],
      " "
    )
  },
  InterfaceTypeExtension: {
    leave: ({ name: e, interfaces: t, directives: n, fields: r }) => ne(
      [
        "extend interface",
        e,
        he("implements ", ne(t, " & ")),
        ne(n, " "),
        In(r)
      ],
      " "
    )
  },
  UnionTypeExtension: {
    leave: ({ name: e, directives: t, types: n }) => ne(
      [
        "extend union",
        e,
        ne(t, " "),
        he("= ", ne(n, " | "))
      ],
      " "
    )
  },
  EnumTypeExtension: {
    leave: ({ name: e, directives: t, values: n }) => ne(["extend enum", e, ne(t, " "), In(n)], " ")
  },
  InputObjectTypeExtension: {
    leave: ({ name: e, directives: t, fields: n }) => ne(["extend input", e, ne(t, " "), In(n)], " ")
  },
  // Schema Coordinates
  TypeCoordinate: {
    leave: ({ name: e }) => e
  },
  MemberCoordinate: {
    leave: ({ name: e, memberName: t }) => ne([e, he(".", t)])
  },
  ArgumentCoordinate: {
    leave: ({ name: e, fieldName: t, argumentName: n }) => ne([e, he(".", t), he("(", n, ":)")])
  },
  DirectiveCoordinate: {
    leave: ({ name: e }) => ne(["@", e])
  },
  DirectiveArgumentCoordinate: {
    leave: ({ name: e, argumentName: t }) => ne(["@", e, he("(", t, ":)")])
  }
};
function ne(e, t = "") {
  var n;
  return (n = e == null ? void 0 : e.filter((r) => r).join(t)) !== null && n !== void 0 ? n : "";
}
function In(e) {
  return he(`{
`, Cf(ne(e, `
`)), `
}`);
}
function he(e, t, n = "") {
  return t != null && t !== "" ? e + t + n : "";
}
function Cf(e) {
  return he("  ", e.replace(/\n/g, `
  `));
}
function yp(e) {
  var t;
  return (t = e == null ? void 0 : e.some((n) => n.includes(`
`))) !== null && t !== void 0 ? t : !1;
}
function nx(e) {
  return e.kind === X.FIELD || e.kind === X.FRAGMENT_SPREAD || e.kind === X.INLINE_FRAGMENT;
}
function uu(e, t) {
  var n = e.directives;
  return !n || !n.length ? !0 : lj(n).every(function(r) {
    var a = r.directive, i = r.ifArgument, o = !1;
    return i.value.kind === "Variable" ? (o = t && t[i.value.name.value], W(o !== void 0, 106, a.name.value)) : o = i.value.value, a.name.value === "skip" ? !o : o;
  });
}
function Dc(e, t, n) {
  var r = new Set(e), a = r.size;
  return Vn(t, {
    Directive: function(i) {
      if (r.delete(i.name.value) && (!n || !r.size))
        return eh;
    }
  }), n ? !r.size : r.size < a;
}
function oj(e) {
  return e && Dc(["client", "export"], e, !0);
}
function sj(e) {
  var t = e.name.value;
  return t === "skip" || t === "include";
}
function lj(e) {
  var t = [];
  return e && e.length && e.forEach(function(n) {
    if (sj(n)) {
      var r = n.arguments, a = n.name.value;
      W(r && r.length === 1, 107, a);
      var i = r[0];
      W(i.name && i.name.value === "if", 108, a);
      var o = i.value;
      W(o && (o.kind === "Variable" || o.kind === "BooleanValue"), 109, a), t.push({ directive: n, ifArgument: i });
    }
  }), t;
}
function cj(e) {
  var t, n, r = (t = e.directives) === null || t === void 0 ? void 0 : t.find(function(i) {
    var o = i.name;
    return o.value === "unmask";
  });
  if (!r)
    return "mask";
  var a = (n = r.arguments) === null || n === void 0 ? void 0 : n.find(function(i) {
    var o = i.name;
    return o.value === "mode";
  });
  return globalThis.__DEV__ !== !1 && a && (a.value.kind === X.VARIABLE ? globalThis.__DEV__ !== !1 && W.warn(110) : a.value.kind !== X.STRING ? globalThis.__DEV__ !== !1 && W.warn(111) : a.value.value !== "migrate" && globalThis.__DEV__ !== !1 && W.warn(112, a.value.value)), a && "value" in a.value && a.value.value === "migrate" ? "migrate" : "unmask";
}
const uj = () => /* @__PURE__ */ Object.create(null), { forEach: fj, slice: rx } = Array.prototype, { hasOwnProperty: dj } = Object.prototype;
class na {
  constructor(t = !0, n = uj) {
    this.weakness = t, this.makeData = n;
  }
  lookup() {
    return this.lookupArray(arguments);
  }
  lookupArray(t) {
    let n = this;
    return fj.call(t, (r) => n = n.getChildTrie(r)), dj.call(n, "data") ? n.data : n.data = this.makeData(rx.call(t));
  }
  peek() {
    return this.peekArray(arguments);
  }
  peekArray(t) {
    let n = this;
    for (let r = 0, a = t.length; n && r < a; ++r) {
      const i = n.mapFor(t[r], !1);
      n = i && i.get(t[r]);
    }
    return n && n.data;
  }
  remove() {
    return this.removeArray(arguments);
  }
  removeArray(t) {
    let n;
    if (t.length) {
      const r = t[0], a = this.mapFor(r, !1), i = a && a.get(r);
      i && (n = i.removeArray(rx.call(t, 1)), !i.data && !i.weak && !(i.strong && i.strong.size) && a.delete(r));
    } else
      n = this.data, delete this.data;
    return n;
  }
  getChildTrie(t) {
    const n = this.mapFor(t, !0);
    let r = n.get(t);
    return r || n.set(t, r = new na(this.weakness, this.makeData)), r;
  }
  mapFor(t, n) {
    return this.weakness && hj(t) ? this.weak || (n ? this.weak = /* @__PURE__ */ new WeakMap() : void 0) : this.strong || (n ? this.strong = /* @__PURE__ */ new Map() : void 0);
  }
}
function hj(e) {
  switch (typeof e) {
    case "object":
      if (e === null)
        break;
    case "function":
      return !0;
  }
  return !1;
}
var pj = Bn(function() {
  return navigator.product;
}) == "ReactNative", uo = typeof WeakMap == "function" && !(pj && !global.HermesInternal), Uy = typeof WeakSet == "function", qy = typeof Symbol == "function" && typeof Symbol.for == "function", th = qy && Symbol.asyncIterator;
Bn(function() {
  return window.document.createElement;
});
Bn(function() {
  return navigator.userAgent.indexOf("jsdom") >= 0;
});
function it(e) {
  return e !== null && typeof e == "object";
}
function mj(e, t) {
  var n = t, r = [];
  e.definitions.forEach(function(i) {
    if (i.kind === "OperationDefinition")
      throw Gt(
        113,
        i.operation,
        i.name ? " named '".concat(i.name.value, "'") : ""
      );
    i.kind === "FragmentDefinition" && r.push(i);
  }), typeof n > "u" && (W(r.length === 1, 114, r.length), n = r[0].name.value);
  var a = M(M({}, e), { definitions: Nt([
    {
      kind: "OperationDefinition",
      // OperationTypeNode is an enum
      operation: "query",
      selectionSet: {
        kind: "SelectionSet",
        selections: [
          {
            kind: "FragmentSpread",
            name: {
              kind: "Name",
              value: n
            }
          }
        ]
      }
    }
  ], e.definitions, !0) });
  return a;
}
function Zs(e) {
  e === void 0 && (e = []);
  var t = {};
  return e.forEach(function(n) {
    t[n.name.value] = n;
  }), t;
}
function nh(e, t) {
  switch (e.kind) {
    case "InlineFragment":
      return e;
    case "FragmentSpread": {
      var n = e.name.value;
      if (typeof t == "function")
        return t(n);
      var r = t && t[n];
      return W(r, 115, n), r || null;
    }
    default:
      return null;
  }
}
function gj(e) {
  var t = !0;
  return Vn(e, {
    FragmentSpread: function(n) {
      if (t = !!n.directives && n.directives.some(function(r) {
        return r.name.value === "unmask";
      }), !t)
        return eh;
    }
  }), t;
}
function vj() {
}
class Tg {
  constructor(t = 1 / 0, n = vj) {
    this.max = t, this.dispose = n, this.map = /* @__PURE__ */ new Map(), this.newest = null, this.oldest = null;
  }
  has(t) {
    return this.map.has(t);
  }
  get(t) {
    const n = this.getNode(t);
    return n && n.value;
  }
  get size() {
    return this.map.size;
  }
  getNode(t) {
    const n = this.map.get(t);
    if (n && n !== this.newest) {
      const { older: r, newer: a } = n;
      a && (a.older = r), r && (r.newer = a), n.older = this.newest, n.older.newer = n, n.newer = null, this.newest = n, n === this.oldest && (this.oldest = a);
    }
    return n;
  }
  set(t, n) {
    let r = this.getNode(t);
    return r ? r.value = n : (r = {
      key: t,
      value: n,
      newer: null,
      older: this.newest
    }, this.newest && (this.newest.newer = r), this.newest = r, this.oldest = this.oldest || r, this.map.set(t, r), r.value);
  }
  clean() {
    for (; this.oldest && this.map.size > this.max; )
      this.delete(this.oldest.key);
  }
  delete(t) {
    const n = this.map.get(t);
    return n ? (n === this.newest && (this.newest = n.older), n === this.oldest && (this.oldest = n.newer), n.newer && (n.newer.older = n.older), n.older && (n.older.newer = n.newer), this.map.delete(t), this.dispose(n.value, t), !0) : !1;
  }
}
function Cg() {
}
const yj = Cg, bj = typeof WeakRef < "u" ? WeakRef : function(e) {
  return { deref: () => e };
}, wj = typeof WeakMap < "u" ? WeakMap : Map, xj = typeof FinalizationRegistry < "u" ? FinalizationRegistry : function() {
  return {
    register: Cg,
    unregister: Cg
  };
}, Ej = 10024;
class pd {
  constructor(t = 1 / 0, n = yj) {
    this.max = t, this.dispose = n, this.map = new wj(), this.newest = null, this.oldest = null, this.unfinalizedNodes = /* @__PURE__ */ new Set(), this.finalizationScheduled = !1, this.size = 0, this.finalize = () => {
      const r = this.unfinalizedNodes.values();
      for (let a = 0; a < Ej; a++) {
        const i = r.next().value;
        if (!i)
          break;
        this.unfinalizedNodes.delete(i);
        const o = i.key;
        delete i.key, i.keyRef = new bj(o), this.registry.register(o, i, i);
      }
      this.unfinalizedNodes.size > 0 ? queueMicrotask(this.finalize) : this.finalizationScheduled = !1;
    }, this.registry = new xj(this.deleteNode.bind(this));
  }
  has(t) {
    return this.map.has(t);
  }
  get(t) {
    const n = this.getNode(t);
    return n && n.value;
  }
  getNode(t) {
    const n = this.map.get(t);
    if (n && n !== this.newest) {
      const { older: r, newer: a } = n;
      a && (a.older = r), r && (r.newer = a), n.older = this.newest, n.older.newer = n, n.newer = null, this.newest = n, n === this.oldest && (this.oldest = a);
    }
    return n;
  }
  set(t, n) {
    let r = this.getNode(t);
    return r ? r.value = n : (r = {
      key: t,
      value: n,
      newer: null,
      older: this.newest
    }, this.newest && (this.newest.newer = r), this.newest = r, this.oldest = this.oldest || r, this.scheduleFinalization(r), this.map.set(t, r), this.size++, r.value);
  }
  clean() {
    for (; this.oldest && this.size > this.max; )
      this.deleteNode(this.oldest);
  }
  deleteNode(t) {
    t === this.newest && (this.newest = t.older), t === this.oldest && (this.oldest = t.newer), t.newer && (t.newer.older = t.older), t.older && (t.older.newer = t.newer), this.size--;
    const n = t.key || t.keyRef && t.keyRef.deref();
    this.dispose(t.value, n), t.keyRef ? this.registry.unregister(t) : this.unfinalizedNodes.delete(t), n && this.map.delete(n);
  }
  delete(t) {
    const n = this.map.get(t);
    return n ? (this.deleteNode(n), !0) : !1;
  }
  scheduleFinalization(t) {
    this.unfinalizedNodes.add(t), this.finalizationScheduled || (this.finalizationScheduled = !0, queueMicrotask(this.finalize));
  }
}
var bp = /* @__PURE__ */ new WeakSet();
function S1(e) {
  e.size <= (e.max || -1) || bp.has(e) || (bp.add(e), setTimeout(function() {
    e.clean(), bp.delete(e);
  }, 100));
}
var T1 = function(e, t) {
  var n = new pd(e, t);
  return n.set = function(r, a) {
    var i = pd.prototype.set.call(this, r, a);
    return S1(this), i;
  }, n;
}, Sj = function(e, t) {
  var n = new Tg(e, t);
  return n.set = function(r, a) {
    var i = Tg.prototype.set.call(this, r, a);
    return S1(this), i;
  }, n;
}, Tj = Symbol.for("apollo.cacheSize"), Kr = M({}, hd[Tj]), Si = {};
function C1(e, t) {
  Si[e] = t;
}
var Cj = globalThis.__DEV__ !== !1 ? _j : void 0, Oj = globalThis.__DEV__ !== !1 ? Dj : void 0, Aj = globalThis.__DEV__ !== !1 ? O1 : void 0;
function Rj() {
  var e = {
    parser: 1e3,
    canonicalStringify: 1e3,
    print: 2e3,
    "documentTransform.cache": 2e3,
    "queryManager.getDocumentInfo": 2e3,
    "PersistedQueryLink.persistedQueryHashes": 2e3,
    "fragmentRegistry.transform": 2e3,
    "fragmentRegistry.lookup": 1e3,
    "fragmentRegistry.findFragmentSpreads": 4e3,
    "cache.fragmentQueryDocuments": 1e3,
    "removeTypenameFromVariables.getVariableDefinitions": 2e3,
    "inMemoryCache.maybeBroadcastWatch": 5e3,
    "inMemoryCache.executeSelectionSet": 5e4,
    "inMemoryCache.executeSubSelectedArray": 1e4
  };
  return Object.fromEntries(Object.entries(e).map(function(t) {
    var n = t[0], r = t[1];
    return [
      n,
      Kr[n] || r
    ];
  }));
}
function _j() {
  var e, t, n, r, a;
  if (globalThis.__DEV__ === !1)
    throw new Error("only supported in development mode");
  return {
    limits: Rj(),
    sizes: M({ print: (e = Si.print) === null || e === void 0 ? void 0 : e.call(Si), parser: (t = Si.parser) === null || t === void 0 ? void 0 : t.call(Si), canonicalStringify: (n = Si.canonicalStringify) === null || n === void 0 ? void 0 : n.call(Si), links: Ag(this.link), queryManager: {
      getDocumentInfo: this.queryManager.transformCache.size,
      documentTransforms: R1(this.queryManager.documentTransform)
    } }, (a = (r = this.cache).getMemoryInternals) === null || a === void 0 ? void 0 : a.call(r))
  };
}
function O1() {
  return {
    cache: {
      fragmentQueryDocuments: va(this.getFragmentDoc)
    }
  };
}
function Dj() {
  var e = this.config.fragments;
  return M(M({}, O1.apply(this)), { addTypenameDocumentTransform: R1(this.addTypenameTransform), inMemoryCache: {
    executeSelectionSet: va(this.storeReader.executeSelectionSet),
    executeSubSelectedArray: va(this.storeReader.executeSubSelectedArray),
    maybeBroadcastWatch: va(this.maybeBroadcastWatch)
  }, fragmentRegistry: {
    findFragmentSpreads: va(e == null ? void 0 : e.findFragmentSpreads),
    lookup: va(e == null ? void 0 : e.lookup),
    transform: va(e == null ? void 0 : e.transform)
  } });
}
function Nj(e) {
  return !!e && "dirtyKey" in e;
}
function va(e) {
  return Nj(e) ? e.size : void 0;
}
function A1(e) {
  return e != null;
}
function R1(e) {
  return Og(e).map(function(t) {
    return { cache: t };
  });
}
function Og(e) {
  return e ? Nt(Nt([
    va(e == null ? void 0 : e.performWork)
  ], Og(e == null ? void 0 : e.left), !0), Og(e == null ? void 0 : e.right), !0).filter(A1) : [];
}
function Ag(e) {
  var t;
  return e ? Nt(Nt([
    (t = e == null ? void 0 : e.getMemoryInternals) === null || t === void 0 ? void 0 : t.call(e)
  ], Ag(e == null ? void 0 : e.left), !0), Ag(e == null ? void 0 : e.right), !0).filter(A1) : [];
}
var Ya = Object.assign(function(t) {
  return JSON.stringify(t, kj);
}, {
  reset: function() {
    $o = new Sj(
      Kr.canonicalStringify || 1e3
      /* defaultCacheSizes.canonicalStringify */
    );
  }
});
globalThis.__DEV__ !== !1 && C1("canonicalStringify", function() {
  return $o.size;
});
var $o;
Ya.reset();
function kj(e, t) {
  if (t && typeof t == "object") {
    var n = Object.getPrototypeOf(t);
    if (n === Object.prototype || n === null) {
      var r = Object.keys(t);
      if (r.every(Mj))
        return t;
      var a = JSON.stringify(r), i = $o.get(a);
      if (!i) {
        r.sort();
        var o = JSON.stringify(r);
        i = $o.get(o) || r, $o.set(a, i), $o.set(o, i);
      }
      var s = Object.create(n);
      return i.forEach(function(l) {
        s[l] = t[l];
      }), s;
    }
  }
  return t;
}
function Mj(e, t, n) {
  return t === 0 || n[t - 1] <= e;
}
function as(e) {
  return { __ref: String(e) };
}
function Me(e) {
  return !!(e && typeof e == "object" && typeof e.__ref == "string");
}
function Lj(e) {
  return it(e) && e.kind === "Document" && Array.isArray(e.definitions);
}
function zj(e) {
  return e.kind === "StringValue";
}
function jj(e) {
  return e.kind === "BooleanValue";
}
function Pj(e) {
  return e.kind === "IntValue";
}
function Ij(e) {
  return e.kind === "FloatValue";
}
function Fj(e) {
  return e.kind === "Variable";
}
function Uj(e) {
  return e.kind === "ObjectValue";
}
function qj(e) {
  return e.kind === "ListValue";
}
function Bj(e) {
  return e.kind === "EnumValue";
}
function Vj(e) {
  return e.kind === "NullValue";
}
function zs(e, t, n, r) {
  if (Pj(n) || Ij(n))
    e[t.value] = Number(n.value);
  else if (jj(n) || zj(n))
    e[t.value] = n.value;
  else if (Uj(n)) {
    var a = {};
    n.fields.map(function(o) {
      return zs(a, o.name, o.value, r);
    }), e[t.value] = a;
  } else if (Fj(n)) {
    var i = (r || {})[n.name.value];
    e[t.value] = i;
  } else if (qj(n))
    e[t.value] = n.values.map(function(o) {
      var s = {};
      return zs(s, t, o, r), s[t.value];
    });
  else if (Bj(n))
    e[t.value] = n.value;
  else if (Vj(n))
    e[t.value] = null;
  else
    throw Gt(124, t.value, n.kind);
}
function Qj(e, t) {
  var n = null;
  e.directives && (n = {}, e.directives.forEach(function(a) {
    n[a.name.value] = {}, a.arguments && a.arguments.forEach(function(i) {
      var o = i.name, s = i.value;
      return zs(n[a.name.value], o, s, t);
    });
  }));
  var r = null;
  return e.arguments && e.arguments.length && (r = {}, e.arguments.forEach(function(a) {
    var i = a.name, o = a.value;
    return zs(r, i, o, t);
  })), _1(e.name.value, r, n);
}
var Hj = [
  "connection",
  "include",
  "skip",
  "client",
  "rest",
  "export",
  "nonreactive"
], xl = Ya, _1 = Object.assign(function(e, t, n) {
  if (t && n && n.connection && n.connection.key)
    if (n.connection.filter && n.connection.filter.length > 0) {
      var r = n.connection.filter ? n.connection.filter : [];
      r.sort();
      var a = {};
      return r.forEach(function(s) {
        a[s] = t[s];
      }), "".concat(n.connection.key, "(").concat(xl(a), ")");
    } else
      return n.connection.key;
  var i = e;
  if (t) {
    var o = xl(t);
    i += "(".concat(o, ")");
  }
  return n && Object.keys(n).forEach(function(s) {
    Hj.indexOf(s) === -1 && (n[s] && Object.keys(n[s]).length ? i += "@".concat(s, "(").concat(xl(n[s]), ")") : i += "@".concat(s));
  }), i;
}, {
  setStringify: function(e) {
    var t = xl;
    return xl = e, t;
  }
});
function rh(e, t) {
  if (e.arguments && e.arguments.length) {
    var n = {};
    return e.arguments.forEach(function(r) {
      var a = r.name, i = r.value;
      return zs(n, a, i, t);
    }), n;
  }
  return null;
}
function Xr(e) {
  return e.alias ? e.alias.value : e.name.value;
}
function Rg(e, t, n) {
  for (var r, a = 0, i = t.selections; a < i.length; a++) {
    var o = i[a];
    if (ei(o)) {
      if (o.name.value === "__typename")
        return e[Xr(o)];
    } else r ? r.push(o) : r = [o];
  }
  if (typeof e.__typename == "string")
    return e.__typename;
  if (r)
    for (var s = 0, l = r; s < l.length; s++) {
      var o = l[s], c = Rg(e, nh(o, n).selectionSet, n);
      if (typeof c == "string")
        return c;
    }
}
function ei(e) {
  return e.kind === "Field";
}
function $j(e) {
  return e.kind === "InlineFragment";
}
function Js(e) {
  W(e && e.kind === "Document", 116);
  var t = e.definitions.filter(function(n) {
    return n.kind !== "FragmentDefinition";
  }).map(function(n) {
    if (n.kind !== "OperationDefinition")
      throw Gt(117, n.kind);
    return n;
  });
  return W(t.length <= 1, 118, t.length), e;
}
function Ji(e) {
  return Js(e), e.definitions.filter(function(t) {
    return t.kind === "OperationDefinition";
  })[0];
}
function ql(e) {
  return e.definitions.filter(function(t) {
    return t.kind === "OperationDefinition" && !!t.name;
  }).map(function(t) {
    return t.name.value;
  })[0] || null;
}
function el(e) {
  return e.definitions.filter(function(t) {
    return t.kind === "FragmentDefinition";
  });
}
function D1(e) {
  var t = Ji(e);
  return W(t && t.operation === "query", 119), t;
}
function N1(e) {
  W(e.kind === "Document", 120), W(e.definitions.length <= 1, 121);
  var t = e.definitions[0];
  return W(t.kind === "FragmentDefinition", 122), t;
}
function fu(e) {
  Js(e);
  for (var t, n = 0, r = e.definitions; n < r.length; n++) {
    var a = r[n];
    if (a.kind === "OperationDefinition") {
      var i = a.operation;
      if (i === "query" || i === "mutation" || i === "subscription")
        return a;
    }
    a.kind === "FragmentDefinition" && !t && (t = a);
  }
  if (t)
    return t;
  throw Gt(123);
}
function By(e) {
  var t = /* @__PURE__ */ Object.create(null), n = e && e.variableDefinitions;
  return n && n.length && n.forEach(function(r) {
    r.defaultValue && zs(t, r.variable.name, r.defaultValue);
  }), t;
}
let kt = null;
const ax = {};
let Gj = 1;
const Yj = () => class {
  constructor() {
    this.id = [
      "slot",
      Gj++,
      Date.now(),
      Math.random().toString(36).slice(2)
    ].join(":");
  }
  hasValue() {
    for (let t = kt; t; t = t.parent)
      if (this.id in t.slots) {
        const n = t.slots[this.id];
        if (n === ax)
          break;
        return t !== kt && (kt.slots[this.id] = n), !0;
      }
    return kt && (kt.slots[this.id] = ax), !1;
  }
  getValue() {
    if (this.hasValue())
      return kt.slots[this.id];
  }
  withValue(t, n, r, a) {
    const i = {
      __proto__: null,
      [this.id]: t
    }, o = kt;
    kt = { parent: o, slots: i };
    try {
      return n.apply(a, r);
    } finally {
      kt = o;
    }
  }
  // Capture the current context and wrap a callback function so that it
  // reestablishes the captured context when called.
  static bind(t) {
    const n = kt;
    return function() {
      const r = kt;
      try {
        return kt = n, t.apply(this, arguments);
      } finally {
        kt = r;
      }
    };
  }
  // Immediately run a callback function without any captured context.
  static noContext(t, n, r) {
    if (kt) {
      const a = kt;
      try {
        return kt = null, t.apply(r, n);
      } finally {
        kt = a;
      }
    } else
      return t.apply(r, n);
  }
};
function ix(e) {
  try {
    return e();
  } catch {
  }
}
const wp = "@wry/context:Slot", Kj = (
  // Prefer globalThis when available.
  // https://github.com/benjamn/wryware/issues/347
  ix(() => globalThis) || // Fall back to global, which works in Node.js and may be converted by some
  // bundlers to the appropriate identifier (window, self, ...) depending on the
  // bundling target. https://github.com/endojs/endo/issues/576#issuecomment-1178515224
  ix(() => global) || // Otherwise, use a dummy host that's local to this module. We used to fall
  // back to using the Array constructor as a namespace, but that was flagged in
  // https://github.com/benjamn/wryware/issues/347, and can be avoided.
  /* @__PURE__ */ Object.create(null)
), ox = Kj, tl = ox[wp] || // Earlier versions of this package stored the globalKey property on the Array
// constructor, so we check there as well, to prevent Slot class duplication.
Array[wp] || function(e) {
  try {
    Object.defineProperty(ox, wp, {
      value: e,
      enumerable: !1,
      writable: !1,
      // When it was possible for globalHost to be the Array constructor (a
      // legacy Slot dedup strategy), it was important for the property to be
      // configurable:true so it could be deleted. That does not seem to be as
      // important when globalHost is the global object, but I don't want to
      // cause similar problems again, and configurable:true seems safest.
      // https://github.com/endojs/endo/issues/576#issuecomment-1178274008
      configurable: !0
    });
  } finally {
    return e;
  }
}(Yj()), { bind: L8, noContext: z8 } = tl, ah = new tl(), { hasOwnProperty: Xj } = Object.prototype, Vy = Array.from || function(e) {
  const t = [];
  return e.forEach((n) => t.push(n)), t;
};
function Qy(e) {
  const { unsubscribe: t } = e;
  typeof t == "function" && (e.unsubscribe = void 0, t());
}
const Nc = [], Wj = 100;
function js(e, t) {
  if (!e)
    throw new Error(t || "assertion failure");
}
function k1(e, t) {
  const n = e.length;
  return (
    // Unknown values are not equal to each other.
    n > 0 && // Both values must be ordinary (or both exceptional) to be equal.
    n === t.length && // The underlying value or exception must be the same.
    e[n - 1] === t[n - 1]
  );
}
function M1(e) {
  switch (e.length) {
    case 0:
      throw new Error("unknown value");
    case 1:
      return e[0];
    case 2:
      throw e[1];
  }
}
function L1(e) {
  return e.slice(0);
}
class ih {
  constructor(t) {
    this.fn = t, this.parents = /* @__PURE__ */ new Set(), this.childValues = /* @__PURE__ */ new Map(), this.dirtyChildren = null, this.dirty = !0, this.recomputing = !1, this.value = [], this.deps = null, ++ih.count;
  }
  peek() {
    if (this.value.length === 1 && !ti(this))
      return sx(this), this.value[0];
  }
  // This is the most important method of the Entry API, because it
  // determines whether the cached this.value can be returned immediately,
  // or must be recomputed. The overall performance of the caching system
  // depends on the truth of the following observations: (1) this.dirty is
  // usually false, (2) this.dirtyChildren is usually null/empty, and thus
  // (3) valueGet(this.value) is usually returned without recomputation.
  recompute(t) {
    return js(!this.recomputing, "already recomputing"), sx(this), ti(this) ? Zj(this, t) : M1(this.value);
  }
  setDirty() {
    this.dirty || (this.dirty = !0, z1(this), Qy(this));
  }
  dispose() {
    this.setDirty(), U1(this), Hy(this, (t, n) => {
      t.setDirty(), q1(t, this);
    });
  }
  forget() {
    this.dispose();
  }
  dependOn(t) {
    t.add(this), this.deps || (this.deps = Nc.pop() || /* @__PURE__ */ new Set()), this.deps.add(t);
  }
  forgetDeps() {
    this.deps && (Vy(this.deps).forEach((t) => t.delete(this)), this.deps.clear(), Nc.push(this.deps), this.deps = null);
  }
}
ih.count = 0;
function sx(e) {
  const t = ah.getValue();
  if (t)
    return e.parents.add(t), t.childValues.has(e) || t.childValues.set(e, []), ti(e) ? P1(t, e) : I1(t, e), t;
}
function Zj(e, t) {
  return U1(e), ah.withValue(e, Jj, [e, t]), tP(e, t) && eP(e), M1(e.value);
}
function Jj(e, t) {
  e.recomputing = !0;
  const { normalizeResult: n } = e;
  let r;
  n && e.value.length === 1 && (r = L1(e.value)), e.value.length = 0;
  try {
    if (e.value[0] = e.fn.apply(null, t), n && r && !k1(r, e.value))
      try {
        e.value[0] = n(e.value[0], r[0]);
      } catch {
      }
  } catch (a) {
    e.value[1] = a;
  }
  e.recomputing = !1;
}
function ti(e) {
  return e.dirty || !!(e.dirtyChildren && e.dirtyChildren.size);
}
function eP(e) {
  e.dirty = !1, !ti(e) && j1(e);
}
function z1(e) {
  Hy(e, P1);
}
function j1(e) {
  Hy(e, I1);
}
function Hy(e, t) {
  const n = e.parents.size;
  if (n) {
    const r = Vy(e.parents);
    for (let a = 0; a < n; ++a)
      t(r[a], e);
  }
}
function P1(e, t) {
  js(e.childValues.has(t)), js(ti(t));
  const n = !ti(e);
  if (!e.dirtyChildren)
    e.dirtyChildren = Nc.pop() || /* @__PURE__ */ new Set();
  else if (e.dirtyChildren.has(t))
    return;
  e.dirtyChildren.add(t), n && z1(e);
}
function I1(e, t) {
  js(e.childValues.has(t)), js(!ti(t));
  const n = e.childValues.get(t);
  n.length === 0 ? e.childValues.set(t, L1(t.value)) : k1(n, t.value) || e.setDirty(), F1(e, t), !ti(e) && j1(e);
}
function F1(e, t) {
  const n = e.dirtyChildren;
  n && (n.delete(t), n.size === 0 && (Nc.length < Wj && Nc.push(n), e.dirtyChildren = null));
}
function U1(e) {
  e.childValues.size > 0 && e.childValues.forEach((t, n) => {
    q1(e, n);
  }), e.forgetDeps(), js(e.dirtyChildren === null);
}
function q1(e, t) {
  t.parents.delete(e), e.childValues.delete(t), F1(e, t);
}
function tP(e, t) {
  if (typeof e.subscribe == "function")
    try {
      Qy(e), e.unsubscribe = e.subscribe.apply(null, t);
    } catch {
      return e.setDirty(), !1;
    }
  return !0;
}
const nP = {
  setDirty: !0,
  dispose: !0,
  forget: !0
  // Fully remove parent Entry from LRU cache and computation graph
};
function B1(e) {
  const t = /* @__PURE__ */ new Map();
  function n(r) {
    const a = ah.getValue();
    if (a) {
      let i = t.get(r);
      i || t.set(r, i = /* @__PURE__ */ new Set()), a.dependOn(i);
    }
  }
  return n.dirty = function(a, i) {
    const o = t.get(a);
    if (o) {
      const s = i && Xj.call(nP, i) ? i : "setDirty";
      Vy(o).forEach((l) => l[s]()), t.delete(a), Qy(o);
    }
  }, n;
}
let lx;
function rP(...e) {
  return (lx || (lx = new na(typeof WeakMap == "function"))).lookupArray(e);
}
const xp = /* @__PURE__ */ new Set();
function kc(e, { max: t = Math.pow(2, 16), keyArgs: n, makeCacheKey: r = rP, normalizeResult: a, subscribe: i, cache: o = Tg } = /* @__PURE__ */ Object.create(null)) {
  const s = typeof o == "function" ? new o(t, (d) => d.dispose()) : o, l = function() {
    const d = r.apply(null, n ? n.apply(null, arguments) : arguments);
    if (d === void 0)
      return e.apply(null, arguments);
    let h = s.get(d);
    h || (s.set(d, h = new ih(e)), h.normalizeResult = a, h.subscribe = i, h.forget = () => s.delete(d));
    const g = h.recompute(Array.prototype.slice.call(arguments));
    return s.set(d, h), xp.add(s), ah.hasValue() || (xp.forEach((v) => v.clean()), xp.clear()), g;
  };
  Object.defineProperty(l, "size", {
    get: () => s.size,
    configurable: !1,
    enumerable: !1
  }), Object.freeze(l.options = {
    max: t,
    keyArgs: n,
    makeCacheKey: r,
    normalizeResult: a,
    subscribe: i,
    cache: s
  });
  function c(d) {
    const h = d && s.get(d);
    h && h.setDirty();
  }
  l.dirtyKey = c, l.dirty = function() {
    c(r.apply(null, arguments));
  };
  function u(d) {
    const h = d && s.get(d);
    if (h)
      return h.peek();
  }
  l.peekKey = u, l.peek = function() {
    return u(r.apply(null, arguments));
  };
  function f(d) {
    return d ? s.delete(d) : !1;
  }
  return l.forgetKey = f, l.forget = function() {
    return f(r.apply(null, arguments));
  }, l.makeCacheKey = r, l.getKey = n ? function() {
    return r.apply(null, n.apply(null, arguments));
  } : r, Object.freeze(l);
}
function aP(e) {
  return e;
}
var V1 = (
  /** @class */
  function() {
    function e(t, n) {
      n === void 0 && (n = /* @__PURE__ */ Object.create(null)), this.resultCache = Uy ? /* @__PURE__ */ new WeakSet() : /* @__PURE__ */ new Set(), this.transform = t, n.getCacheKey && (this.getCacheKey = n.getCacheKey), this.cached = n.cache !== !1, this.resetCache();
    }
    return e.prototype.getCacheKey = function(t) {
      return [t];
    }, e.identity = function() {
      return new e(aP, { cache: !1 });
    }, e.split = function(t, n, r) {
      return r === void 0 && (r = e.identity()), Object.assign(new e(
        function(a) {
          var i = t(a) ? n : r;
          return i.transformDocument(a);
        },
        // Reasonably assume both `left` and `right` transforms handle their own caching
        { cache: !1 }
      ), { left: n, right: r });
    }, e.prototype.resetCache = function() {
      var t = this;
      if (this.cached) {
        var n = new na(uo);
        this.performWork = kc(e.prototype.performWork.bind(this), {
          makeCacheKey: function(r) {
            var a = t.getCacheKey(r);
            if (a)
              return W(Array.isArray(a), 105), n.lookupArray(a);
          },
          max: Kr["documentTransform.cache"],
          cache: pd
        });
      }
    }, e.prototype.performWork = function(t) {
      return Js(t), this.transform(t);
    }, e.prototype.transformDocument = function(t) {
      if (this.resultCache.has(t))
        return t;
      var n = this.performWork(t);
      return this.resultCache.add(n), n;
    }, e.prototype.concat = function(t) {
      var n = this;
      return Object.assign(new e(
        function(r) {
          return t.transformDocument(n.transformDocument(r));
        },
        // Reasonably assume both transforms handle their own caching
        { cache: !1 }
      ), {
        left: this,
        right: t
      });
    }, e;
  }()
), ac, _i = Object.assign(function(e) {
  var t = ac.get(e);
  return t || (t = E1(e), ac.set(e, t)), t;
}, {
  reset: function() {
    ac = new T1(
      Kr.print || 2e3
      /* defaultCacheSizes.print */
    );
  }
});
_i.reset();
globalThis.__DEV__ !== !1 && C1("print", function() {
  return ac ? ac.size : 0;
});
var ot = Array.isArray;
function ur(e) {
  return Array.isArray(e) && e.length > 0;
}
var cx = {
  kind: X.FIELD,
  name: {
    kind: X.NAME,
    value: "__typename"
  }
};
function Q1(e, t) {
  return !e || e.selectionSet.selections.every(function(n) {
    return n.kind === X.FRAGMENT_SPREAD && Q1(t[n.name.value], t);
  });
}
function iP(e) {
  return Q1(Ji(e) || N1(e), Zs(el(e))) ? null : e;
}
function oP(e) {
  var t = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map();
  return e.forEach(function(r) {
    r && (r.name ? t.set(r.name, r) : r.test && n.set(r.test, r));
  }), function(r) {
    var a = t.get(r.name.value);
    return !a && n.size && n.forEach(function(i, o) {
      o(r) && (a = i);
    }), a;
  };
}
function ux(e) {
  var t = /* @__PURE__ */ new Map();
  return function(r) {
    r === void 0 && (r = e);
    var a = t.get(r);
    return a || t.set(r, a = {
      // Variable and fragment spread names used directly within this
      // operation or fragment definition, as identified by key. These sets
      // will be populated during the first traversal of the document in
      // removeDirectivesFromDocument below.
      variables: /* @__PURE__ */ new Set(),
      fragmentSpreads: /* @__PURE__ */ new Set()
    }), a;
  };
}
function H1(e, t) {
  Js(t);
  for (var n = ux(""), r = ux(""), a = function(p) {
    for (var m = 0, w = void 0; m < p.length && (w = p[m]); ++m)
      if (!ot(w)) {
        if (w.kind === X.OPERATION_DEFINITION)
          return n(w.name && w.name.value);
        if (w.kind === X.FRAGMENT_DEFINITION)
          return r(w.name.value);
      }
    return globalThis.__DEV__ !== !1 && W.error(125), null;
  }, i = 0, o = t.definitions.length - 1; o >= 0; --o)
    t.definitions[o].kind === X.OPERATION_DEFINITION && ++i;
  var s = oP(e), l = function(p) {
    return ur(p) && p.map(s).some(function(m) {
      return m && m.remove;
    });
  }, c = /* @__PURE__ */ new Map(), u = !1, f = {
    enter: function(p) {
      if (l(p.directives))
        return u = !0, null;
    }
  }, d = Vn(t, {
    // These two AST node types share the same implementation, defined above.
    Field: f,
    InlineFragment: f,
    VariableDefinition: {
      enter: function() {
        return !1;
      }
    },
    Variable: {
      enter: function(p, m, w, x, S) {
        var T = a(S);
        T && T.variables.add(p.name.value);
      }
    },
    FragmentSpread: {
      enter: function(p, m, w, x, S) {
        if (l(p.directives))
          return u = !0, null;
        var T = a(S);
        T && T.fragmentSpreads.add(p.name.value);
      }
    },
    FragmentDefinition: {
      enter: function(p, m, w, x) {
        c.set(JSON.stringify(x), p);
      },
      leave: function(p, m, w, x) {
        var S = c.get(JSON.stringify(x));
        if (p === S)
          return p;
        if (
          // This logic applies only if the document contains one or more
          // operations, since removing all fragments from a document containing
          // only fragments makes the document useless.
          i > 0 && p.selectionSet.selections.every(function(T) {
            return T.kind === X.FIELD && T.name.value === "__typename";
          })
        )
          return r(p.name.value).removed = !0, u = !0, null;
      }
    },
    Directive: {
      leave: function(p) {
        if (s(p))
          return u = !0, null;
      }
    }
  });
  if (!u)
    return t;
  var h = function(p) {
    return p.transitiveVars || (p.transitiveVars = new Set(p.variables), p.removed || p.fragmentSpreads.forEach(function(m) {
      h(r(m)).transitiveVars.forEach(function(w) {
        p.transitiveVars.add(w);
      });
    })), p;
  }, g = /* @__PURE__ */ new Set();
  d.definitions.forEach(function(p) {
    p.kind === X.OPERATION_DEFINITION ? h(n(p.name && p.name.value)).fragmentSpreads.forEach(function(m) {
      g.add(m);
    }) : p.kind === X.FRAGMENT_DEFINITION && // If there are no operations in the document, then all fragment
    // definitions count as usages of their own fragment names. This heuristic
    // prevents accidentally removing all fragment definitions from the
    // document just because it contains no operations that use the fragments.
    i === 0 && !r(p.name.value).removed && g.add(p.name.value);
  }), g.forEach(function(p) {
    h(r(p)).fragmentSpreads.forEach(function(m) {
      g.add(m);
    });
  });
  var v = function(p) {
    return !!// A fragment definition will be removed if there are no spreads that refer
    // to it, or the fragment was explicitly removed because it had no fields
    // other than __typename.
    (!g.has(p) || r(p).removed);
  }, b = {
    enter: function(p) {
      if (v(p.name.value))
        return null;
    }
  };
  return iP(Vn(d, {
    // If the fragment is going to be removed, then leaving any dangling
    // FragmentSpread nodes with the same name would be a mistake.
    FragmentSpread: b,
    // This is where the fragment definition is actually removed.
    FragmentDefinition: b,
    OperationDefinition: {
      leave: function(p) {
        if (p.variableDefinitions) {
          var m = h(
            // If an operation is anonymous, we use the empty string as its key.
            n(p.name && p.name.value)
          ).transitiveVars;
          if (m.size < p.variableDefinitions.length)
            return M(M({}, p), { variableDefinitions: p.variableDefinitions.filter(function(w) {
              return m.has(w.variable.name.value);
            }) });
        }
      }
    }
  }));
}
var $y = Object.assign(function(e) {
  return Vn(e, {
    SelectionSet: {
      enter: function(t, n, r) {
        if (!(r && r.kind === X.OPERATION_DEFINITION)) {
          var a = t.selections;
          if (a) {
            var i = a.some(function(s) {
              return ei(s) && (s.name.value === "__typename" || s.name.value.lastIndexOf("__", 0) === 0);
            });
            if (!i) {
              var o = r;
              if (!(ei(o) && o.directives && o.directives.some(function(s) {
                return s.name.value === "export";
              })))
                return M(M({}, t), { selections: Nt(Nt([], a, !0), [cx], !1) });
            }
          }
        }
      }
    }
  });
}, {
  added: function(e) {
    return e === cx;
  }
});
function sP(e) {
  var t = fu(e), n = t.operation;
  if (n === "query")
    return e;
  var r = Vn(e, {
    OperationDefinition: {
      enter: function(a) {
        return M(M({}, a), { operation: "query" });
      }
    }
  });
  return r;
}
function $1(e) {
  Js(e);
  var t = H1([
    {
      test: function(n) {
        return n.name.value === "client";
      },
      remove: !0
    }
  ], e);
  return t;
}
function lP(e) {
  return Js(e), Vn(e, {
    FragmentSpread: function(t) {
      var n;
      if (!(!((n = t.directives) === null || n === void 0) && n.some(function(r) {
        return r.name.value === "unmask";
      })))
        return M(M({}, t), { directives: Nt(Nt([], t.directives || [], !0), [
          {
            kind: X.DIRECTIVE,
            name: { kind: X.NAME, value: "nonreactive" }
          }
        ], !1) });
    }
  });
}
var cP = Object.prototype.hasOwnProperty;
function fx() {
  for (var e = [], t = 0; t < arguments.length; t++)
    e[t] = arguments[t];
  return oh(e);
}
function oh(e) {
  var t = e[0] || {}, n = e.length;
  if (n > 1)
    for (var r = new ni(), a = 1; a < n; ++a)
      t = r.merge(t, e[a]);
  return t;
}
var uP = function(e, t, n) {
  return this.merge(e[n], t[n]);
}, ni = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = uP), this.reconciler = t, this.isObject = it, this.pastCopies = /* @__PURE__ */ new Set();
    }
    return e.prototype.merge = function(t, n) {
      for (var r = this, a = [], i = 2; i < arguments.length; i++)
        a[i - 2] = arguments[i];
      return it(n) && it(t) ? (Object.keys(n).forEach(function(o) {
        if (cP.call(t, o)) {
          var s = t[o];
          if (n[o] !== s) {
            var l = r.reconciler.apply(r, Nt([
              t,
              n,
              o
            ], a, !1));
            l !== s && (t = r.shallowCopyForMerge(t), t[o] = l);
          }
        } else
          t = r.shallowCopyForMerge(t), t[o] = n[o];
      }), t) : n;
    }, e.prototype.shallowCopyForMerge = function(t) {
      return it(t) && (this.pastCopies.has(t) || (Array.isArray(t) ? t = t.slice(0) : t = M({ __proto__: Object.getPrototypeOf(t) }, t), this.pastCopies.add(t))), t;
    }, e;
  }()
);
function fP(e, t) {
  var n = typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (n) return (n = n.call(e)).next.bind(n);
  if (Array.isArray(e) || (n = dP(e)) || t) {
    n && (e = n);
    var r = 0;
    return function() {
      return r >= e.length ? { done: !0 } : { done: !1, value: e[r++] };
    };
  }
  throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function dP(e, t) {
  if (e) {
    if (typeof e == "string") return dx(e, t);
    var n = Object.prototype.toString.call(e).slice(8, -1);
    if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set") return Array.from(e);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return dx(e, t);
  }
}
function dx(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, r = new Array(t); n < t; n++)
    r[n] = e[n];
  return r;
}
function hx(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n];
    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
  }
}
function Gy(e, t, n) {
  return t && hx(e.prototype, t), n && hx(e, n), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
var Yy = function() {
  return typeof Symbol == "function";
}, Ky = function(e) {
  return Yy() && !!Symbol[e];
}, Xy = function(e) {
  return Ky(e) ? Symbol[e] : "@@" + e;
};
Yy() && !Ky("observable") && (Symbol.observable = Symbol("observable"));
var hP = Xy("iterator"), _g = Xy("observable"), G1 = Xy("species");
function md(e, t) {
  var n = e[t];
  if (n != null) {
    if (typeof n != "function") throw new TypeError(n + " is not a function");
    return n;
  }
}
function El(e) {
  var t = e.constructor;
  return t !== void 0 && (t = t[G1], t === null && (t = void 0)), t !== void 0 ? t : ke;
}
function pP(e) {
  return e instanceof ke;
}
function Ps(e) {
  Ps.log ? Ps.log(e) : setTimeout(function() {
    throw e;
  });
}
function Of(e) {
  Promise.resolve().then(function() {
    try {
      e();
    } catch (t) {
      Ps(t);
    }
  });
}
function Y1(e) {
  var t = e._cleanup;
  if (t !== void 0 && (e._cleanup = void 0, !!t))
    try {
      if (typeof t == "function")
        t();
      else {
        var n = md(t, "unsubscribe");
        n && n.call(t);
      }
    } catch (r) {
      Ps(r);
    }
}
function Dg(e) {
  e._observer = void 0, e._queue = void 0, e._state = "closed";
}
function mP(e) {
  var t = e._queue;
  if (t) {
    e._queue = void 0, e._state = "ready";
    for (var n = 0; n < t.length && (K1(e, t[n].type, t[n].value), e._state !== "closed"); ++n)
      ;
  }
}
function K1(e, t, n) {
  e._state = "running";
  var r = e._observer;
  try {
    var a = md(r, t);
    switch (t) {
      case "next":
        a && a.call(r, n);
        break;
      case "error":
        if (Dg(e), a) a.call(r, n);
        else throw n;
        break;
      case "complete":
        Dg(e), a && a.call(r);
        break;
    }
  } catch (i) {
    Ps(i);
  }
  e._state === "closed" ? Y1(e) : e._state === "running" && (e._state = "ready");
}
function Ep(e, t, n) {
  if (e._state !== "closed") {
    if (e._state === "buffering") {
      e._queue.push({
        type: t,
        value: n
      });
      return;
    }
    if (e._state !== "ready") {
      e._state = "buffering", e._queue = [{
        type: t,
        value: n
      }], Of(function() {
        return mP(e);
      });
      return;
    }
    K1(e, t, n);
  }
}
var gP = /* @__PURE__ */ function() {
  function e(n, r) {
    this._cleanup = void 0, this._observer = n, this._queue = void 0, this._state = "initializing";
    var a = new vP(this);
    try {
      this._cleanup = r.call(void 0, a);
    } catch (i) {
      a.error(i);
    }
    this._state === "initializing" && (this._state = "ready");
  }
  var t = e.prototype;
  return t.unsubscribe = function() {
    this._state !== "closed" && (Dg(this), Y1(this));
  }, Gy(e, [{
    key: "closed",
    get: function() {
      return this._state === "closed";
    }
  }]), e;
}(), vP = /* @__PURE__ */ function() {
  function e(n) {
    this._subscription = n;
  }
  var t = e.prototype;
  return t.next = function(r) {
    Ep(this._subscription, "next", r);
  }, t.error = function(r) {
    Ep(this._subscription, "error", r);
  }, t.complete = function() {
    Ep(this._subscription, "complete");
  }, Gy(e, [{
    key: "closed",
    get: function() {
      return this._subscription._state === "closed";
    }
  }]), e;
}(), ke = /* @__PURE__ */ function() {
  function e(n) {
    if (!(this instanceof e)) throw new TypeError("Observable cannot be called as a function");
    if (typeof n != "function") throw new TypeError("Observable initializer must be a function");
    this._subscriber = n;
  }
  var t = e.prototype;
  return t.subscribe = function(r) {
    return (typeof r != "object" || r === null) && (r = {
      next: r,
      error: arguments[1],
      complete: arguments[2]
    }), new gP(r, this._subscriber);
  }, t.forEach = function(r) {
    var a = this;
    return new Promise(function(i, o) {
      if (typeof r != "function") {
        o(new TypeError(r + " is not a function"));
        return;
      }
      function s() {
        l.unsubscribe(), i();
      }
      var l = a.subscribe({
        next: function(c) {
          try {
            r(c, s);
          } catch (u) {
            o(u), l.unsubscribe();
          }
        },
        error: o,
        complete: i
      });
    });
  }, t.map = function(r) {
    var a = this;
    if (typeof r != "function") throw new TypeError(r + " is not a function");
    var i = El(this);
    return new i(function(o) {
      return a.subscribe({
        next: function(s) {
          try {
            s = r(s);
          } catch (l) {
            return o.error(l);
          }
          o.next(s);
        },
        error: function(s) {
          o.error(s);
        },
        complete: function() {
          o.complete();
        }
      });
    });
  }, t.filter = function(r) {
    var a = this;
    if (typeof r != "function") throw new TypeError(r + " is not a function");
    var i = El(this);
    return new i(function(o) {
      return a.subscribe({
        next: function(s) {
          try {
            if (!r(s)) return;
          } catch (l) {
            return o.error(l);
          }
          o.next(s);
        },
        error: function(s) {
          o.error(s);
        },
        complete: function() {
          o.complete();
        }
      });
    });
  }, t.reduce = function(r) {
    var a = this;
    if (typeof r != "function") throw new TypeError(r + " is not a function");
    var i = El(this), o = arguments.length > 1, s = !1, l = arguments[1], c = l;
    return new i(function(u) {
      return a.subscribe({
        next: function(f) {
          var d = !s;
          if (s = !0, !d || o)
            try {
              c = r(c, f);
            } catch (h) {
              return u.error(h);
            }
          else
            c = f;
        },
        error: function(f) {
          u.error(f);
        },
        complete: function() {
          if (!s && !o) return u.error(new TypeError("Cannot reduce an empty sequence"));
          u.next(c), u.complete();
        }
      });
    });
  }, t.concat = function() {
    for (var r = this, a = arguments.length, i = new Array(a), o = 0; o < a; o++)
      i[o] = arguments[o];
    var s = El(this);
    return new s(function(l) {
      var c, u = 0;
      function f(d) {
        c = d.subscribe({
          next: function(h) {
            l.next(h);
          },
          error: function(h) {
            l.error(h);
          },
          complete: function() {
            u === i.length ? (c = void 0, l.complete()) : f(s.from(i[u++]));
          }
        });
      }
      return f(r), function() {
        c && (c.unsubscribe(), c = void 0);
      };
    });
  }, t.flatMap = function(r) {
    var a = this;
    if (typeof r != "function") throw new TypeError(r + " is not a function");
    var i = El(this);
    return new i(function(o) {
      var s = [], l = a.subscribe({
        next: function(u) {
          if (r)
            try {
              u = r(u);
            } catch (d) {
              return o.error(d);
            }
          var f = i.from(u).subscribe({
            next: function(d) {
              o.next(d);
            },
            error: function(d) {
              o.error(d);
            },
            complete: function() {
              var d = s.indexOf(f);
              d >= 0 && s.splice(d, 1), c();
            }
          });
          s.push(f);
        },
        error: function(u) {
          o.error(u);
        },
        complete: function() {
          c();
        }
      });
      function c() {
        l.closed && s.length === 0 && o.complete();
      }
      return function() {
        s.forEach(function(u) {
          return u.unsubscribe();
        }), l.unsubscribe();
      };
    });
  }, t[_g] = function() {
    return this;
  }, e.from = function(r) {
    var a = typeof this == "function" ? this : e;
    if (r == null) throw new TypeError(r + " is not an object");
    var i = md(r, _g);
    if (i) {
      var o = i.call(r);
      if (Object(o) !== o) throw new TypeError(o + " is not an object");
      return pP(o) && o.constructor === a ? o : new a(function(s) {
        return o.subscribe(s);
      });
    }
    if (Ky("iterator") && (i = md(r, hP), i))
      return new a(function(s) {
        Of(function() {
          if (!s.closed) {
            for (var l = fP(i.call(r)), c; !(c = l()).done; ) {
              var u = c.value;
              if (s.next(u), s.closed) return;
            }
            s.complete();
          }
        });
      });
    if (Array.isArray(r))
      return new a(function(s) {
        Of(function() {
          if (!s.closed) {
            for (var l = 0; l < r.length; ++l)
              if (s.next(r[l]), s.closed) return;
            s.complete();
          }
        });
      });
    throw new TypeError(r + " is not observable");
  }, e.of = function() {
    for (var r = arguments.length, a = new Array(r), i = 0; i < r; i++)
      a[i] = arguments[i];
    var o = typeof this == "function" ? this : e;
    return new o(function(s) {
      Of(function() {
        if (!s.closed) {
          for (var l = 0; l < a.length; ++l)
            if (s.next(a[l]), s.closed) return;
          s.complete();
        }
      });
    });
  }, Gy(e, null, [{
    key: G1,
    get: function() {
      return this;
    }
  }]), e;
}();
Yy() && Object.defineProperty(ke, Symbol("extensions"), {
  value: {
    symbol: _g,
    hostReportError: Ps
  },
  configurable: !0
});
function yP(e) {
  var t, n = e.Symbol;
  if (typeof n == "function")
    if (n.observable)
      t = n.observable;
    else {
      typeof n.for == "function" ? t = n.for("https://github.com/benlesh/symbol-observable") : t = n("https://github.com/benlesh/symbol-observable");
      try {
        n.observable = t;
      } catch {
      }
    }
  else
    t = "@@observable";
  return t;
}
var Ro;
typeof self < "u" ? Ro = self : typeof window < "u" ? Ro = window : typeof global < "u" ? Ro = global : typeof module < "u" ? Ro = module : Ro = Function("return this")();
yP(Ro);
var px = ke.prototype, mx = "@@observable";
px[mx] || (px[mx] = function() {
  return this;
});
function bP(e) {
  return e.catch(function() {
  }), e;
}
var wP = Object.prototype.toString;
function X1(e) {
  return Ng(e);
}
function Ng(e, t) {
  switch (wP.call(e)) {
    case "[object Array]": {
      if (t = t || /* @__PURE__ */ new Map(), t.has(e))
        return t.get(e);
      var n = e.slice(0);
      return t.set(e, n), n.forEach(function(a, i) {
        n[i] = Ng(a, t);
      }), n;
    }
    case "[object Object]": {
      if (t = t || /* @__PURE__ */ new Map(), t.has(e))
        return t.get(e);
      var r = Object.create(Object.getPrototypeOf(e));
      return t.set(e, r), Object.keys(e).forEach(function(a) {
        r[a] = Ng(e[a], t);
      }), r;
    }
    default:
      return e;
  }
}
function xP(e) {
  var t = /* @__PURE__ */ new Set([e]);
  return t.forEach(function(n) {
    it(n) && EP(n) === n && Object.getOwnPropertyNames(n).forEach(function(r) {
      it(n[r]) && t.add(n[r]);
    });
  }), e;
}
function EP(e) {
  if (globalThis.__DEV__ !== !1 && !Object.isFrozen(e))
    try {
      Object.freeze(e);
    } catch (t) {
      if (t instanceof TypeError)
        return null;
      throw t;
    }
  return e;
}
function gd(e) {
  return globalThis.__DEV__ !== !1 && xP(e), e;
}
function ic(e, t, n) {
  var r = [];
  e.forEach(function(a) {
    return a[t] && r.push(a);
  }), r.forEach(function(a) {
    return a[t](n);
  });
}
function Sp(e, t, n) {
  return new ke(function(r) {
    var a = {
      // Normally we would initialize promiseQueue to Promise.resolve(), but
      // in this case, for backwards compatibility, we need to be careful to
      // invoke the first callback synchronously.
      then: function(l) {
        return new Promise(function(c) {
          return c(l());
        });
      }
    };
    function i(l, c) {
      return function(u) {
        if (l) {
          var f = function() {
            return r.closed ? (
              /* will be swallowed */
              0
            ) : l(u);
          };
          a = a.then(f, f).then(function(d) {
            return r.next(d);
          }, function(d) {
            return r.error(d);
          });
        } else
          r[c](u);
      };
    }
    var o = {
      next: i(t, "next"),
      error: i(n, "error"),
      complete: function() {
        a.then(function() {
          return r.complete();
        });
      }
    }, s = e.subscribe(o);
    return function() {
      return s.unsubscribe();
    };
  });
}
function W1(e) {
  function t(n) {
    Object.defineProperty(e, n, { value: ke });
  }
  return qy && Symbol.species && t(Symbol.species), t("@@species"), e;
}
function gx(e) {
  return e && typeof e.then == "function";
}
var _o = (
  /** @class */
  function(e) {
    Yn(t, e);
    function t(n) {
      var r = e.call(this, function(a) {
        return r.addObserver(a), function() {
          return r.removeObserver(a);
        };
      }) || this;
      return r.observers = /* @__PURE__ */ new Set(), r.promise = new Promise(function(a, i) {
        r.resolve = a, r.reject = i;
      }), r.handlers = {
        next: function(a) {
          r.sub !== null && (r.latest = ["next", a], r.notify("next", a), ic(r.observers, "next", a));
        },
        error: function(a) {
          var i = r.sub;
          i !== null && (i && setTimeout(function() {
            return i.unsubscribe();
          }), r.sub = null, r.latest = ["error", a], r.reject(a), r.notify("error", a), ic(r.observers, "error", a));
        },
        complete: function() {
          var a = r, i = a.sub, o = a.sources, s = o === void 0 ? [] : o;
          if (i !== null) {
            var l = s.shift();
            l ? gx(l) ? l.then(function(c) {
              return r.sub = c.subscribe(r.handlers);
            }, r.handlers.error) : r.sub = l.subscribe(r.handlers) : (i && setTimeout(function() {
              return i.unsubscribe();
            }), r.sub = null, r.latest && r.latest[0] === "next" ? r.resolve(r.latest[1]) : r.resolve(), r.notify("complete"), ic(r.observers, "complete"));
          }
        }
      }, r.nextResultListeners = /* @__PURE__ */ new Set(), r.cancel = function(a) {
        r.reject(a), r.sources = [], r.handlers.error(a);
      }, r.promise.catch(function(a) {
      }), typeof n == "function" && (n = [new ke(n)]), gx(n) ? n.then(function(a) {
        return r.start(a);
      }, r.handlers.error) : r.start(n), r;
    }
    return t.prototype.start = function(n) {
      this.sub === void 0 && (this.sources = Array.from(n), this.handlers.complete());
    }, t.prototype.deliverLastMessage = function(n) {
      if (this.latest) {
        var r = this.latest[0], a = n[r];
        a && a.call(n, this.latest[1]), this.sub === null && r === "next" && n.complete && n.complete();
      }
    }, t.prototype.addObserver = function(n) {
      this.observers.has(n) || (this.deliverLastMessage(n), this.observers.add(n));
    }, t.prototype.removeObserver = function(n) {
      this.observers.delete(n) && this.observers.size < 1 && this.handlers.complete();
    }, t.prototype.notify = function(n, r) {
      var a = this.nextResultListeners;
      a.size && (this.nextResultListeners = /* @__PURE__ */ new Set(), a.forEach(function(i) {
        return i(n, r);
      }));
    }, t.prototype.beforeNext = function(n) {
      var r = !1;
      this.nextResultListeners.add(function(a, i) {
        r || (r = !0, n(a, i));
      });
    }, t;
  }(ke)
);
W1(_o);
function is(e) {
  return "incremental" in e;
}
function SP(e) {
  return "hasNext" in e && "data" in e;
}
function TP(e) {
  return is(e) || SP(e);
}
function CP(e) {
  return it(e) && "payload" in e;
}
function Z1(e, t) {
  var n = e, r = new ni();
  return is(t) && ur(t.incremental) && t.incremental.forEach(function(a) {
    for (var i = a.data, o = a.path, s = o.length - 1; s >= 0; --s) {
      var l = o[s], c = !isNaN(+l), u = c ? [] : {};
      u[l] = i, i = u;
    }
    n = r.merge(n, i);
  }), n;
}
function Af(e) {
  var t = kg(e);
  return ur(t);
}
function kg(e) {
  var t = ur(e.errors) ? e.errors.slice(0) : [];
  return is(e) && ur(e.incremental) && e.incremental.forEach(function(n) {
    n.errors && t.push.apply(t, n.errors);
  }), t;
}
function Is() {
  for (var e = [], t = 0; t < arguments.length; t++)
    e[t] = arguments[t];
  var n = /* @__PURE__ */ Object.create(null);
  return e.forEach(function(r) {
    r && Object.keys(r).forEach(function(a) {
      var i = r[a];
      i !== void 0 && (n[a] = i);
    });
  }), n;
}
function Tp(e, t) {
  return Is(e, t, t.variables && {
    variables: Is(M(M({}, e && e.variables), t.variables))
  });
}
function Cp(e) {
  return new ke(function(t) {
    t.error(e);
  });
}
var J1 = function(e, t, n) {
  var r = new Error(n);
  throw r.name = "ServerError", r.response = e, r.statusCode = e.status, r.result = t, r;
};
function OP(e) {
  for (var t = [
    "query",
    "operationName",
    "variables",
    "extensions",
    "context"
  ], n = 0, r = Object.keys(e); n < r.length; n++) {
    var a = r[n];
    if (t.indexOf(a) < 0)
      throw Gt(58, a);
  }
  return e;
}
function AP(e, t) {
  var n = M({}, e), r = function(i) {
    typeof i == "function" ? n = M(M({}, n), i(n)) : n = M(M({}, n), i);
  }, a = function() {
    return M({}, n);
  };
  return Object.defineProperty(t, "setContext", {
    enumerable: !1,
    value: r
  }), Object.defineProperty(t, "getContext", {
    enumerable: !1,
    value: a
  }), t;
}
function RP(e) {
  var t = {
    variables: e.variables || {},
    extensions: e.extensions || {},
    operationName: e.operationName,
    query: e.query
  };
  return t.operationName || (t.operationName = typeof t.query != "string" ? ql(t.query) || void 0 : ""), t;
}
function _P(e, t) {
  var n = M({}, e), r = new Set(Object.keys(e));
  return Vn(t, {
    Variable: function(a, i, o) {
      o && o.kind !== "VariableDefinition" && r.delete(a.name.value);
    }
  }), r.forEach(function(a) {
    delete n[a];
  }), n;
}
var DP = Symbol.for("apollo.deprecations"), NP = hd, Mg = new tl();
function kP(e) {
  return NP[DP] || (Mg.getValue() || []).includes(e);
}
function Ut(e) {
  for (var t = [], n = 1; n < arguments.length; n++)
    t[n - 1] = arguments[n];
  return Mg.withValue.apply(Mg, Nt([Array.isArray(e) ? e : [e]], t, !1));
}
function st(e, t, n, r) {
  r === void 0 && (r = "Please remove this option."), Oi(t, function() {
    t in e && globalThis.__DEV__ !== !1 && W.warn(104, n, t, r);
  });
}
function Oi(e, t) {
  kP(e) || t();
}
function vx(e, t) {
  return t ? t(e) : ke.of();
}
function Sl(e) {
  return typeof e == "function" ? new gr(e) : e;
}
function Xu(e) {
  return e.request.length <= 1;
}
var gr = (
  /** @class */
  function() {
    function e(t) {
      t && (this.request = t);
    }
    return e.empty = function() {
      return new e(function() {
        return ke.of();
      });
    }, e.from = function(t) {
      return t.length === 0 ? e.empty() : t.map(Sl).reduce(function(n, r) {
        return n.concat(r);
      });
    }, e.split = function(t, n, r) {
      var a = Sl(n), i = Sl(r || new e(vx)), o;
      return Xu(a) && Xu(i) ? o = new e(function(s) {
        return t(s) ? a.request(s) || ke.of() : i.request(s) || ke.of();
      }) : o = new e(function(s, l) {
        return t(s) ? a.request(s, l) || ke.of() : i.request(s, l) || ke.of();
      }), Object.assign(o, { left: a, right: i });
    }, e.execute = function(t, n) {
      return t.request(AP(n.context, RP(OP(n)))) || ke.of();
    }, e.concat = function(t, n) {
      var r = Sl(t);
      if (Xu(r))
        return globalThis.__DEV__ !== !1 && W.warn(47, r), r;
      var a = Sl(n), i;
      return Xu(a) ? i = new e(function(o) {
        return r.request(o, function(s) {
          return a.request(s) || ke.of();
        }) || ke.of();
      }) : i = new e(function(o, s) {
        return r.request(o, function(l) {
          return a.request(l, s) || ke.of();
        }) || ke.of();
      }), Object.assign(i, { left: r, right: a });
    }, e.prototype.split = function(t, n, r) {
      return this.concat(e.split(t, n, r || new e(vx)));
    }, e.prototype.concat = function(t) {
      return e.concat(this, t);
    }, e.prototype.request = function(t, n) {
      throw Gt(48);
    }, e.prototype.onError = function(t, n) {
      if (globalThis.__DEV__ !== !1 && Oi("onError", function() {
        globalThis.__DEV__ !== !1 && W.warn(49);
      }), n && n.error)
        return n.error(t), !1;
      throw t;
    }, e.prototype.setOnError = function(t) {
      return globalThis.__DEV__ !== !1 && globalThis.__DEV__ !== !1 && W.warn(50), this.onError = t, this;
    }, e;
  }()
), Lg = gr.execute;
function MP(e) {
  var t, n = e[Symbol.asyncIterator]();
  return t = {
    next: function() {
      return n.next();
    }
  }, t[Symbol.asyncIterator] = function() {
    return this;
  }, t;
}
function LP(e) {
  var t = null, n = null, r = !1, a = [], i = [];
  function o(f) {
    if (!n) {
      if (i.length) {
        var d = i.shift();
        if (Array.isArray(d) && d[0])
          return d[0]({ value: f, done: !1 });
      }
      a.push(f);
    }
  }
  function s(f) {
    n = f;
    var d = i.slice();
    d.forEach(function(h) {
      h[1](f);
    }), !t || t();
  }
  function l() {
    r = !0;
    var f = i.slice();
    f.forEach(function(d) {
      d[0]({ value: void 0, done: !0 });
    }), !t || t();
  }
  t = function() {
    t = null, e.removeListener("data", o), e.removeListener("error", s), e.removeListener("end", l), e.removeListener("finish", l), e.removeListener("close", l);
  }, e.on("data", o), e.on("error", s), e.on("end", l), e.on("finish", l), e.on("close", l);
  function c() {
    return new Promise(function(f, d) {
      if (n)
        return d(n);
      if (a.length)
        return f({ value: a.shift(), done: !1 });
      if (r)
        return f({ value: void 0, done: !0 });
      i.push([f, d]);
    });
  }
  var u = {
    next: function() {
      return c();
    }
  };
  return th && (u[Symbol.asyncIterator] = function() {
    return this;
  }), u;
}
function zP(e) {
  var t = !1, n = {
    next: function() {
      return t ? Promise.resolve({
        value: void 0,
        done: !0
      }) : (t = !0, new Promise(function(r, a) {
        e.then(function(i) {
          r({ value: i, done: !1 });
        }).catch(a);
      }));
    }
  };
  return th && (n[Symbol.asyncIterator] = function() {
    return this;
  }), n;
}
function yx(e) {
  var t = {
    next: function() {
      return e.read();
    }
  };
  return th && (t[Symbol.asyncIterator] = function() {
    return this;
  }), t;
}
function jP(e) {
  return !!e.body;
}
function PP(e) {
  return !!e.getReader;
}
function IP(e) {
  return !!(th && e[Symbol.asyncIterator]);
}
function FP(e) {
  return !!e.stream;
}
function UP(e) {
  return !!e.arrayBuffer;
}
function qP(e) {
  return !!e.pipe;
}
function BP(e) {
  var t = e;
  if (jP(e) && (t = e.body), IP(t))
    return MP(t);
  if (PP(t))
    return yx(t.getReader());
  if (FP(t))
    return yx(t.stream().getReader());
  if (UP(t))
    return zP(t.arrayBuffer());
  if (qP(t))
    return LP(t);
  throw new Error("Unknown body type for responseIterator. Please pass a streamable response.");
}
var sh = Symbol();
function eA(e) {
  return e.extensions ? Array.isArray(e.extensions[sh]) : !1;
}
function tA(e) {
  return e.hasOwnProperty("graphQLErrors");
}
var VP = function(e) {
  var t = Nt(Nt(Nt([], e.graphQLErrors, !0), e.clientErrors, !0), e.protocolErrors, !0);
  return e.networkError && t.push(e.networkError), t.map(function(n) {
    return it(n) && n.message || "Error message not found.";
  }).join(`
`);
}, Ti = (
  /** @class */
  function(e) {
    Yn(t, e);
    function t(n) {
      var r = n.graphQLErrors, a = n.protocolErrors, i = n.clientErrors, o = n.networkError, s = n.errorMessage, l = n.extraInfo, c = e.call(this, s) || this;
      return c.name = "ApolloError", c.graphQLErrors = r || [], c.protocolErrors = a || [], c.clientErrors = i || [], c.networkError = o || null, c.message = s || VP(c), c.extraInfo = l, c.cause = Nt(Nt(Nt([
        o
      ], r || [], !0), a || [], !0), i || [], !0).find(function(u) {
        return !!u;
      }) || null, c.__proto__ = t.prototype, c;
    }
    return t;
  }(Error)
), bx = Object.prototype.hasOwnProperty;
function QP(e, t) {
  return ma(this, void 0, void 0, function() {
    var n, r, a, i, o, s, l, c, u, f, d, h, g, v, b, p, m, w, x, S, T, E, O, D;
    return ga(this, function(A) {
      switch (A.label) {
        case 0:
          if (TextDecoder === void 0)
            throw new Error("TextDecoder must be defined in the environment: please import a polyfill.");
          n = new TextDecoder("utf-8"), r = (D = e.headers) === null || D === void 0 ? void 0 : D.get("content-type"), a = "boundary=", i = r != null && r.includes(a) ? r == null ? void 0 : r.substring((r == null ? void 0 : r.indexOf(a)) + a.length).replace(/['"]/g, "").replace(/\;(.*)/gm, "").trim() : "-", o = `\r
--`.concat(i), s = "", l = BP(e), c = !0, A.label = 1;
        case 1:
          return c ? [4, l.next()] : [3, 3];
        case 2:
          for (u = A.sent(), f = u.value, d = u.done, h = typeof f == "string" ? f : n.decode(f), g = s.length - o.length + 1, c = !d, s += h, v = s.indexOf(o, g); v > -1; ) {
            if (b = void 0, E = [
              s.slice(0, v),
              s.slice(v + o.length)
            ], b = E[0], s = E[1], p = b.indexOf(`\r
\r
`), m = HP(b.slice(0, p)), w = m["content-type"], w && w.toLowerCase().indexOf("application/json") === -1)
              throw new Error("Unsupported patch content type: application/json is required.");
            if (x = b.slice(p), x) {
              if (S = nA(e, x), Object.keys(S).length > 1 || "data" in S || "incremental" in S || "errors" in S || "payload" in S)
                if (CP(S)) {
                  if (T = {}, "payload" in S) {
                    if (Object.keys(S).length === 1 && S.payload === null)
                      return [
                        2
                        /*return*/
                      ];
                    T = M({}, S.payload);
                  }
                  "errors" in S && (T = M(M({}, T), { extensions: M(M({}, "extensions" in T ? T.extensions : null), (O = {}, O[sh] = S.errors, O)) })), t(T);
                } else
                  t(S);
              else if (
                // If the chunk contains only a "hasNext: false", we can call
                // observer.complete() immediately.
                Object.keys(S).length === 1 && "hasNext" in S && !S.hasNext
              )
                return [
                  2
                  /*return*/
                ];
            }
            v = s.indexOf(o);
          }
          return [3, 1];
        case 3:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function HP(e) {
  var t = {};
  return e.split(`
`).forEach(function(n) {
    var r = n.indexOf(":");
    if (r > -1) {
      var a = n.slice(0, r).trim().toLowerCase(), i = n.slice(r + 1).trim();
      t[a] = i;
    }
  }), t;
}
function nA(e, t) {
  if (e.status >= 300) {
    var n = function() {
      try {
        return JSON.parse(t);
      } catch {
        return t;
      }
    };
    J1(e, n(), "Response not successful: Received status code ".concat(e.status));
  }
  try {
    return JSON.parse(t);
  } catch (a) {
    var r = a;
    throw r.name = "ServerParseError", r.response = e, r.statusCode = e.status, r.bodyText = t, r;
  }
}
function $P(e, t) {
  e.result && e.result.errors && e.result.data && t.next(e.result), t.error(e);
}
function rA(e) {
  return function(t) {
    return t.text().then(function(n) {
      return nA(t, n);
    }).then(function(n) {
      return !Array.isArray(n) && !bx.call(n, "data") && !bx.call(n, "errors") && J1(t, n, "Server response was missing for query '".concat(Array.isArray(e) ? e.map(function(r) {
        return r.operationName;
      }) : e.operationName, "'.")), n;
    });
  };
}
var Mc = function(e, t) {
  var n;
  try {
    n = JSON.stringify(e);
  } catch (a) {
    var r = Gt(54, t, a.message);
    throw r.parseError = a, r;
  }
  return n;
}, GP = {
  includeQuery: !0,
  includeExtensions: !1,
  preserveHeaderCase: !1
}, YP = {
  // headers are case insensitive (https://stackoverflow.com/a/5259004)
  accept: "*/*",
  // The content-type header describes the type of the body of the request, and
  // so it typically only is sent with requests that actually have bodies. One
  // could imagine that Apollo Client would remove this header when constructing
  // a GET request (which has no body), but we historically have not done that.
  // This means that browsers will preflight all Apollo Client requests (even
  // GET requests). Apollo Server's CSRF prevention feature (introduced in
  // AS3.7) takes advantage of this fact and does not block requests with this
  // header. If you want to drop this header from GET requests, then you should
  // probably replace it with a `apollo-require-preflight` header, or servers
  // with CSRF prevention enabled might block your GET request. See
  // https://www.apollographql.com/docs/apollo-server/security/cors/#preventing-cross-site-request-forgery-csrf
  // for more details.
  "content-type": "application/json"
}, KP = {
  method: "POST"
}, aA = {
  http: GP,
  headers: YP,
  options: KP
}, iA = function(e, t) {
  return t(e);
};
function oA(e, t) {
  for (var n = [], r = 2; r < arguments.length; r++)
    n[r - 2] = arguments[r];
  var a = {}, i = {};
  n.forEach(function(f) {
    a = M(M(M({}, a), f.options), { headers: M(M({}, a.headers), f.headers) }), f.credentials && (a.credentials = f.credentials), i = M(M({}, i), f.http);
  }), a.headers && (a.headers = XP(a.headers, i.preserveHeaderCase));
  var o = e.operationName, s = e.extensions, l = e.variables, c = e.query, u = { operationName: o, variables: l };
  return i.includeExtensions && (u.extensions = s), i.includeQuery && (u.query = t(c, _i)), {
    options: a,
    body: u
  };
}
function XP(e, t) {
  if (!t) {
    var n = {};
    return Object.keys(Object(e)).forEach(function(i) {
      n[i.toLowerCase()] = e[i];
    }), n;
  }
  var r = {};
  Object.keys(Object(e)).forEach(function(i) {
    r[i.toLowerCase()] = {
      originalName: i,
      value: e[i]
    };
  });
  var a = {};
  return Object.keys(r).forEach(function(i) {
    a[r[i].originalName] = r[i].value;
  }), a;
}
var WP = function(e) {
  if (!e && typeof fetch > "u")
    throw Gt(51);
}, ZP = function() {
  if (typeof AbortController > "u")
    return { controller: !1, signal: !1 };
  var e = new AbortController(), t = e.signal;
  return { controller: e, signal: t };
}, sA = function(e, t) {
  var n = e.getContext(), r = n.uri;
  return r || (typeof t == "function" ? t(e) : t || "/graphql");
};
function lA(e, t) {
  var n = [], r = function(f, d) {
    n.push("".concat(f, "=").concat(encodeURIComponent(d)));
  };
  if ("query" in t && r("query", t.query), t.operationName && r("operationName", t.operationName), t.variables) {
    var a = void 0;
    try {
      a = Mc(t.variables, "Variables map");
    } catch (f) {
      return { parseError: f };
    }
    r("variables", a);
  }
  if (t.extensions) {
    var i = void 0;
    try {
      i = Mc(t.extensions, "Extensions map");
    } catch (f) {
      return { parseError: f };
    }
    r("extensions", i);
  }
  var o = "", s = e, l = e.indexOf("#");
  l !== -1 && (o = e.substr(l), s = e.substr(0, l));
  var c = s.indexOf("?") === -1 ? "?" : "&", u = s + c + n.join("&") + o;
  return { newURI: u };
}
var wx = Bn(function() {
  return fetch;
}), JP = function(e) {
  e === void 0 && (e = {});
  var t = e.uri, n = t === void 0 ? "/graphql" : t, r = e.fetch, a = e.print, i = a === void 0 ? iA : a, o = e.includeExtensions, s = e.preserveHeaderCase, l = e.useGETForQueries, c = e.includeUnusedVariables, u = c === void 0 ? !1 : c, f = Ln(e, ["uri", "fetch", "print", "includeExtensions", "preserveHeaderCase", "useGETForQueries", "includeUnusedVariables"]);
  globalThis.__DEV__ !== !1 && WP(r || wx);
  var d = {
    http: { includeExtensions: o, preserveHeaderCase: s },
    options: f.fetchOptions,
    credentials: f.credentials,
    headers: f.headers
  };
  return new gr(function(h) {
    var g = sA(h, n), v = h.getContext(), b = {};
    if (v.clientAwareness) {
      var p = v.clientAwareness, m = p.name, w = p.version;
      m && (b["apollographql-client-name"] = m), w && (b["apollographql-client-version"] = w);
    }
    var x = M(M({}, b), v.headers), S = {
      http: v.http,
      options: v.fetchOptions,
      credentials: v.credentials,
      headers: x
    };
    if (Dc(["client"], h.query)) {
      globalThis.__DEV__ !== !1 && globalThis.__DEV__ !== !1 && W.warn(52);
      var T = $1(h.query);
      if (!T)
        return Cp(new Error("HttpLink: Trying to send a client-only query to the server. To send to the server, ensure a non-client field is added to the query or set the `transformOptions.removeClientFields` option to `true`."));
      h.query = T;
    }
    var E = oA(h, i, aA, d, S), O = E.options, D = E.body;
    D.variables && !u && (D.variables = _P(D.variables, h.query));
    var A;
    !O.signal && typeof AbortController < "u" && (A = new AbortController(), O.signal = A.signal);
    var U = function(H) {
      return H.kind === "OperationDefinition" && H.operation === "mutation";
    }, R = function(H) {
      return H.kind === "OperationDefinition" && H.operation === "subscription";
    }, q = R(fu(h.query)), z = Dc(["defer"], h.query);
    if (l && !h.query.definitions.some(U) && (O.method = "GET"), z || q) {
      O.headers = O.headers || {};
      var Q = "multipart/mixed;";
      q && z && globalThis.__DEV__ !== !1 && W.warn(53), q ? Q += "boundary=graphql;subscriptionSpec=1.0,application/json" : z && (Q += "deferSpec=20220824,application/json"), O.headers.accept = Q;
    }
    if (O.method === "GET") {
      var k = lA(g, D), P = k.newURI, F = k.parseError;
      if (F)
        return Cp(F);
      g = P;
    } else
      try {
        O.body = Mc(D, "Payload");
      } catch (H) {
        return Cp(H);
      }
    return new ke(function(H) {
      var K = r || Bn(function() {
        return fetch;
      }) || wx, Z = H.next.bind(H);
      return K(g, O).then(function(I) {
        var G;
        h.setContext({ response: I });
        var ee = (G = I.headers) === null || G === void 0 ? void 0 : G.get("content-type");
        return ee !== null && /^multipart\/mixed/i.test(ee) ? QP(I, Z) : rA(h)(I).then(Z);
      }).then(function() {
        A = void 0, H.complete();
      }).catch(function(I) {
        A = void 0, $P(I, H);
      }), function() {
        A && A.abort();
      };
    });
  });
}, eI = (
  /** @class */
  function(e) {
    Yn(t, e);
    function t(n) {
      n === void 0 && (n = {});
      var r = e.call(this, JP(n).request) || this;
      return r.options = n, r;
    }
    return t;
  }(gr)
);
const { toString: xx, hasOwnProperty: tI } = Object.prototype, Ex = Function.prototype.toString, zg = /* @__PURE__ */ new Map();
function qe(e, t) {
  try {
    return jg(e, t);
  } finally {
    zg.clear();
  }
}
function jg(e, t) {
  if (e === t)
    return !0;
  const n = xx.call(e), r = xx.call(t);
  if (n !== r)
    return !1;
  switch (n) {
    case "[object Array]":
      if (e.length !== t.length)
        return !1;
    case "[object Object]": {
      if (Tx(e, t))
        return !0;
      const a = Sx(e), i = Sx(t), o = a.length;
      if (o !== i.length)
        return !1;
      for (let s = 0; s < o; ++s)
        if (!tI.call(t, a[s]))
          return !1;
      for (let s = 0; s < o; ++s) {
        const l = a[s];
        if (!jg(e[l], t[l]))
          return !1;
      }
      return !0;
    }
    case "[object Error]":
      return e.name === t.name && e.message === t.message;
    case "[object Number]":
      if (e !== e)
        return t !== t;
    case "[object Boolean]":
    case "[object Date]":
      return +e == +t;
    case "[object RegExp]":
    case "[object String]":
      return e == `${t}`;
    case "[object Map]":
    case "[object Set]": {
      if (e.size !== t.size)
        return !1;
      if (Tx(e, t))
        return !0;
      const a = e.entries(), i = n === "[object Map]";
      for (; ; ) {
        const o = a.next();
        if (o.done)
          break;
        const [s, l] = o.value;
        if (!t.has(s) || i && !jg(l, t.get(s)))
          return !1;
      }
      return !0;
    }
    case "[object Uint16Array]":
    case "[object Uint8Array]":
    case "[object Uint32Array]":
    case "[object Int32Array]":
    case "[object Int8Array]":
    case "[object Int16Array]":
    case "[object ArrayBuffer]":
      e = new Uint8Array(e), t = new Uint8Array(t);
    case "[object DataView]": {
      let a = e.byteLength;
      if (a === t.byteLength)
        for (; a-- && e[a] === t[a]; )
          ;
      return a === -1;
    }
    case "[object AsyncFunction]":
    case "[object GeneratorFunction]":
    case "[object AsyncGeneratorFunction]":
    case "[object Function]": {
      const a = Ex.call(e);
      return a !== Ex.call(t) ? !1 : !aI(a, rI);
    }
  }
  return !1;
}
function Sx(e) {
  return Object.keys(e).filter(nI, e);
}
function nI(e) {
  return this[e] !== void 0;
}
const rI = "{ [native code] }";
function aI(e, t) {
  const n = e.length - t.length;
  return n >= 0 && e.indexOf(t, n) === n;
}
function Tx(e, t) {
  let n = zg.get(e);
  if (n) {
    if (n.has(t))
      return !0;
  } else
    zg.set(e, n = /* @__PURE__ */ new Set());
  return n.add(t), !1;
}
function cA(e, t, n, r) {
  var a = t.data, i = Ln(t, ["data"]), o = n.data, s = Ln(n, ["data"]);
  return qe(i, s) && Rf(fu(e).selectionSet, a, o, {
    fragmentMap: Zs(el(e)),
    variables: r
  });
}
function Rf(e, t, n, r) {
  if (t === n)
    return !0;
  var a = /* @__PURE__ */ new Set();
  return e.selections.every(function(i) {
    if (a.has(i) || (a.add(i), !uu(i, r.variables)) || Cx(i))
      return !0;
    if (ei(i)) {
      var o = Xr(i), s = t && t[o], l = n && n[o], c = i.selectionSet;
      if (!c)
        return qe(s, l);
      var u = Array.isArray(s), f = Array.isArray(l);
      if (u !== f)
        return !1;
      if (u && f) {
        var d = s.length;
        if (l.length !== d)
          return !1;
        for (var h = 0; h < d; ++h)
          if (!Rf(c, s[h], l[h], r))
            return !1;
        return !0;
      }
      return Rf(c, s, l, r);
    } else {
      var g = nh(i, r.fragmentMap);
      if (g)
        return Cx(g) ? !0 : Rf(
          g.selectionSet,
          // Notice that we reuse the same aResult and bResult values here,
          // since the fragment ...spread does not specify a field name, but
          // consists of multiple fields (within the fragment's selection set)
          // that should be applied to the current result value(s).
          t,
          n,
          r
        );
    }
  });
}
function Cx(e) {
  return !!e.directives && e.directives.some(iI);
}
function iI(e) {
  return e.name.value === "nonreactive";
}
var uA = uo ? WeakMap : Map, fA = Uy ? WeakSet : Set, Wy = new tl(), Ox = !1;
function dA() {
  Ox || (Ox = !0, globalThis.__DEV__ !== !1 && W.warn(64));
}
function hA(e, t, n) {
  return Wy.withValue(!0, function() {
    var r = Bl(e, t, n, !1);
    return Object.isFrozen(e) && gd(r), r;
  });
}
function oI(e, t) {
  if (t.has(e))
    return t.get(e);
  var n = Array.isArray(e) ? [] : /* @__PURE__ */ Object.create(null);
  return t.set(e, n), n;
}
function Bl(e, t, n, r, a) {
  var i, o = n.knownChanged, s = oI(e, n.mutableTargets);
  if (Array.isArray(e)) {
    for (var l = 0, c = Array.from(e.entries()); l < c.length; l++) {
      var u = c[l], f = u[0], d = u[1];
      if (d === null) {
        s[f] = null;
        continue;
      }
      var h = Bl(d, t, n, r, globalThis.__DEV__ !== !1 ? "".concat(a || "", "[").concat(f, "]") : void 0);
      o.has(h) && o.add(s), s[f] = h;
    }
    return o.has(s) ? s : e;
  }
  for (var g = 0, v = t.selections; g < v.length; g++) {
    var b = v[g], p = void 0;
    if (r && o.add(s), b.kind === X.FIELD) {
      var m = Xr(b), w = b.selectionSet;
      if (p = s[m] || e[m], p === void 0)
        continue;
      if (w && p !== null) {
        var h = Bl(e[m], w, n, r, globalThis.__DEV__ !== !1 ? "".concat(a || "", ".").concat(m) : void 0);
        o.has(h) && (p = h);
      }
      globalThis.__DEV__ === !1 && (s[m] = p), globalThis.__DEV__ !== !1 && (r && m !== "__typename" && // either the field is not present in the memo object
      // or it has a `get` descriptor, not a `value` descriptor
      // => it is a warning accessor and we can overwrite it
      // with another accessor
      !(!((i = Object.getOwnPropertyDescriptor(s, m)) === null || i === void 0) && i.value) ? Object.defineProperty(s, m, sI(m, p, a || "", n.operationName, n.operationType)) : (delete s[m], s[m] = p));
    }
    if (b.kind === X.INLINE_FRAGMENT && (!b.typeCondition || n.cache.fragmentMatches(b, e.__typename)) && (p = Bl(e, b.selectionSet, n, r, a)), b.kind === X.FRAGMENT_SPREAD) {
      var x = b.name.value, S = n.fragmentMap[x] || (n.fragmentMap[x] = n.cache.lookupFragment(x));
      W(S, 59, x);
      var T = cj(b);
      T !== "mask" && (p = Bl(e, S.selectionSet, n, T === "migrate", a));
    }
    o.has(p) && o.add(s);
  }
  return "__typename" in e && !("__typename" in s) && (s.__typename = e.__typename), Object.keys(s).length !== Object.keys(e).length && o.add(s), o.has(s) ? s : e;
}
function sI(e, t, n, r, a) {
  var i = function() {
    return Wy.getValue() || (globalThis.__DEV__ !== !1 && W.warn(60, r ? "".concat(a, " '").concat(r, "'") : "anonymous ".concat(a), "".concat(n, ".").concat(e).replace(/^\./, "")), i = function() {
      return t;
    }), t;
  };
  return {
    get: function() {
      return i();
    },
    set: function(o) {
      i = function() {
        return o;
      };
    },
    enumerable: !0,
    configurable: !0
  };
}
function pA(e, t, n, r) {
  if (!n.fragmentMatches)
    return globalThis.__DEV__ !== !1 && dA(), e;
  var a = t.definitions.filter(function(o) {
    return o.kind === X.FRAGMENT_DEFINITION;
  });
  typeof r > "u" && (W(a.length === 1, 61, a.length), r = a[0].name.value);
  var i = a.find(function(o) {
    return o.name.value === r;
  });
  return W(!!i, 62, r), e == null || qe(e, {}) ? e : hA(e, i.selectionSet, {
    operationType: "fragment",
    operationName: i.name.value,
    fragmentMap: Zs(el(t)),
    cache: n,
    mutableTargets: new uA(),
    knownChanged: new fA()
  });
}
function lI(e, t, n) {
  var r;
  if (!n.fragmentMatches)
    return globalThis.__DEV__ !== !1 && dA(), e;
  var a = Ji(t);
  return W(a, 63), e == null ? e : hA(e, a.selectionSet, {
    operationType: a.operation,
    operationName: (r = a.name) === null || r === void 0 ? void 0 : r.value,
    fragmentMap: Zs(el(t)),
    cache: n,
    mutableTargets: new uA(),
    knownChanged: new fA()
  });
}
var mA = (
  /** @class */
  function() {
    function e() {
      this.assumeImmutableResults = !1, this.getFragmentDoc = kc(mj, {
        max: Kr["cache.fragmentQueryDocuments"] || 1e3,
        cache: pd
      });
    }
    return e.prototype.lookupFragment = function(t) {
      return null;
    }, e.prototype.batch = function(t) {
      var n = this, r = typeof t.optimistic == "string" ? t.optimistic : t.optimistic === !1 ? null : void 0, a;
      return this.performTransaction(function() {
        return a = t.update(n);
      }, r), a;
    }, e.prototype.recordOptimisticTransaction = function(t, n) {
      this.performTransaction(t, n);
    }, e.prototype.transformDocument = function(t) {
      return t;
    }, e.prototype.transformForLink = function(t) {
      return t;
    }, e.prototype.identify = function(t) {
    }, e.prototype.gc = function() {
      return [];
    }, e.prototype.modify = function(t) {
      return !1;
    }, e.prototype.readQuery = function(t, n) {
      var r = this;
      return n === void 0 && (n = !!t.optimistic), globalThis.__DEV__ !== !1 && st(t, "canonizeResults", "cache.readQuery"), Ut("canonizeResults", function() {
        return r.read(M(M({}, t), { rootId: t.id || "ROOT_QUERY", optimistic: n }));
      });
    }, e.prototype.watchFragment = function(t) {
      var n = this, r = t.fragment, a = t.fragmentName, i = t.from, o = t.optimistic, s = o === void 0 ? !0 : o, l = Ln(t, ["fragment", "fragmentName", "from", "optimistic"]), c = this.getFragmentDoc(r, a), u = typeof i > "u" || typeof i == "string" ? i : this.identify(i), f = !!t[Symbol.for("apollo.dataMasking")];
      if (globalThis.__DEV__ !== !1) {
        var d = a || N1(r).name.value;
        u || globalThis.__DEV__ !== !1 && W.warn(1, d);
      }
      var h = M(M({}, l), { returnPartialData: !0, id: u, query: c, optimistic: s }), g;
      return new ke(function(v) {
        return n.watch(M(M({}, h), { immediate: !0, callback: function(b) {
          var p = f ? pA(b.result, r, n, a) : b.result;
          if (
            // Always ensure we deliver the first result
            !(g && cA(
              c,
              { data: g.result },
              { data: p },
              // TODO: Fix the type on WatchFragmentOptions so that TVars
              // extends OperationVariables
              t.variables
            ))
          ) {
            var m = {
              data: p,
              complete: !!b.complete
            };
            b.missing && (m.missing = oh(b.missing.map(function(w) {
              return w.missing;
            }))), g = M(M({}, b), { result: p }), v.next(m);
          }
        } }));
      });
    }, e.prototype.readFragment = function(t, n) {
      var r = this;
      return n === void 0 && (n = !!t.optimistic), globalThis.__DEV__ !== !1 && st(t, "canonizeResults", "cache.readFragment"), Ut("canonizeResults", function() {
        return r.read(M(M({}, t), { query: r.getFragmentDoc(t.fragment, t.fragmentName), rootId: t.id, optimistic: n }));
      });
    }, e.prototype.writeQuery = function(t) {
      var n = t.id, r = t.data, a = Ln(t, ["id", "data"]);
      return this.write(Object.assign(a, {
        dataId: n || "ROOT_QUERY",
        result: r
      }));
    }, e.prototype.writeFragment = function(t) {
      var n = t.id, r = t.data, a = t.fragment, i = t.fragmentName, o = Ln(t, ["id", "data", "fragment", "fragmentName"]);
      return this.write(Object.assign(o, {
        query: this.getFragmentDoc(a, i),
        dataId: n,
        result: r
      }));
    }, e.prototype.updateQuery = function(t, n) {
      return globalThis.__DEV__ !== !1 && st(t, "canonizeResults", "cache.updateQuery"), this.batch({
        update: function(r) {
          var a = Ut("canonizeResults", function() {
            return r.readQuery(t);
          }), i = n(a);
          return i == null ? a : (r.writeQuery(M(M({}, t), { data: i })), i);
        }
      });
    }, e.prototype.updateFragment = function(t, n) {
      return globalThis.__DEV__ !== !1 && st(t, "canonizeResults", "cache.updateFragment"), this.batch({
        update: function(r) {
          var a = Ut("canonizeResults", function() {
            return r.readFragment(t);
          }), i = n(a);
          return i == null ? a : (r.writeFragment(M(M({}, t), { data: i })), i);
        }
      });
    }, e;
  }()
);
globalThis.__DEV__ !== !1 && (mA.prototype.getMemoryInternals = Aj);
var gA = (
  /** @class */
  function(e) {
    Yn(t, e);
    function t(n, r, a, i) {
      var o, s = e.call(this, n) || this;
      if (s.message = n, s.path = r, s.query = a, s.variables = i, Array.isArray(s.path)) {
        s.missing = s.message;
        for (var l = s.path.length - 1; l >= 0; --l)
          s.missing = (o = {}, o[s.path[l]] = s.missing, o);
      } else
        s.missing = s.path;
      return s.__proto__ = t.prototype, s;
    }
    return t;
  }(Error)
), At = Object.prototype.hasOwnProperty;
function Tl(e) {
  return e == null;
}
function vA(e, t) {
  var n = e.__typename, r = e.id, a = e._id;
  if (typeof n == "string" && (t && (t.keyObject = Tl(r) ? Tl(a) ? void 0 : { _id: a } : { id: r }), Tl(r) && !Tl(a) && (r = a), !Tl(r)))
    return "".concat(n, ":").concat(typeof r == "number" || typeof r == "string" ? r : JSON.stringify(r));
}
var yA = {
  dataIdFromObject: vA,
  addTypename: !0,
  resultCaching: !0,
  // Thanks to the shouldCanonizeResults helper, this should be the only line
  // you have to change to reenable canonization by default in the future.
  canonizeResults: !1
};
function cI(e) {
  return Is(yA, e);
}
function bA(e) {
  var t = e.canonizeResults;
  return t === void 0 ? yA.canonizeResults : t;
}
function uI(e, t) {
  return Me(t) ? e.get(t.__ref, "__typename") : t && t.__typename;
}
var wA = /^[_a-z][_0-9a-z]*/i;
function ri(e) {
  var t = e.match(wA);
  return t ? t[0] : e;
}
function Pg(e, t, n) {
  return it(t) ? ot(t) ? t.every(function(r) {
    return Pg(e, r, n);
  }) : e.selections.every(function(r) {
    if (ei(r) && uu(r, n)) {
      var a = Xr(r);
      return At.call(t, a) && (!r.selectionSet || Pg(r.selectionSet, t[a], n));
    }
    return !0;
  }) : !1;
}
function Go(e) {
  return it(e) && !Me(e) && !ot(e);
}
function fI() {
  return new ni();
}
function xA(e, t) {
  var n = Zs(el(e));
  return {
    fragmentMap: n,
    lookupFragment: function(r) {
      var a = n[r];
      return !a && t && (a = t.lookup(r)), a || null;
    }
  };
}
var _f = /* @__PURE__ */ Object.create(null), Op = function() {
  return _f;
}, Ax = /* @__PURE__ */ Object.create(null), Lc = (
  /** @class */
  function() {
    function e(t, n) {
      var r = this;
      this.policies = t, this.group = n, this.data = /* @__PURE__ */ Object.create(null), this.rootIds = /* @__PURE__ */ Object.create(null), this.refs = /* @__PURE__ */ Object.create(null), this.getFieldValue = function(a, i) {
        return gd(Me(a) ? r.get(a.__ref, i) : a && a[i]);
      }, this.canRead = function(a) {
        return Me(a) ? r.has(a.__ref) : typeof a == "object";
      }, this.toReference = function(a, i) {
        if (typeof a == "string")
          return as(a);
        if (Me(a))
          return a;
        var o = r.policies.identify(a)[0];
        if (o) {
          var s = as(o);
          return i && r.merge(o, a), s;
        }
      };
    }
    return e.prototype.toObject = function() {
      return M({}, this.data);
    }, e.prototype.has = function(t) {
      return this.lookup(t, !0) !== void 0;
    }, e.prototype.get = function(t, n) {
      if (this.group.depend(t, n), At.call(this.data, t)) {
        var r = this.data[t];
        if (r && At.call(r, n))
          return r[n];
      }
      if (n === "__typename" && At.call(this.policies.rootTypenamesById, t))
        return this.policies.rootTypenamesById[t];
      if (this instanceof fa)
        return this.parent.get(t, n);
    }, e.prototype.lookup = function(t, n) {
      if (n && this.group.depend(t, "__exists"), At.call(this.data, t))
        return this.data[t];
      if (this instanceof fa)
        return this.parent.lookup(t, n);
      if (this.policies.rootTypenamesById[t])
        return /* @__PURE__ */ Object.create(null);
    }, e.prototype.merge = function(t, n) {
      var r = this, a;
      Me(t) && (t = t.__ref), Me(n) && (n = n.__ref);
      var i = typeof t == "string" ? this.lookup(a = t) : t, o = typeof n == "string" ? this.lookup(a = n) : n;
      if (o) {
        W(typeof a == "string", 2);
        var s = new ni(hI).merge(i, o);
        if (this.data[a] = s, s !== i && (delete this.refs[a], this.group.caching)) {
          var l = /* @__PURE__ */ Object.create(null);
          i || (l.__exists = 1), Object.keys(o).forEach(function(c) {
            if (!i || i[c] !== s[c]) {
              l[c] = 1;
              var u = ri(c);
              u !== c && !r.policies.hasKeyArgs(s.__typename, u) && (l[u] = 1), s[c] === void 0 && !(r instanceof fa) && delete s[c];
            }
          }), l.__typename && !(i && i.__typename) && // Since we return default root __typename strings
          // automatically from store.get, we don't need to dirty the
          // ROOT_QUERY.__typename field if merged.__typename is equal
          // to the default string (usually "Query").
          this.policies.rootTypenamesById[a] === s.__typename && delete l.__typename, Object.keys(l).forEach(function(c) {
            return r.group.dirty(a, c);
          });
        }
      }
    }, e.prototype.modify = function(t, n) {
      var r = this, a = this.lookup(t);
      if (a) {
        var i = /* @__PURE__ */ Object.create(null), o = !1, s = !0, l = {
          DELETE: _f,
          INVALIDATE: Ax,
          isReference: Me,
          toReference: this.toReference,
          canRead: this.canRead,
          readField: function(c, u) {
            return r.policies.readField(typeof c == "string" ? {
              fieldName: c,
              from: u || as(t)
            } : c, { store: r });
          }
        };
        if (Object.keys(a).forEach(function(c) {
          var u = ri(c), f = a[c];
          if (f !== void 0) {
            var d = typeof n == "function" ? n : n[c] || n[u];
            if (d) {
              var h = d === Op ? _f : d(gd(f), M(M({}, l), { fieldName: u, storeFieldName: c, storage: r.getStorage(t, c) }));
              if (h === Ax)
                r.group.dirty(t, c);
              else if (h === _f && (h = void 0), h !== f && (i[c] = h, o = !0, f = h, globalThis.__DEV__ !== !1)) {
                var g = function(S) {
                  if (r.lookup(S.__ref) === void 0)
                    return globalThis.__DEV__ !== !1 && W.warn(3, S), !0;
                };
                if (Me(h))
                  g(h);
                else if (Array.isArray(h))
                  for (var v = !1, b = void 0, p = 0, m = h; p < m.length; p++) {
                    var w = m[p];
                    if (Me(w)) {
                      if (v = !0, g(w))
                        break;
                    } else if (typeof w == "object" && w) {
                      var x = r.policies.identify(w)[0];
                      x && (b = w);
                    }
                    if (v && b !== void 0) {
                      globalThis.__DEV__ !== !1 && W.warn(4, b);
                      break;
                    }
                  }
              }
            }
            f !== void 0 && (s = !1);
          }
        }), o)
          return this.merge(t, i), s && (this instanceof fa ? this.data[t] = void 0 : delete this.data[t], this.group.dirty(t, "__exists")), !0;
      }
      return !1;
    }, e.prototype.delete = function(t, n, r) {
      var a, i = this.lookup(t);
      if (i) {
        var o = this.getFieldValue(i, "__typename"), s = n && r ? this.policies.getStoreFieldName({ typename: o, fieldName: n, args: r }) : n;
        return this.modify(t, s ? (a = {}, a[s] = Op, a) : Op);
      }
      return !1;
    }, e.prototype.evict = function(t, n) {
      var r = !1;
      return t.id && (At.call(this.data, t.id) && (r = this.delete(t.id, t.fieldName, t.args)), this instanceof fa && this !== n && (r = this.parent.evict(t, n) || r), (t.fieldName || r) && this.group.dirty(t.id, t.fieldName || "__exists")), r;
    }, e.prototype.clear = function() {
      this.replace(null);
    }, e.prototype.extract = function() {
      var t = this, n = this.toObject(), r = [];
      return this.getRootIdSet().forEach(function(a) {
        At.call(t.policies.rootTypenamesById, a) || r.push(a);
      }), r.length && (n.__META = { extraRootIds: r.sort() }), n;
    }, e.prototype.replace = function(t) {
      var n = this;
      if (Object.keys(this.data).forEach(function(i) {
        t && At.call(t, i) || n.delete(i);
      }), t) {
        var r = t.__META, a = Ln(t, ["__META"]);
        Object.keys(a).forEach(function(i) {
          n.merge(i, a[i]);
        }), r && r.extraRootIds.forEach(this.retain, this);
      }
    }, e.prototype.retain = function(t) {
      return this.rootIds[t] = (this.rootIds[t] || 0) + 1;
    }, e.prototype.release = function(t) {
      if (this.rootIds[t] > 0) {
        var n = --this.rootIds[t];
        return n || delete this.rootIds[t], n;
      }
      return 0;
    }, e.prototype.getRootIdSet = function(t) {
      return t === void 0 && (t = /* @__PURE__ */ new Set()), Object.keys(this.rootIds).forEach(t.add, t), this instanceof fa ? this.parent.getRootIdSet(t) : Object.keys(this.policies.rootTypenamesById).forEach(t.add, t), t;
    }, e.prototype.gc = function() {
      var t = this, n = this.getRootIdSet(), r = this.toObject();
      n.forEach(function(o) {
        At.call(r, o) && (Object.keys(t.findChildRefIds(o)).forEach(n.add, n), delete r[o]);
      });
      var a = Object.keys(r);
      if (a.length) {
        for (var i = this; i instanceof fa; )
          i = i.parent;
        a.forEach(function(o) {
          return i.delete(o);
        });
      }
      return a;
    }, e.prototype.findChildRefIds = function(t) {
      if (!At.call(this.refs, t)) {
        var n = this.refs[t] = /* @__PURE__ */ Object.create(null), r = this.data[t];
        if (!r)
          return n;
        var a = /* @__PURE__ */ new Set([r]);
        a.forEach(function(i) {
          Me(i) && (n[i.__ref] = !0), it(i) && Object.keys(i).forEach(function(o) {
            var s = i[o];
            it(s) && a.add(s);
          });
        });
      }
      return this.refs[t];
    }, e.prototype.makeCacheKey = function() {
      return this.group.keyMaker.lookupArray(arguments);
    }, e;
  }()
), EA = (
  /** @class */
  function() {
    function e(t, n) {
      n === void 0 && (n = null), this.caching = t, this.parent = n, this.d = null, this.resetCaching();
    }
    return e.prototype.resetCaching = function() {
      this.d = this.caching ? B1() : null, this.keyMaker = new na(uo);
    }, e.prototype.depend = function(t, n) {
      if (this.d) {
        this.d(Ap(t, n));
        var r = ri(n);
        r !== n && this.d(Ap(t, r)), this.parent && this.parent.depend(t, n);
      }
    }, e.prototype.dirty = function(t, n) {
      this.d && this.d.dirty(
        Ap(t, n),
        // When storeFieldName === "__exists", that means the entity identified
        // by dataId has either disappeared from the cache or was newly added,
        // so the result caching system would do well to "forget everything it
        // knows" about that object. To achieve that kind of invalidation, we
        // not only dirty the associated result cache entry, but also remove it
        // completely from the dependency graph. For the optimism implementation
        // details, see https://github.com/benjamn/optimism/pull/195.
        n === "__exists" ? "forget" : "setDirty"
      );
    }, e;
  }()
);
function Ap(e, t) {
  return t + "#" + e;
}
function Rx(e, t) {
  oc(e) && e.group.depend(t, "__exists");
}
(function(e) {
  var t = (
    /** @class */
    function(n) {
      Yn(r, n);
      function r(a) {
        var i = a.policies, o = a.resultCaching, s = o === void 0 ? !0 : o, l = a.seed, c = n.call(this, i, new EA(s)) || this;
        return c.stump = new dI(c), c.storageTrie = new na(uo), l && c.replace(l), c;
      }
      return r.prototype.addLayer = function(a, i) {
        return this.stump.addLayer(a, i);
      }, r.prototype.removeLayer = function() {
        return this;
      }, r.prototype.getStorage = function() {
        return this.storageTrie.lookupArray(arguments);
      }, r;
    }(e)
  );
  e.Root = t;
})(Lc || (Lc = {}));
var fa = (
  /** @class */
  function(e) {
    Yn(t, e);
    function t(n, r, a, i) {
      var o = e.call(this, r.policies, i) || this;
      return o.id = n, o.parent = r, o.replay = a, o.group = i, a(o), o;
    }
    return t.prototype.addLayer = function(n, r) {
      return new t(n, this, r, this.group);
    }, t.prototype.removeLayer = function(n) {
      var r = this, a = this.parent.removeLayer(n);
      return n === this.id ? (this.group.caching && Object.keys(this.data).forEach(function(i) {
        var o = r.data[i], s = a.lookup(i);
        s ? o ? o !== s && Object.keys(o).forEach(function(l) {
          qe(o[l], s[l]) || r.group.dirty(i, l);
        }) : (r.group.dirty(i, "__exists"), Object.keys(s).forEach(function(l) {
          r.group.dirty(i, l);
        })) : r.delete(i);
      }), a) : a === this.parent ? this : a.addLayer(this.id, this.replay);
    }, t.prototype.toObject = function() {
      return M(M({}, this.parent.toObject()), this.data);
    }, t.prototype.findChildRefIds = function(n) {
      var r = this.parent.findChildRefIds(n);
      return At.call(this.data, n) ? M(M({}, r), e.prototype.findChildRefIds.call(this, n)) : r;
    }, t.prototype.getStorage = function() {
      for (var n = this.parent; n.parent; )
        n = n.parent;
      return n.getStorage.apply(
        n,
        // @ts-expect-error
        arguments
      );
    }, t;
  }(Lc)
), dI = (
  /** @class */
  function(e) {
    Yn(t, e);
    function t(n) {
      return e.call(this, "EntityStore.Stump", n, function() {
      }, new EA(n.group.caching, n.group)) || this;
    }
    return t.prototype.removeLayer = function() {
      return this;
    }, t.prototype.merge = function(n, r) {
      return this.parent.merge(n, r);
    }, t;
  }(fa)
);
function hI(e, t, n) {
  var r = e[n], a = t[n];
  return qe(r, a) ? r : a;
}
function oc(e) {
  return !!(e instanceof Lc && e.group.caching);
}
function pI(e) {
  return it(e) ? ot(e) ? e.slice(0) : M({ __proto__: Object.getPrototypeOf(e) }, e) : e;
}
var _x = (
  /** @class */
  function() {
    function e() {
      this.known = new (Uy ? WeakSet : Set)(), this.pool = new na(uo), this.passes = /* @__PURE__ */ new WeakMap(), this.keysByJSON = /* @__PURE__ */ new Map(), this.empty = this.admit({});
    }
    return e.prototype.isKnown = function(t) {
      return it(t) && this.known.has(t);
    }, e.prototype.pass = function(t) {
      if (it(t)) {
        var n = pI(t);
        return this.passes.set(n, t), n;
      }
      return t;
    }, e.prototype.admit = function(t) {
      var n = this;
      if (it(t)) {
        var r = this.passes.get(t);
        if (r)
          return r;
        var a = Object.getPrototypeOf(t);
        switch (a) {
          case Array.prototype: {
            if (this.known.has(t))
              return t;
            var i = t.map(this.admit, this), o = this.pool.lookupArray(i);
            return o.array || (this.known.add(o.array = i), globalThis.__DEV__ !== !1 && Object.freeze(i)), o.array;
          }
          case null:
          case Object.prototype: {
            if (this.known.has(t))
              return t;
            var s = Object.getPrototypeOf(t), l = [s], c = this.sortedKeys(t);
            l.push(c.json);
            var u = l.length;
            c.sorted.forEach(function(h) {
              l.push(n.admit(t[h]));
            });
            var o = this.pool.lookupArray(l);
            if (!o.object) {
              var f = o.object = Object.create(s);
              this.known.add(f), c.sorted.forEach(function(h, g) {
                f[h] = l[u + g];
              }), globalThis.__DEV__ !== !1 && Object.freeze(f);
            }
            return o.object;
          }
        }
      }
      return t;
    }, e.prototype.sortedKeys = function(t) {
      var n = Object.keys(t), r = this.pool.lookupArray(n);
      if (!r.keys) {
        n.sort();
        var a = JSON.stringify(n);
        (r.keys = this.keysByJSON.get(a)) || this.keysByJSON.set(a, r.keys = { sorted: n, json: a });
      }
      return r.keys;
    }, e;
  }()
);
function Dx(e) {
  return [
    e.selectionSet,
    e.objectOrReference,
    e.context,
    // We split out this property so we can pass different values
    // independently without modifying options.context itself.
    e.context.canonizeResults
  ];
}
var mI = (
  /** @class */
  function() {
    function e(t) {
      var n = this;
      this.knownResults = new (uo ? WeakMap : Map)(), this.config = Is(t, {
        addTypename: t.addTypename !== !1,
        canonizeResults: bA(t)
      }), this.canon = t.canon || new _x(), this.executeSelectionSet = kc(function(r) {
        var a, i = r.context.canonizeResults, o = Dx(r);
        o[3] = !i;
        var s = (a = n.executeSelectionSet).peek.apply(a, o);
        return s ? i ? M(M({}, s), {
          // If we previously read this result without canonizing it, we can
          // reuse that result simply by canonizing it now.
          result: n.canon.admit(s.result)
        }) : s : (Rx(r.context.store, r.enclosingRef.__ref), n.execSelectionSetImpl(r));
      }, {
        max: this.config.resultCacheMaxSize || Kr["inMemoryCache.executeSelectionSet"] || 5e4,
        keyArgs: Dx,
        // Note that the parameters of makeCacheKey are determined by the
        // array returned by keyArgs.
        makeCacheKey: function(r, a, i, o) {
          if (oc(i.store))
            return i.store.makeCacheKey(r, Me(a) ? a.__ref : a, i.varString, o);
        }
      }), this.executeSubSelectedArray = kc(function(r) {
        return Rx(r.context.store, r.enclosingRef.__ref), n.execSubSelectedArrayImpl(r);
      }, {
        max: this.config.resultCacheMaxSize || Kr["inMemoryCache.executeSubSelectedArray"] || 1e4,
        makeCacheKey: function(r) {
          var a = r.field, i = r.array, o = r.context;
          if (oc(o.store))
            return o.store.makeCacheKey(a, i, o.varString);
        }
      });
    }
    return e.prototype.resetCanon = function() {
      this.canon = new _x();
    }, e.prototype.diffQueryAgainstStore = function(t) {
      var n = t.store, r = t.query, a = t.rootId, i = a === void 0 ? "ROOT_QUERY" : a, o = t.variables, s = t.returnPartialData, l = s === void 0 ? !0 : s, c = t.canonizeResults, u = c === void 0 ? this.config.canonizeResults : c, f = this.config.cache.policies;
      o = M(M({}, By(D1(r))), o);
      var d = as(i), h = this.executeSelectionSet({
        selectionSet: fu(r).selectionSet,
        objectOrReference: d,
        enclosingRef: d,
        context: M({ store: n, query: r, policies: f, variables: o, varString: Ya(o), canonizeResults: u }, xA(r, this.config.fragments))
      }), g;
      if (h.missing && (g = [
        new gA(gI(h.missing), h.missing, r, o)
      ], !l))
        throw g[0];
      return {
        result: h.result,
        complete: !g,
        missing: g
      };
    }, e.prototype.isFresh = function(t, n, r, a) {
      if (oc(a.store) && this.knownResults.get(t) === r) {
        var i = this.executeSelectionSet.peek(
          r,
          n,
          a,
          // If result is canonical, then it could only have been previously
          // cached by the canonizing version of executeSelectionSet, so we can
          // avoid checking both possibilities here.
          this.canon.isKnown(t)
        );
        if (i && t === i.result)
          return !0;
      }
      return !1;
    }, e.prototype.execSelectionSetImpl = function(t) {
      var n = this, r = t.selectionSet, a = t.objectOrReference, i = t.enclosingRef, o = t.context;
      if (Me(a) && !o.policies.rootTypenamesById[a.__ref] && !o.store.has(a.__ref))
        return {
          result: this.canon.empty,
          missing: "Dangling reference to missing ".concat(a.__ref, " object")
        };
      var s = o.variables, l = o.policies, c = o.store, u = c.getFieldValue(a, "__typename"), f = [], d, h = new ni();
      this.config.addTypename && typeof u == "string" && !l.rootIdsByTypename[u] && f.push({ __typename: u });
      function g(w, x) {
        var S;
        return w.missing && (d = h.merge(d, (S = {}, S[x] = w.missing, S))), w.result;
      }
      var v = new Set(r.selections);
      v.forEach(function(w) {
        var x, S;
        if (uu(w, s))
          if (ei(w)) {
            var T = l.readField({
              fieldName: w.name.value,
              field: w,
              variables: o.variables,
              from: a
            }, o), E = Xr(w);
            T === void 0 ? $y.added(w) || (d = h.merge(d, (x = {}, x[E] = "Can't find field '".concat(w.name.value, "' on ").concat(Me(a) ? a.__ref + " object" : "object " + JSON.stringify(a, null, 2)), x))) : ot(T) ? T.length > 0 && (T = g(n.executeSubSelectedArray({
              field: w,
              array: T,
              enclosingRef: i,
              context: o
            }), E)) : w.selectionSet ? T != null && (T = g(n.executeSelectionSet({
              selectionSet: w.selectionSet,
              objectOrReference: T,
              enclosingRef: Me(T) ? T : i,
              context: o
            }), E)) : o.canonizeResults && (T = n.canon.pass(T)), T !== void 0 && f.push((S = {}, S[E] = T, S));
          } else {
            var O = nh(w, o.lookupFragment);
            if (!O && w.kind === X.FRAGMENT_SPREAD)
              throw Gt(10, w.name.value);
            O && l.fragmentMatches(O, u) && O.selectionSet.selections.forEach(v.add, v);
          }
      });
      var b = oh(f), p = { result: b, missing: d }, m = o.canonizeResults ? this.canon.admit(p) : gd(p);
      return m.result && this.knownResults.set(m.result, r), m;
    }, e.prototype.execSubSelectedArrayImpl = function(t) {
      var n = this, r = t.field, a = t.array, i = t.enclosingRef, o = t.context, s, l = new ni();
      function c(u, f) {
        var d;
        return u.missing && (s = l.merge(s, (d = {}, d[f] = u.missing, d))), u.result;
      }
      return r.selectionSet && (a = a.filter(o.store.canRead)), a = a.map(function(u, f) {
        return u === null ? null : ot(u) ? c(n.executeSubSelectedArray({
          field: r,
          array: u,
          enclosingRef: i,
          context: o
        }), f) : r.selectionSet ? c(n.executeSelectionSet({
          selectionSet: r.selectionSet,
          objectOrReference: u,
          enclosingRef: Me(u) ? u : i,
          context: o
        }), f) : (globalThis.__DEV__ !== !1 && vI(o.store, r, u), u);
      }), {
        result: o.canonizeResults ? this.canon.admit(a) : a,
        missing: s
      };
    }, e;
  }()
);
function gI(e) {
  try {
    JSON.stringify(e, function(t, n) {
      if (typeof n == "string")
        throw n;
      return n;
    });
  } catch (t) {
    return t;
  }
}
function vI(e, t, n) {
  if (!t.selectionSet) {
    var r = /* @__PURE__ */ new Set([n]);
    r.forEach(function(a) {
      it(a) && (W(
        !Me(a),
        11,
        uI(e, a),
        t.name.value
      ), Object.values(a).forEach(r.add, r));
    });
  }
}
var Zy = new tl(), Nx = /* @__PURE__ */ new WeakMap();
function sc(e) {
  var t = Nx.get(e);
  return t || Nx.set(e, t = {
    vars: /* @__PURE__ */ new Set(),
    dep: B1()
  }), t;
}
function kx(e) {
  sc(e).vars.forEach(function(t) {
    return t.forgetCache(e);
  });
}
function yI(e) {
  sc(e).vars.forEach(function(t) {
    return t.attachCache(e);
  });
}
function bI(e) {
  var t = /* @__PURE__ */ new Set(), n = /* @__PURE__ */ new Set(), r = function(i) {
    if (arguments.length > 0) {
      if (e !== i) {
        e = i, t.forEach(function(l) {
          sc(l).dep.dirty(r), wI(l);
        });
        var o = Array.from(n);
        n.clear(), o.forEach(function(l) {
          return l(e);
        });
      }
    } else {
      var s = Zy.getValue();
      s && (a(s), sc(s).dep(r));
    }
    return e;
  };
  r.onNextChange = function(i) {
    return n.add(i), function() {
      n.delete(i);
    };
  };
  var a = r.attachCache = function(i) {
    return t.add(i), sc(i).vars.add(r), r;
  };
  return r.forgetCache = function(i) {
    return t.delete(i);
  }, r;
}
function wI(e) {
  e.broadcastWatches && e.broadcastWatches();
}
var Mx = /* @__PURE__ */ Object.create(null);
function Jy(e) {
  var t = JSON.stringify(e);
  return Mx[t] || (Mx[t] = /* @__PURE__ */ Object.create(null));
}
function Lx(e) {
  var t = Jy(e);
  return t.keyFieldsFn || (t.keyFieldsFn = function(n, r) {
    var a = function(o, s) {
      return r.readField(s, o);
    }, i = r.keyObject = eb(e, function(o) {
      var s = os(
        r.storeObject,
        o,
        // Using context.readField to extract paths from context.storeObject
        // allows the extraction to see through Reference objects and respect
        // custom read functions.
        a
      );
      return s === void 0 && n !== r.storeObject && At.call(n, o[0]) && (s = os(n, o, TA)), W(s !== void 0, 5, o.join("."), n), s;
    });
    return "".concat(r.typename, ":").concat(JSON.stringify(i));
  });
}
function zx(e) {
  var t = Jy(e);
  return t.keyArgsFn || (t.keyArgsFn = function(n, r) {
    var a = r.field, i = r.variables, o = r.fieldName, s = eb(e, function(c) {
      var u = c[0], f = u.charAt(0);
      if (f === "@") {
        if (a && ur(a.directives)) {
          var d = u.slice(1), h = a.directives.find(function(p) {
            return p.name.value === d;
          }), g = h && rh(h, i);
          return g && os(
            g,
            // If keyPath.length === 1, this code calls extractKeyPath with an
            // empty path, which works because it uses directiveArgs as the
            // extracted value.
            c.slice(1)
          );
        }
        return;
      }
      if (f === "$") {
        var v = u.slice(1);
        if (i && At.call(i, v)) {
          var b = c.slice(0);
          return b[0] = v, os(i, b);
        }
        return;
      }
      if (n)
        return os(n, c);
    }), l = JSON.stringify(s);
    return (n || l !== "{}") && (o += ":" + l), o;
  });
}
function eb(e, t) {
  var n = new ni();
  return SA(e).reduce(function(r, a) {
    var i, o = t(a);
    if (o !== void 0) {
      for (var s = a.length - 1; s >= 0; --s)
        o = (i = {}, i[a[s]] = o, i);
      r = n.merge(r, o);
    }
    return r;
  }, /* @__PURE__ */ Object.create(null));
}
function SA(e) {
  var t = Jy(e);
  if (!t.paths) {
    var n = t.paths = [], r = [];
    e.forEach(function(a, i) {
      ot(a) ? (SA(a).forEach(function(o) {
        return n.push(r.concat(o));
      }), r.length = 0) : (r.push(a), ot(e[i + 1]) || (n.push(r.slice(0)), r.length = 0));
    });
  }
  return t.paths;
}
function TA(e, t) {
  return e[t];
}
function os(e, t, n) {
  return n = n || TA, CA(t.reduce(function r(a, i) {
    return ot(a) ? a.map(function(o) {
      return r(o, i);
    }) : a && n(a, i);
  }, e));
}
function CA(e) {
  return it(e) ? ot(e) ? e.map(CA) : eb(Object.keys(e).sort(), function(t) {
    return os(e, t);
  }) : e;
}
function Ig(e) {
  return e.args !== void 0 ? e.args : e.field ? rh(e.field, e.variables) : null;
}
var xI = function() {
}, jx = function(e, t) {
  return t.fieldName;
}, Px = function(e, t, n) {
  var r = n.mergeObjects;
  return r(e, t);
}, Ix = function(e, t) {
  return t;
}, EI = (
  /** @class */
  function() {
    function e(t) {
      this.config = t, this.typePolicies = /* @__PURE__ */ Object.create(null), this.toBeAdded = /* @__PURE__ */ Object.create(null), this.supertypeMap = /* @__PURE__ */ new Map(), this.fuzzySubtypes = /* @__PURE__ */ new Map(), this.rootIdsByTypename = /* @__PURE__ */ Object.create(null), this.rootTypenamesById = /* @__PURE__ */ Object.create(null), this.usingPossibleTypes = !1, this.config = M({ dataIdFromObject: vA }, t), this.cache = this.config.cache, this.setRootTypename("Query"), this.setRootTypename("Mutation"), this.setRootTypename("Subscription"), t.possibleTypes && this.addPossibleTypes(t.possibleTypes), t.typePolicies && this.addTypePolicies(t.typePolicies);
    }
    return e.prototype.identify = function(t, n) {
      var r, a = this, i = n && (n.typename || ((r = n.storeObject) === null || r === void 0 ? void 0 : r.__typename)) || t.__typename;
      if (i === this.rootTypenamesById.ROOT_QUERY)
        return ["ROOT_QUERY"];
      var o = n && n.storeObject || t, s = M(M({}, n), { typename: i, storeObject: o, readField: n && n.readField || function() {
        var f = tb(arguments, o);
        return a.readField(f, {
          store: a.cache.data,
          variables: f.variables
        });
      } }), l, c = i && this.getTypePolicy(i), u = c && c.keyFn || this.config.dataIdFromObject;
      return Wy.withValue(!0, function() {
        for (; u; ) {
          var f = u(M(M({}, t), o), s);
          if (ot(f))
            u = Lx(f);
          else {
            l = f;
            break;
          }
        }
      }), l = l ? String(l) : void 0, s.keyObject ? [l, s.keyObject] : [l];
    }, e.prototype.addTypePolicies = function(t) {
      var n = this;
      Object.keys(t).forEach(function(r) {
        var a = t[r], i = a.queryType, o = a.mutationType, s = a.subscriptionType, l = Ln(a, ["queryType", "mutationType", "subscriptionType"]);
        i && n.setRootTypename("Query", r), o && n.setRootTypename("Mutation", r), s && n.setRootTypename("Subscription", r), At.call(n.toBeAdded, r) ? n.toBeAdded[r].push(l) : n.toBeAdded[r] = [l];
      });
    }, e.prototype.updateTypePolicy = function(t, n, r) {
      var a = this.getTypePolicy(t), i = n.keyFields, o = n.fields;
      function s(l, c) {
        l.merge = typeof c == "function" ? c : c === !0 ? Px : c === !1 ? Ix : l.merge;
      }
      s(a, n.merge), a.keyFn = // Pass false to disable normalization for this typename.
      i === !1 ? xI : ot(i) ? Lx(i) : typeof i == "function" ? i : a.keyFn, o && Object.keys(o).forEach(function(l) {
        var c = r[l];
        (!c || (c == null ? void 0 : c.typename) !== t) && (c = r[l] = { typename: t });
        var u = o[l];
        if (typeof u == "function")
          c.read = u;
        else {
          var f = u.keyArgs, d = u.read, h = u.merge;
          c.keyFn = // Pass false to disable argument-based differentiation of
          // field identities.
          f === !1 ? jx : ot(f) ? zx(f) : typeof f == "function" ? f : c.keyFn, typeof d == "function" && (c.read = d), s(c, h);
        }
        c.read && c.merge && (c.keyFn = c.keyFn || jx);
      });
    }, e.prototype.setRootTypename = function(t, n) {
      n === void 0 && (n = t);
      var r = "ROOT_" + t.toUpperCase(), a = this.rootTypenamesById[r];
      n !== a && (W(!a || a === t, 6, t), a && delete this.rootIdsByTypename[a], this.rootIdsByTypename[n] = r, this.rootTypenamesById[r] = n);
    }, e.prototype.addPossibleTypes = function(t) {
      var n = this;
      this.usingPossibleTypes = !0, Object.keys(t).forEach(function(r) {
        n.getSupertypeSet(r, !0), t[r].forEach(function(a) {
          n.getSupertypeSet(a, !0).add(r);
          var i = a.match(wA);
          (!i || i[0] !== a) && n.fuzzySubtypes.set(a, new RegExp(a));
        });
      });
    }, e.prototype.getTypePolicy = function(t) {
      var n = this;
      if (!At.call(this.typePolicies, t)) {
        var r = this.typePolicies[t] = /* @__PURE__ */ Object.create(null);
        r.fields = /* @__PURE__ */ Object.create(null);
        var a = this.supertypeMap.get(t);
        !a && this.fuzzySubtypes.size && (a = this.getSupertypeSet(t, !0), this.fuzzySubtypes.forEach(function(o, s) {
          if (o.test(t)) {
            var l = n.supertypeMap.get(s);
            l && l.forEach(function(c) {
              return a.add(c);
            });
          }
        })), a && a.size && a.forEach(function(o) {
          var s = n.getTypePolicy(o), l = s.fields, c = Ln(s, ["fields"]);
          Object.assign(r, c), Object.assign(r.fields, l);
        });
      }
      var i = this.toBeAdded[t];
      return i && i.length && i.splice(0).forEach(function(o) {
        n.updateTypePolicy(t, o, n.typePolicies[t].fields);
      }), this.typePolicies[t];
    }, e.prototype.getFieldPolicy = function(t, n) {
      if (t)
        return this.getTypePolicy(t).fields[n];
    }, e.prototype.getSupertypeSet = function(t, n) {
      var r = this.supertypeMap.get(t);
      return !r && n && this.supertypeMap.set(t, r = /* @__PURE__ */ new Set()), r;
    }, e.prototype.fragmentMatches = function(t, n, r, a) {
      var i = this;
      if (!t.typeCondition)
        return !0;
      if (!n)
        return !1;
      var o = t.typeCondition.name.value;
      if (n === o)
        return !0;
      if (this.usingPossibleTypes && this.supertypeMap.has(o))
        for (var s = this.getSupertypeSet(n, !0), l = [s], c = function(g) {
          var v = i.getSupertypeSet(g, !1);
          v && v.size && l.indexOf(v) < 0 && l.push(v);
        }, u = !!(r && this.fuzzySubtypes.size), f = !1, d = 0; d < l.length; ++d) {
          var h = l[d];
          if (h.has(o))
            return s.has(o) || (f && globalThis.__DEV__ !== !1 && W.warn(7, n, o), s.add(o)), !0;
          h.forEach(c), u && // Start checking fuzzy subtypes only after exhausting all
          // non-fuzzy subtypes (after the final iteration of the loop).
          d === l.length - 1 && // We could wait to compare fragment.selectionSet to result
          // after we verify the supertype, but this check is often less
          // expensive than that search, and we will have to do the
          // comparison anyway whenever we find a potential match.
          Pg(t.selectionSet, r, a) && (u = !1, f = !0, this.fuzzySubtypes.forEach(function(g, v) {
            var b = n.match(g);
            b && b[0] === n && c(v);
          }));
        }
      return !1;
    }, e.prototype.hasKeyArgs = function(t, n) {
      var r = this.getFieldPolicy(t, n);
      return !!(r && r.keyFn);
    }, e.prototype.getStoreFieldName = function(t) {
      var n = t.typename, r = t.fieldName, a = this.getFieldPolicy(n, r), i, o = a && a.keyFn;
      if (o && n)
        for (var s = {
          typename: n,
          fieldName: r,
          field: t.field || null,
          variables: t.variables
        }, l = Ig(t); o; ) {
          var c = o(l, s);
          if (ot(c))
            o = zx(c);
          else {
            i = c || r;
            break;
          }
        }
      return i === void 0 && (i = t.field ? Qj(t.field, t.variables) : _1(r, Ig(t))), i === !1 ? r : r === ri(i) ? i : r + ":" + i;
    }, e.prototype.readField = function(t, n) {
      var r = t.from;
      if (r) {
        var a = t.field || t.fieldName;
        if (a) {
          if (t.typename === void 0) {
            var i = n.store.getFieldValue(r, "__typename");
            i && (t.typename = i);
          }
          var o = this.getStoreFieldName(t), s = ri(o), l = n.store.getFieldValue(r, o), c = this.getFieldPolicy(t.typename, s), u = c && c.read;
          if (u) {
            var f = Fx(this, r, t, n, n.store.getStorage(Me(r) ? r.__ref : r, o));
            return Zy.withValue(this.cache, u, [
              l,
              f
            ]);
          }
          return l;
        }
      }
    }, e.prototype.getReadFunction = function(t, n) {
      var r = this.getFieldPolicy(t, n);
      return r && r.read;
    }, e.prototype.getMergeFunction = function(t, n, r) {
      var a = this.getFieldPolicy(t, n), i = a && a.merge;
      return !i && r && (a = this.getTypePolicy(r), i = a && a.merge), i;
    }, e.prototype.runMergeFunction = function(t, n, r, a, i) {
      var o = r.field, s = r.typename, l = r.merge;
      return l === Px ? OA(a.store)(t, n) : l === Ix ? n : (a.overwrite && (t = void 0), l(t, n, Fx(
        this,
        // Unlike options.readField for read functions, we do not fall
        // back to the current object if no foreignObjOrRef is provided,
        // because it's not clear what the current object should be for
        // merge functions: the (possibly undefined) existing object, or
        // the incoming object? If you think your merge function needs
        // to read sibling fields in order to produce a new value for
        // the current field, you might want to rethink your strategy,
        // because that's a recipe for making merge behavior sensitive
        // to the order in which fields are written into the cache.
        // However, readField(name, ref) is useful for merge functions
        // that need to deduplicate child objects and references.
        void 0,
        {
          typename: s,
          fieldName: o.name.value,
          field: o,
          variables: a.variables
        },
        a,
        i || /* @__PURE__ */ Object.create(null)
      )));
    }, e;
  }()
);
function Fx(e, t, n, r, a) {
  var i = e.getStoreFieldName(n), o = ri(i), s = n.variables || r.variables, l = r.store, c = l.toReference, u = l.canRead;
  return {
    args: Ig(n),
    field: n.field || null,
    fieldName: o,
    storeFieldName: i,
    variables: s,
    isReference: Me,
    toReference: c,
    storage: a,
    cache: e.cache,
    canRead: u,
    readField: function() {
      return e.readField(tb(arguments, t, s), r);
    },
    mergeObjects: OA(r.store)
  };
}
function tb(e, t, n) {
  var r = e[0], a = e[1], i = e.length, o;
  return typeof r == "string" ? o = {
    fieldName: r,
    // Default to objectOrReference only when no second argument was
    // passed for the from parameter, not when undefined is explicitly
    // passed as the second argument.
    from: i > 1 ? a : t
  } : (o = M({}, r), At.call(o, "from") || (o.from = t)), globalThis.__DEV__ !== !1 && o.from === void 0 && globalThis.__DEV__ !== !1 && W.warn(8, u1(Array.from(e))), o.variables === void 0 && (o.variables = n), o;
}
function OA(e) {
  return function(n, r) {
    if (ot(n) || ot(r))
      throw Gt(9);
    if (it(n) && it(r)) {
      var a = e.getFieldValue(n, "__typename"), i = e.getFieldValue(r, "__typename"), o = a && i && a !== i;
      if (o)
        return r;
      if (Me(n) && Go(r))
        return e.merge(n.__ref, r), n;
      if (Go(n) && Me(r))
        return e.merge(n, r.__ref), r;
      if (Go(n) && Go(r))
        return M(M({}, n), r);
    }
    return r;
  };
}
function Rp(e, t, n) {
  var r = "".concat(t).concat(n), a = e.flavors.get(r);
  return a || e.flavors.set(r, a = e.clientOnly === t && e.deferred === n ? e : M(M({}, e), { clientOnly: t, deferred: n })), a;
}
var SI = (
  /** @class */
  function() {
    function e(t, n, r) {
      this.cache = t, this.reader = n, this.fragments = r;
    }
    return e.prototype.writeToStore = function(t, n) {
      var r = this, a = n.query, i = n.result, o = n.dataId, s = n.variables, l = n.overwrite, c = Ji(a), u = fI();
      s = M(M({}, By(c)), s);
      var f = M(M({ store: t, written: /* @__PURE__ */ Object.create(null), merge: function(h, g) {
        return u.merge(h, g);
      }, variables: s, varString: Ya(s) }, xA(a, this.fragments)), { overwrite: !!l, incomingById: /* @__PURE__ */ new Map(), clientOnly: !1, deferred: !1, flavors: /* @__PURE__ */ new Map() }), d = this.processSelectionSet({
        result: i || /* @__PURE__ */ Object.create(null),
        dataId: o,
        selectionSet: c.selectionSet,
        mergeTree: { map: /* @__PURE__ */ new Map() },
        context: f
      });
      if (!Me(d))
        throw Gt(12, i);
      return f.incomingById.forEach(function(h, g) {
        var v = h.storeObject, b = h.mergeTree, p = h.fieldNodeSet, m = as(g);
        if (b && b.map.size) {
          var w = r.applyMerges(b, m, v, f);
          if (Me(w))
            return;
          v = w;
        }
        if (globalThis.__DEV__ !== !1 && !f.overwrite) {
          var x = /* @__PURE__ */ Object.create(null);
          p.forEach(function(E) {
            E.selectionSet && (x[E.name.value] = !0);
          });
          var S = function(E) {
            return x[ri(E)] === !0;
          }, T = function(E) {
            var O = b && b.map.get(E);
            return !!(O && O.info && O.info.merge);
          };
          Object.keys(v).forEach(function(E) {
            S(E) && !T(E) && TI(m, v, E, f.store);
          });
        }
        t.merge(g, v);
      }), t.retain(d.__ref), d;
    }, e.prototype.processSelectionSet = function(t) {
      var n = this, r = t.dataId, a = t.result, i = t.selectionSet, o = t.context, s = t.mergeTree, l = this.cache.policies, c = /* @__PURE__ */ Object.create(null), u = r && l.rootTypenamesById[r] || Rg(a, i, o.fragmentMap) || r && o.store.get(r, "__typename");
      typeof u == "string" && (c.__typename = u);
      var f = function() {
        var w = tb(arguments, c, o.variables);
        if (Me(w.from)) {
          var x = o.incomingById.get(w.from.__ref);
          if (x) {
            var S = l.readField(M(M({}, w), { from: x.storeObject }), o);
            if (S !== void 0)
              return S;
          }
        }
        return l.readField(w, o);
      }, d = /* @__PURE__ */ new Set();
      this.flattenFields(
        i,
        a,
        // This WriteContext will be the default context value for fields returned
        // by the flattenFields method, but some fields may be assigned a modified
        // context, depending on the presence of @client and other directives.
        o,
        u
      ).forEach(function(w, x) {
        var S, T = Xr(x), E = a[T];
        if (d.add(x), E !== void 0) {
          var O = l.getStoreFieldName({
            typename: u,
            fieldName: x.name.value,
            field: x,
            variables: w.variables
          }), D = Ux(s, O), A = n.processFieldValue(
            E,
            x,
            // Reset context.clientOnly and context.deferred to their default
            // values before processing nested selection sets.
            x.selectionSet ? Rp(w, !1, !1) : w,
            D
          ), U = void 0;
          x.selectionSet && (Me(A) || Go(A)) && (U = f("__typename", A));
          var R = l.getMergeFunction(u, x.name.value, U);
          R ? D.info = {
            // TODO Check compatibility against any existing childTree.field?
            field: x,
            typename: u,
            merge: R
          } : qx(s, O), c = w.merge(c, (S = {}, S[O] = A, S));
        } else globalThis.__DEV__ !== !1 && !w.clientOnly && !w.deferred && !$y.added(x) && // If the field has a read function, it may be a synthetic field or
        // provide a default value, so its absence from the written data should
        // not be cause for alarm.
        !l.getReadFunction(u, x.name.value) && globalThis.__DEV__ !== !1 && W.error(13, Xr(x), a);
      });
      try {
        var h = l.identify(a, {
          typename: u,
          selectionSet: i,
          fragmentMap: o.fragmentMap,
          storeObject: c,
          readField: f
        }), g = h[0], v = h[1];
        r = r || g, v && (c = o.merge(c, v));
      } catch (w) {
        if (!r)
          throw w;
      }
      if (typeof r == "string") {
        var b = as(r), p = o.written[r] || (o.written[r] = []);
        if (p.indexOf(i) >= 0 || (p.push(i), this.reader && this.reader.isFresh(a, b, i, o)))
          return b;
        var m = o.incomingById.get(r);
        return m ? (m.storeObject = o.merge(m.storeObject, c), m.mergeTree = Fg(m.mergeTree, s), d.forEach(function(w) {
          return m.fieldNodeSet.add(w);
        })) : o.incomingById.set(r, {
          storeObject: c,
          // Save a reference to mergeTree only if it is not empty, because
          // empty MergeTrees may be recycled by maybeRecycleChildMergeTree and
          // reused for entirely different parts of the result tree.
          mergeTree: vd(s) ? void 0 : s,
          fieldNodeSet: d
        }), b;
      }
      return c;
    }, e.prototype.processFieldValue = function(t, n, r, a) {
      var i = this;
      return !n.selectionSet || t === null ? globalThis.__DEV__ !== !1 ? X1(t) : t : ot(t) ? t.map(function(o, s) {
        var l = i.processFieldValue(o, n, r, Ux(a, s));
        return qx(a, s), l;
      }) : this.processSelectionSet({
        result: t,
        selectionSet: n.selectionSet,
        context: r,
        mergeTree: a
      });
    }, e.prototype.flattenFields = function(t, n, r, a) {
      a === void 0 && (a = Rg(n, t, r.fragmentMap));
      var i = /* @__PURE__ */ new Map(), o = this.cache.policies, s = new na(!1);
      return function l(c, u) {
        var f = s.lookup(
          c,
          // Because we take inheritedClientOnly and inheritedDeferred into
          // consideration here (in addition to selectionSet), it's possible for
          // the same selection set to be flattened more than once, if it appears
          // in the query with different @client and/or @directive configurations.
          u.clientOnly,
          u.deferred
        );
        f.visited || (f.visited = !0, c.selections.forEach(function(d) {
          if (uu(d, r.variables)) {
            var h = u.clientOnly, g = u.deferred;
            if (
              // Since the presence of @client or @defer on this field can only
              // cause clientOnly or deferred to become true, we can skip the
              // forEach loop if both clientOnly and deferred are already true.
              !(h && g) && ur(d.directives) && d.directives.forEach(function(p) {
                var m = p.name.value;
                if (m === "client" && (h = !0), m === "defer") {
                  var w = rh(p, r.variables);
                  (!w || w.if !== !1) && (g = !0);
                }
              }), ei(d)
            ) {
              var v = i.get(d);
              v && (h = h && v.clientOnly, g = g && v.deferred), i.set(d, Rp(r, h, g));
            } else {
              var b = nh(d, r.lookupFragment);
              if (!b && d.kind === X.FRAGMENT_SPREAD)
                throw Gt(14, d.name.value);
              b && o.fragmentMatches(b, a, n, r.variables) && l(b.selectionSet, Rp(r, h, g));
            }
          }
        }));
      }(t, r), i;
    }, e.prototype.applyMerges = function(t, n, r, a, i) {
      var o, s = this;
      if (t.map.size && !Me(r)) {
        var l = (
          // Items in the same position in different arrays are not
          // necessarily related to each other, so when incoming is an array
          // we process its elements as if there was no existing data.
          !ot(r) && // Likewise, existing must be either a Reference or a StoreObject
          // in order for its fields to be safe to merge with the fields of
          // the incoming object.
          (Me(n) || Go(n)) ? n : void 0
        ), c = r;
        l && !i && (i = [Me(l) ? l.__ref : l]);
        var u, f = function(d, h) {
          return ot(d) ? typeof h == "number" ? d[h] : void 0 : a.store.getFieldValue(d, String(h));
        };
        t.map.forEach(function(d, h) {
          var g = f(l, h), v = f(c, h);
          if (v !== void 0) {
            i && i.push(h);
            var b = s.applyMerges(d, g, v, a, i);
            b !== v && (u = u || /* @__PURE__ */ new Map(), u.set(h, b)), i && W(i.pop() === h);
          }
        }), u && (r = ot(c) ? c.slice(0) : M({}, c), u.forEach(function(d, h) {
          r[h] = d;
        }));
      }
      return t.info ? this.cache.policies.runMergeFunction(n, r, t.info, a, i && (o = a.store).getStorage.apply(o, i)) : r;
    }, e;
  }()
), AA = [];
function Ux(e, t) {
  var n = e.map;
  return n.has(t) || n.set(t, AA.pop() || { map: /* @__PURE__ */ new Map() }), n.get(t);
}
function Fg(e, t) {
  if (e === t || !t || vd(t))
    return e;
  if (!e || vd(e))
    return t;
  var n = e.info && t.info ? M(M({}, e.info), t.info) : e.info || t.info, r = e.map.size && t.map.size, a = r ? /* @__PURE__ */ new Map() : e.map.size ? e.map : t.map, i = { info: n, map: a };
  if (r) {
    var o = new Set(t.map.keys());
    e.map.forEach(function(s, l) {
      i.map.set(l, Fg(s, t.map.get(l))), o.delete(l);
    }), o.forEach(function(s) {
      i.map.set(s, Fg(t.map.get(s), e.map.get(s)));
    });
  }
  return i;
}
function vd(e) {
  return !e || !(e.info || e.map.size);
}
function qx(e, t) {
  var n = e.map, r = n.get(t);
  r && vd(r) && (AA.push(r), n.delete(t));
}
var Bx = /* @__PURE__ */ new Set();
function TI(e, t, n, r) {
  var a = function(f) {
    var d = r.getFieldValue(f, n);
    return typeof d == "object" && d;
  }, i = a(e);
  if (i) {
    var o = a(t);
    if (o && !Me(i) && !qe(i, o) && !Object.keys(i).every(function(f) {
      return r.getFieldValue(o, f) !== void 0;
    })) {
      var s = r.getFieldValue(e, "__typename") || r.getFieldValue(t, "__typename"), l = ri(n), c = "".concat(s, ".").concat(l);
      if (!Bx.has(c)) {
        Bx.add(c);
        var u = [];
        !ot(i) && !ot(o) && [i, o].forEach(function(f) {
          var d = r.getFieldValue(f, "__typename");
          typeof d == "string" && !u.includes(d) && u.push(d);
        }), globalThis.__DEV__ !== !1 && W.warn(15, l, s, u.length ? "either ensure all objects of type " + u.join(" and ") + " have an ID or a custom merge function, or " : "", c, M({}, i), M({}, o));
      }
    }
  }
}
var RA = (
  /** @class */
  function(e) {
    Yn(t, e);
    function t(n) {
      n === void 0 && (n = {});
      var r = e.call(this) || this;
      return r.watches = /* @__PURE__ */ new Set(), r.addTypenameTransform = new V1($y), r.assumeImmutableResults = !0, r.makeVar = bI, r.txCount = 0, globalThis.__DEV__ !== !1 && (st(n, "addTypename", "InMemoryCache", "Please remove the `addTypename` option when initializing `InMemoryCache`."), st(n, "canonizeResults", "InMemoryCache", "Please remove the `canonizeResults` option when initializing `InMemoryCache`.")), r.config = cI(n), r.addTypename = !!r.config.addTypename, r.policies = new EI({
        cache: r,
        dataIdFromObject: r.config.dataIdFromObject,
        possibleTypes: r.config.possibleTypes,
        typePolicies: r.config.typePolicies
      }), r.init(), r;
    }
    return t.prototype.init = function() {
      var n = this.data = new Lc.Root({
        policies: this.policies,
        resultCaching: this.config.resultCaching
      });
      this.optimisticData = n.stump, this.resetResultCache();
    }, t.prototype.resetResultCache = function(n) {
      var r = this, a = this.storeReader, i = this.config.fragments;
      this.addTypenameTransform.resetCache(), i == null || i.resetCaches(), this.storeWriter = new SI(this, this.storeReader = new mI({
        cache: this,
        addTypename: this.addTypename,
        resultCacheMaxSize: this.config.resultCacheMaxSize,
        canonizeResults: bA(this.config),
        canon: n ? void 0 : a && a.canon,
        fragments: i
      }), i), this.maybeBroadcastWatch = kc(function(o, s) {
        return r.broadcastWatch(o, s);
      }, {
        max: this.config.resultCacheMaxSize || Kr["inMemoryCache.maybeBroadcastWatch"] || 5e3,
        makeCacheKey: function(o) {
          var s = o.optimistic ? r.optimisticData : r.data;
          if (oc(s)) {
            var l = o.optimistic, c = o.id, u = o.variables;
            return s.makeCacheKey(
              o.query,
              // Different watches can have the same query, optimistic
              // status, rootId, and variables, but if their callbacks are
              // different, the (identical) result needs to be delivered to
              // each distinct callback. The easiest way to achieve that
              // separation is to include c.callback in the cache key for
              // maybeBroadcastWatch calls. See issue #5733.
              o.callback,
              Ya({ optimistic: l, id: c, variables: u })
            );
          }
        }
      }), (/* @__PURE__ */ new Set([this.data.group, this.optimisticData.group])).forEach(function(o) {
        return o.resetCaching();
      });
    }, t.prototype.restore = function(n) {
      return this.init(), n && this.data.replace(n), this;
    }, t.prototype.extract = function(n) {
      return n === void 0 && (n = !1), (n ? this.optimisticData : this.data).extract();
    }, t.prototype.read = function(n) {
      globalThis.__DEV__ !== !1 && st(n, "canonizeResults", "cache.read");
      var r = n.returnPartialData, a = r === void 0 ? !1 : r;
      try {
        return this.storeReader.diffQueryAgainstStore(M(M({}, n), { store: n.optimistic ? this.optimisticData : this.data, config: this.config, returnPartialData: a })).result || null;
      } catch (i) {
        if (i instanceof gA)
          return null;
        throw i;
      }
    }, t.prototype.write = function(n) {
      try {
        return ++this.txCount, this.storeWriter.writeToStore(this.data, n);
      } finally {
        !--this.txCount && n.broadcast !== !1 && this.broadcastWatches();
      }
    }, t.prototype.modify = function(n) {
      if (At.call(n, "id") && !n.id)
        return !1;
      var r = n.optimistic ? this.optimisticData : this.data;
      try {
        return ++this.txCount, r.modify(n.id || "ROOT_QUERY", n.fields);
      } finally {
        !--this.txCount && n.broadcast !== !1 && this.broadcastWatches();
      }
    }, t.prototype.diff = function(n) {
      return globalThis.__DEV__ !== !1 && st(n, "canonizeResults", "cache.diff"), this.storeReader.diffQueryAgainstStore(M(M({}, n), { store: n.optimistic ? this.optimisticData : this.data, rootId: n.id || "ROOT_QUERY", config: this.config }));
    }, t.prototype.watch = function(n) {
      var r = this;
      return this.watches.size || yI(this), this.watches.add(n), n.immediate && this.maybeBroadcastWatch(n), function() {
        r.watches.delete(n) && !r.watches.size && kx(r), r.maybeBroadcastWatch.forget(n);
      };
    }, t.prototype.gc = function(n) {
      globalThis.__DEV__ !== !1 && st(n || {}, "resetResultIdentities", "cache.gc", "First ensure all usages of `canonizeResults` are removed, then remove this option."), Ya.reset(), _i.reset();
      var r = this.optimisticData.gc();
      return n && !this.txCount && (n.resetResultCache ? this.resetResultCache(n.resetResultIdentities) : n.resetResultIdentities && this.storeReader.resetCanon()), r;
    }, t.prototype.retain = function(n, r) {
      return (r ? this.optimisticData : this.data).retain(n);
    }, t.prototype.release = function(n, r) {
      return (r ? this.optimisticData : this.data).release(n);
    }, t.prototype.identify = function(n) {
      if (Me(n))
        return n.__ref;
      try {
        return this.policies.identify(n)[0];
      } catch (r) {
        globalThis.__DEV__ !== !1 && W.warn(r);
      }
    }, t.prototype.evict = function(n) {
      if (!n.id) {
        if (At.call(n, "id"))
          return !1;
        n = M(M({}, n), { id: "ROOT_QUERY" });
      }
      try {
        return ++this.txCount, this.optimisticData.evict(n, this.data);
      } finally {
        !--this.txCount && n.broadcast !== !1 && this.broadcastWatches();
      }
    }, t.prototype.reset = function(n) {
      var r = this;
      return this.init(), Ya.reset(), n && n.discardWatches ? (this.watches.forEach(function(a) {
        return r.maybeBroadcastWatch.forget(a);
      }), this.watches.clear(), kx(this)) : this.broadcastWatches(), Promise.resolve();
    }, t.prototype.removeOptimistic = function(n) {
      var r = this.optimisticData.removeLayer(n);
      r !== this.optimisticData && (this.optimisticData = r, this.broadcastWatches());
    }, t.prototype.batch = function(n) {
      var r = this, a = n.update, i = n.optimistic, o = i === void 0 ? !0 : i, s = n.removeOptimistic, l = n.onWatchUpdated, c, u = function(d) {
        var h = r, g = h.data, v = h.optimisticData;
        ++r.txCount, d && (r.data = r.optimisticData = d);
        try {
          return c = a(r);
        } finally {
          --r.txCount, r.data = g, r.optimisticData = v;
        }
      }, f = /* @__PURE__ */ new Set();
      return l && !this.txCount && this.broadcastWatches(M(M({}, n), { onWatchUpdated: function(d) {
        return f.add(d), !1;
      } })), typeof o == "string" ? this.optimisticData = this.optimisticData.addLayer(o, u) : o === !1 ? u(this.data) : u(), typeof s == "string" && (this.optimisticData = this.optimisticData.removeLayer(s)), l && f.size ? (this.broadcastWatches(M(M({}, n), { onWatchUpdated: function(d, h) {
        var g = l.call(this, d, h);
        return g !== !1 && f.delete(d), g;
      } })), f.size && f.forEach(function(d) {
        return r.maybeBroadcastWatch.dirty(d);
      })) : this.broadcastWatches(n), c;
    }, t.prototype.performTransaction = function(n, r) {
      return this.batch({
        update: n,
        optimistic: r || r !== null
      });
    }, t.prototype.transformDocument = function(n) {
      return this.addTypenameToDocument(this.addFragmentsToDocument(n));
    }, t.prototype.fragmentMatches = function(n, r) {
      return this.policies.fragmentMatches(n, r);
    }, t.prototype.lookupFragment = function(n) {
      var r;
      return ((r = this.config.fragments) === null || r === void 0 ? void 0 : r.lookup(n)) || null;
    }, t.prototype.broadcastWatches = function(n) {
      var r = this;
      this.txCount || this.watches.forEach(function(a) {
        return r.maybeBroadcastWatch(a, n);
      });
    }, t.prototype.addFragmentsToDocument = function(n) {
      var r = this.config.fragments;
      return r ? r.transform(n) : n;
    }, t.prototype.addTypenameToDocument = function(n) {
      return this.addTypename ? this.addTypenameTransform.transformDocument(n) : n;
    }, t.prototype.broadcastWatch = function(n, r) {
      var a = this, i = n.lastDiff, o = Ut("canonizeResults", function() {
        return a.diff(n);
      });
      r && (n.optimistic && typeof r.optimistic == "string" && (o.fromOptimisticTransaction = !0), r.onWatchUpdated && r.onWatchUpdated.call(this, n, o, i) === !1) || (!i || !qe(i.result, o.result)) && n.callback(n.lastDiff = o, i);
    }, t;
  }(mA)
);
globalThis.__DEV__ !== !1 && (RA.prototype.getMemoryInternals = Oj);
var Ne;
(function(e) {
  e[e.loading = 1] = "loading", e[e.setVariables = 2] = "setVariables", e[e.fetchMore = 3] = "fetchMore", e[e.refetch = 4] = "refetch", e[e.poll = 6] = "poll", e[e.ready = 7] = "ready", e[e.error = 8] = "error";
})(Ne || (Ne = {}));
function Yo(e) {
  return e ? e < 7 : !1;
}
var Vx = Object.assign, CI = Object.hasOwnProperty, Df = (
  /** @class */
  function(e) {
    Yn(t, e);
    function t(n) {
      var r = n.queryManager, a = n.queryInfo, i = n.options, o = this, s = t.inactiveOnCreation.getValue();
      o = e.call(this, function(p) {
        o._getOrCreateQuery();
        try {
          var m = p._subscription._observer;
          m && !m.error && (m.error = OI);
        } catch {
        }
        var w = !o.observers.size;
        o.observers.add(p);
        var x = o.last;
        return x && x.error ? p.error && p.error(x.error) : x && x.result && p.next && p.next(o.maskResult(x.result)), w && o.reobserve().catch(function() {
        }), function() {
          o.observers.delete(p) && !o.observers.size && o.tearDownQuery();
        };
      }) || this, o.observers = /* @__PURE__ */ new Set(), o.subscriptions = /* @__PURE__ */ new Set(), o.dirty = !1, o._getOrCreateQuery = function() {
        return s && (r.queries.set(o.queryId, a), s = !1), o.queryManager.getOrCreateQuery(o.queryId);
      }, o.queryInfo = a, o.queryManager = r, o.waitForOwnResult = _p(i.fetchPolicy), o.isTornDown = !1, o.subscribeToMore = o.subscribeToMore.bind(o), o.maskResult = o.maskResult.bind(o);
      var l = r.defaultOptions.watchQuery, c = l === void 0 ? {} : l, u = c.fetchPolicy, f = u === void 0 ? "cache-first" : u, d = i.fetchPolicy, h = d === void 0 ? f : d, g = i.initialFetchPolicy, v = g === void 0 ? h === "standby" ? f : h : g;
      o.options = M(M({}, i), {
        // Remember the initial options.fetchPolicy so we can revert back to this
        // policy when variables change. This information can also be specified
        // (or overridden) by providing options.initialFetchPolicy explicitly.
        initialFetchPolicy: v,
        // This ensures this.options.fetchPolicy always has a string value, in
        // case options.fetchPolicy was not provided.
        fetchPolicy: h
      }), o.queryId = a.queryId || r.generateQueryId();
      var b = Ji(o.query);
      return o.queryName = b && b.name && b.name.value, o;
    }
    return Object.defineProperty(t.prototype, "query", {
      // The `query` computed property will always reflect the document transformed
      // by the last run query. `this.options.query` will always reflect the raw
      // untransformed query to ensure document transforms with runtime conditionals
      // are run on the original document.
      get: function() {
        return this.lastQuery || this.options.query;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "variables", {
      // Computed shorthand for this.options.variables, preserved for
      // backwards compatibility.
      /**
       * An object containing the variables that were provided for the query.
       */
      get: function() {
        return this.options.variables;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.result = function() {
      var n = this;
      return globalThis.__DEV__ !== !1 && Oi("observableQuery.result", function() {
        globalThis.__DEV__ !== !1 && W.warn(23);
      }), new Promise(function(r, a) {
        var i = {
          next: function(s) {
            r(s), n.observers.delete(i), n.observers.size || n.queryManager.removeQuery(n.queryId), setTimeout(function() {
              o.unsubscribe();
            }, 0);
          },
          error: a
        }, o = n.subscribe(i);
      });
    }, t.prototype.resetDiff = function() {
      this.queryInfo.resetDiff();
    }, t.prototype.getCurrentFullResult = function(n) {
      var r = this;
      n === void 0 && (n = !0);
      var a = Ut("getLastResult", function() {
        return r.getLastResult(!0);
      }), i = this.queryInfo.networkStatus || a && a.networkStatus || Ne.ready, o = M(M({}, a), { loading: Yo(i), networkStatus: i }), s = this.options.fetchPolicy, l = s === void 0 ? "cache-first" : s;
      if (
        // These fetch policies should never deliver data from the cache, unless
        // redelivering a previously delivered result.
        !(_p(l) || // If this.options.query has @client(always: true) fields, we cannot
        // trust diff.result, since it was read from the cache without running
        // local resolvers (and it's too late to run resolvers now, since we must
        // return a result synchronously).
        this.queryManager.getDocumentInfo(this.query).hasForcedResolvers)
      ) if (this.waitForOwnResult)
        this.queryInfo.updateWatch();
      else {
        var c = this.queryInfo.getDiff();
        (c.complete || this.options.returnPartialData) && (o.data = c.result), qe(o.data, {}) && (o.data = void 0), c.complete ? (delete o.partial, c.complete && o.networkStatus === Ne.loading && (l === "cache-first" || l === "cache-only") && (o.networkStatus = Ne.ready, o.loading = !1)) : o.partial = !0, o.networkStatus === Ne.ready && (o.error || o.errors) && (o.networkStatus = Ne.error), globalThis.__DEV__ !== !1 && !c.complete && !this.options.partialRefetch && !o.loading && !o.data && !o.error && _A(c.missing);
      }
      return n && this.updateLastResult(o), o;
    }, t.prototype.getCurrentResult = function(n) {
      return n === void 0 && (n = !0), this.maskResult(this.getCurrentFullResult(n));
    }, t.prototype.isDifferentFromLastResult = function(n, r) {
      if (!this.last)
        return !0;
      var a = this.queryManager.getDocumentInfo(this.query), i = this.queryManager.dataMasking, o = i ? a.nonReactiveQuery : this.query, s = i || a.hasNonreactiveDirective ? !cA(o, this.last.result, n, this.variables) : !qe(this.last.result, n);
      return s || r && !qe(this.last.variables, r);
    }, t.prototype.getLast = function(n, r) {
      var a = this.last;
      if (a && a[n] && (!r || qe(a.variables, this.variables)))
        return a[n];
    }, t.prototype.getLastResult = function(n) {
      return globalThis.__DEV__ !== !1 && Oi("getLastResult", function() {
        globalThis.__DEV__ !== !1 && W.warn(24);
      }), this.getLast("result", n);
    }, t.prototype.getLastError = function(n) {
      return globalThis.__DEV__ !== !1 && Oi("getLastError", function() {
        globalThis.__DEV__ !== !1 && W.warn(25);
      }), this.getLast("error", n);
    }, t.prototype.resetLastResults = function() {
      globalThis.__DEV__ !== !1 && Oi("resetLastResults", function() {
        globalThis.__DEV__ !== !1 && W.warn(26);
      }), delete this.last, this.isTornDown = !1;
    }, t.prototype.resetQueryStoreErrors = function() {
      globalThis.__DEV__ !== !1 && globalThis.__DEV__ !== !1 && W.warn(27), this.queryManager.resetErrors(this.queryId);
    }, t.prototype.refetch = function(n) {
      var r, a = {
        // Always disable polling for refetches.
        pollInterval: 0
      }, i = this.options.fetchPolicy;
      if (i === "no-cache" ? a.fetchPolicy = "no-cache" : a.fetchPolicy = "network-only", globalThis.__DEV__ !== !1 && n && CI.call(n, "variables")) {
        var o = D1(this.query), s = o.variableDefinitions;
        (!s || !s.some(function(l) {
          return l.variable.name.value === "variables";
        })) && globalThis.__DEV__ !== !1 && W.warn(
          28,
          n,
          ((r = o.name) === null || r === void 0 ? void 0 : r.value) || o
        );
      }
      return n && !qe(this.options.variables, n) && (a.variables = this.options.variables = M(M({}, this.options.variables), n)), this.queryInfo.resetLastWrite(), this.reobserve(a, Ne.refetch);
    }, t.prototype.fetchMore = function(n) {
      var r = this, a = M(M({}, n.query ? n : M(M(M(M({}, this.options), { query: this.options.query }), n), { variables: M(M({}, this.options.variables), n.variables) })), {
        // The fetchMore request goes immediately to the network and does
        // not automatically write its result to the cache (hence no-cache
        // instead of network-only), because we allow the caller of
        // fetchMore to provide an updateQuery callback that determines how
        // the data gets written to the cache.
        fetchPolicy: "no-cache"
      });
      a.query = this.transformDocument(a.query);
      var i = this.queryManager.generateQueryId();
      this.lastQuery = n.query ? this.transformDocument(this.options.query) : a.query;
      var o = this.queryInfo, s = o.networkStatus;
      o.networkStatus = Ne.fetchMore, a.notifyOnNetworkStatusChange && this.observe();
      var l = /* @__PURE__ */ new Set(), c = n == null ? void 0 : n.updateQuery, u = this.options.fetchPolicy !== "no-cache";
      return u || W(c, 29), this.queryManager.fetchQuery(i, a, Ne.fetchMore).then(function(f) {
        if (r.queryManager.removeQuery(i), o.networkStatus === Ne.fetchMore && (o.networkStatus = s), u)
          r.queryManager.cache.batch({
            update: function(g) {
              var v = n.updateQuery;
              v ? g.updateQuery({
                query: r.query,
                variables: r.variables,
                returnPartialData: !0,
                optimistic: !1
              }, function(b) {
                return v(b, {
                  fetchMoreResult: f.data,
                  variables: a.variables
                });
              }) : g.writeQuery({
                query: a.query,
                variables: a.variables,
                data: f.data
              });
            },
            onWatchUpdated: function(g) {
              l.add(g.query);
            }
          });
        else {
          var d = r.getLast("result"), h = c(d.data, {
            fetchMoreResult: f.data,
            variables: a.variables
          });
          r.reportResult(M(M({}, d), { networkStatus: s, loading: Yo(s), data: h }), r.variables);
        }
        return r.maskResult(f);
      }).finally(function() {
        u && !l.has(r.query) && r.reobserveCacheFirst();
      });
    }, t.prototype.subscribeToMore = function(n) {
      var r = this, a = this.queryManager.startGraphQLSubscription({
        query: n.document,
        variables: n.variables,
        context: n.context
      }).subscribe({
        next: function(i) {
          var o = n.updateQuery;
          o && r.updateQuery(function(s, l) {
            return o(s, M({ subscriptionData: i }, l));
          });
        },
        error: function(i) {
          if (n.onError) {
            n.onError(i);
            return;
          }
          globalThis.__DEV__ !== !1 && W.error(30, i);
        }
      });
      return this.subscriptions.add(a), function() {
        r.subscriptions.delete(a) && a.unsubscribe();
      };
    }, t.prototype.setOptions = function(n) {
      return globalThis.__DEV__ !== !1 && (st(n, "canonizeResults", "setOptions"), Oi("setOptions", function() {
        globalThis.__DEV__ !== !1 && W.warn(31);
      })), this.reobserve(n);
    }, t.prototype.silentSetOptions = function(n) {
      var r = Is(this.options, n || {});
      Vx(this.options, r);
    }, t.prototype.setVariables = function(n) {
      var r = this;
      return qe(this.variables, n) ? this.observers.size ? Ut("observableQuery.result", function() {
        return r.result();
      }) : Promise.resolve() : (this.options.variables = n, this.observers.size ? this.reobserve({
        // Reset options.fetchPolicy to its original value.
        fetchPolicy: this.options.initialFetchPolicy,
        variables: n
      }, Ne.setVariables) : Promise.resolve());
    }, t.prototype.updateQuery = function(n) {
      var r = this.queryManager, a = r.cache.diff({
        query: this.options.query,
        variables: this.variables,
        returnPartialData: !0,
        optimistic: !1
      }), i = a.result, o = a.complete, s = n(i, {
        variables: this.variables,
        complete: !!o,
        previousData: i
      });
      s && (r.cache.writeQuery({
        query: this.options.query,
        data: s,
        variables: this.variables
      }), r.broadcastQueries());
    }, t.prototype.startPolling = function(n) {
      this.options.pollInterval = n, this.updatePolling();
    }, t.prototype.stopPolling = function() {
      this.options.pollInterval = 0, this.updatePolling();
    }, t.prototype.applyNextFetchPolicy = function(n, r) {
      if (r.nextFetchPolicy) {
        var a = r.fetchPolicy, i = a === void 0 ? "cache-first" : a, o = r.initialFetchPolicy, s = o === void 0 ? i : o;
        i === "standby" || (typeof r.nextFetchPolicy == "function" ? r.fetchPolicy = r.nextFetchPolicy(i, {
          reason: n,
          options: r,
          observable: this,
          initialFetchPolicy: s
        }) : n === "variables-changed" ? r.fetchPolicy = s : r.fetchPolicy = r.nextFetchPolicy);
      }
      return r.fetchPolicy;
    }, t.prototype.fetch = function(n, r, a) {
      var i = this._getOrCreateQuery();
      return i.setObservableQuery(this), this.queryManager.fetchConcastWithInfo(i, n, r, a);
    }, t.prototype.updatePolling = function() {
      var n = this;
      if (!this.queryManager.ssrMode) {
        var r = this, a = r.pollingInfo, i = r.options.pollInterval;
        if (!i || !this.hasObservers()) {
          a && (clearTimeout(a.timeout), delete this.pollingInfo);
          return;
        }
        if (!(a && a.interval === i)) {
          W(i, 32);
          var o = a || (this.pollingInfo = {});
          o.interval = i;
          var s = function() {
            var c, u;
            n.pollingInfo && (!Yo(n.queryInfo.networkStatus) && !(!((u = (c = n.options).skipPollAttempt) === null || u === void 0) && u.call(c)) ? n.reobserve({
              // Most fetchPolicy options don't make sense to use in a polling context, as
              // users wouldn't want to be polling the cache directly. However, network-only and
              // no-cache are both useful for when the user wants to control whether or not the
              // polled results are written to the cache.
              fetchPolicy: n.options.initialFetchPolicy === "no-cache" ? "no-cache" : "network-only"
            }, Ne.poll).then(l, l) : l());
          }, l = function() {
            var c = n.pollingInfo;
            c && (clearTimeout(c.timeout), c.timeout = setTimeout(s, c.interval));
          };
          l();
        }
      }
    }, t.prototype.updateLastResult = function(n, r) {
      var a = this;
      r === void 0 && (r = this.variables);
      var i = Ut("getLastError", function() {
        return a.getLastError();
      });
      return i && this.last && !qe(r, this.last.variables) && (i = void 0), this.last = M({ result: this.queryManager.assumeImmutableResults ? n : X1(n), variables: r }, i ? { error: i } : null);
    }, t.prototype.reobserveAsConcast = function(n, r) {
      var a = this;
      this.isTornDown = !1;
      var i = (
        // Refetching uses a disposable Concast to allow refetches using different
        // options/variables, without permanently altering the options of the
        // original ObservableQuery.
        r === Ne.refetch || // The fetchMore method does not actually call the reobserve method, but,
        // if it did, it would definitely use a disposable Concast.
        r === Ne.fetchMore || // Polling uses a disposable Concast so the polling options (which force
        // fetchPolicy to be "network-only" or "no-cache") won't override the original options.
        r === Ne.poll
      ), o = this.options.variables, s = this.options.fetchPolicy, l = Is(this.options, n || {}), c = i ? (
        // Disposable Concast fetches receive a shallow copy of this.options
        // (merged with newOptions), leaving this.options unmodified.
        l
      ) : Vx(this.options, l), u = this.transformDocument(c.query);
      this.lastQuery = u, i || (this.updatePolling(), n && n.variables && !qe(n.variables, o) && // Don't mess with the fetchPolicy if it's currently "standby".
      c.fetchPolicy !== "standby" && // If we're changing the fetchPolicy anyway, don't try to change it here
      // using applyNextFetchPolicy. The explicit options.fetchPolicy wins.
      (c.fetchPolicy === s || // A `nextFetchPolicy` function has even higher priority, though,
      // so in that case `applyNextFetchPolicy` must be called.
      typeof c.nextFetchPolicy == "function") && (this.applyNextFetchPolicy("variables-changed", c), r === void 0 && (r = Ne.setVariables))), this.waitForOwnResult && (this.waitForOwnResult = _p(c.fetchPolicy));
      var f = function() {
        a.concast === g && (a.waitForOwnResult = !1);
      }, d = c.variables && M({}, c.variables), h = this.fetch(c, r, u), g = h.concast, v = h.fromLink, b = {
        next: function(p) {
          qe(a.variables, d) && (f(), a.reportResult(p, d));
        },
        error: function(p) {
          qe(a.variables, d) && (tA(p) || (p = new Ti({ networkError: p })), f(), a.reportError(p, d));
        }
      };
      return !i && (v || !this.concast) && (this.concast && this.observer && this.concast.removeObserver(this.observer), this.concast = g, this.observer = b), g.addObserver(b), g;
    }, t.prototype.reobserve = function(n, r) {
      return bP(this.reobserveAsConcast(n, r).promise.then(this.maskResult));
    }, t.prototype.resubscribeAfterError = function() {
      for (var n = this, r = [], a = 0; a < arguments.length; a++)
        r[a] = arguments[a];
      var i = this.last;
      Ut("resetLastResults", function() {
        return n.resetLastResults();
      });
      var o = this.subscribe.apply(this, r);
      return this.last = i, o;
    }, t.prototype.observe = function() {
      this.reportResult(
        // Passing false is important so that this.getCurrentResult doesn't
        // save the fetchMore result as this.lastResult, causing it to be
        // ignored due to the this.isDifferentFromLastResult check in
        // this.reportResult.
        this.getCurrentFullResult(!1),
        this.variables
      );
    }, t.prototype.reportResult = function(n, r) {
      var a = this, i = Ut("getLastError", function() {
        return a.getLastError();
      }), o = this.isDifferentFromLastResult(n, r);
      (i || !n.partial || this.options.returnPartialData) && this.updateLastResult(n, r), (i || o) && ic(this.observers, "next", this.maskResult(n));
    }, t.prototype.reportError = function(n, r) {
      var a = this, i = M(M({}, Ut("getLastResult", function() {
        return a.getLastResult();
      })), { error: n, errors: n.graphQLErrors, networkStatus: Ne.error, loading: !1 });
      this.updateLastResult(i, r), ic(this.observers, "error", this.last.error = n);
    }, t.prototype.hasObservers = function() {
      return this.observers.size > 0;
    }, t.prototype.tearDownQuery = function() {
      this.isTornDown || (this.concast && this.observer && (this.concast.removeObserver(this.observer), delete this.concast, delete this.observer), this.stopPolling(), this.subscriptions.forEach(function(n) {
        return n.unsubscribe();
      }), this.subscriptions.clear(), this.queryManager.stopQuery(this.queryId), this.observers.clear(), this.isTornDown = !0);
    }, t.prototype.transformDocument = function(n) {
      return this.queryManager.transform(n);
    }, t.prototype.maskResult = function(n) {
      return n && "data" in n ? M(M({}, n), { data: this.queryManager.maskOperation({
        document: this.query,
        data: n.data,
        fetchPolicy: this.options.fetchPolicy,
        id: this.queryId
      }) }) : n;
    }, t.prototype.resetNotifications = function() {
      this.cancelNotifyTimeout(), this.dirty = !1;
    }, t.prototype.cancelNotifyTimeout = function() {
      this.notifyTimeout && (clearTimeout(this.notifyTimeout), this.notifyTimeout = void 0);
    }, t.prototype.scheduleNotify = function() {
      var n = this;
      this.dirty || (this.dirty = !0, this.notifyTimeout || (this.notifyTimeout = setTimeout(function() {
        return n.notify();
      }, 0)));
    }, t.prototype.notify = function() {
      if (this.cancelNotifyTimeout(), this.dirty && (this.options.fetchPolicy == "cache-only" || this.options.fetchPolicy == "cache-and-network" || !Yo(this.queryInfo.networkStatus))) {
        var n = this.queryInfo.getDiff();
        n.fromOptimisticTransaction ? this.observe() : this.reobserveCacheFirst();
      }
      this.dirty = !1;
    }, t.prototype.reobserveCacheFirst = function() {
      var n = this.options, r = n.fetchPolicy, a = n.nextFetchPolicy;
      return r === "cache-and-network" || r === "network-only" ? this.reobserve({
        fetchPolicy: "cache-first",
        // Use a temporary nextFetchPolicy function that replaces itself with the
        // previous nextFetchPolicy value and returns the original fetchPolicy.
        nextFetchPolicy: function(i, o) {
          return this.nextFetchPolicy = a, typeof this.nextFetchPolicy == "function" ? this.nextFetchPolicy(i, o) : r;
        }
      }) : this.reobserve();
    }, t.inactiveOnCreation = new tl(), t;
  }(ke)
);
W1(Df);
function OI(e) {
  globalThis.__DEV__ !== !1 && W.error(33, e.message, e.stack);
}
function _A(e) {
  globalThis.__DEV__ !== !1 && e && globalThis.__DEV__ !== !1 && W.debug(34, e);
}
function _p(e) {
  return e === "network-only" || e === "no-cache" || e === "standby";
}
var Ko = new (uo ? WeakMap : Map)();
function Dp(e, t) {
  var n = e[t];
  typeof n == "function" && (e[t] = function() {
    return Ko.set(
      e,
      // The %1e15 allows the count to wrap around to 0 safely every
      // quadrillion evictions, so there's no risk of overflow. To be
      // clear, this is more of a pedantic principle than something
      // that matters in any conceivable practical scenario.
      (Ko.get(e) + 1) % 1e15
    ), n.apply(this, arguments);
  });
}
var Np = (
  /** @class */
  function() {
    function e(t, n) {
      n === void 0 && (n = t.generateQueryId()), this.queryId = n, this.document = null, this.lastRequestId = 1, this.stopped = !1, this.observableQuery = null;
      var r = this.cache = t.cache;
      Ko.has(r) || (Ko.set(r, 0), Dp(r, "evict"), Dp(r, "modify"), Dp(r, "reset"));
    }
    return e.prototype.init = function(t) {
      var n = t.networkStatus || Ne.loading;
      return this.variables && this.networkStatus !== Ne.loading && !qe(this.variables, t.variables) && (n = Ne.setVariables), qe(t.variables, this.variables) || (this.lastDiff = void 0, this.cancel()), Object.assign(this, {
        document: t.document,
        variables: t.variables,
        networkError: null,
        graphQLErrors: this.graphQLErrors || [],
        networkStatus: n
      }), t.observableQuery && this.setObservableQuery(t.observableQuery), t.lastRequestId && (this.lastRequestId = t.lastRequestId), this;
    }, e.prototype.resetDiff = function() {
      this.lastDiff = void 0;
    }, e.prototype.getDiff = function() {
      var t = this, n = this.getDiffOptions();
      if (this.lastDiff && qe(n, this.lastDiff.options))
        return this.lastDiff.diff;
      this.updateWatch(this.variables);
      var r = this.observableQuery;
      if (r && r.options.fetchPolicy === "no-cache")
        return { complete: !1 };
      var a = Ut("canonizeResults", function() {
        return t.cache.diff(n);
      });
      return this.updateLastDiff(a, n), a;
    }, e.prototype.updateLastDiff = function(t, n) {
      this.lastDiff = t ? {
        diff: t,
        options: n || this.getDiffOptions()
      } : void 0;
    }, e.prototype.getDiffOptions = function(t) {
      var n;
      return t === void 0 && (t = this.variables), {
        query: this.document,
        variables: t,
        returnPartialData: !0,
        optimistic: !0,
        canonizeResults: (n = this.observableQuery) === null || n === void 0 ? void 0 : n.options.canonizeResults
      };
    }, e.prototype.setDiff = function(t) {
      var n = this, r, a = this.lastDiff && this.lastDiff.diff;
      t && !t.complete && Ut("getLastError", function() {
        var i;
        return (i = n.observableQuery) === null || i === void 0 ? void 0 : i.getLastError();
      }) || (this.updateLastDiff(t), qe(a && a.result, t && t.result) || (r = this.observableQuery) === null || r === void 0 || r.scheduleNotify());
    }, e.prototype.setObservableQuery = function(t) {
      t !== this.observableQuery && (this.observableQuery = t, t && (t.queryInfo = this));
    }, e.prototype.stop = function() {
      var t;
      if (!this.stopped) {
        this.stopped = !0, (t = this.observableQuery) === null || t === void 0 || t.resetNotifications(), this.cancel();
        var n = this.observableQuery;
        n && n.stopPolling();
      }
    }, e.prototype.cancel = function() {
      var t;
      (t = this.cancelWatch) === null || t === void 0 || t.call(this), this.cancelWatch = void 0;
    }, e.prototype.updateWatch = function(t) {
      var n = this;
      t === void 0 && (t = this.variables);
      var r = this.observableQuery;
      if (!(r && r.options.fetchPolicy === "no-cache")) {
        var a = M(M({}, this.getDiffOptions(t)), { watcher: this, callback: function(i) {
          return n.setDiff(i);
        } });
        (!this.lastWatch || !qe(a, this.lastWatch)) && (this.cancel(), this.cancelWatch = this.cache.watch(this.lastWatch = a));
      }
    }, e.prototype.resetLastWrite = function() {
      this.lastWrite = void 0;
    }, e.prototype.shouldWrite = function(t, n) {
      var r = this.lastWrite;
      return !(r && // If cache.evict has been called since the last time we wrote this
      // data into the cache, there's a chance writing this result into
      // the cache will repair what was evicted.
      r.dmCount === Ko.get(this.cache) && qe(n, r.variables) && qe(t.data, r.result.data));
    }, e.prototype.markResult = function(t, n, r, a) {
      var i = this, o, s = new ni(), l = ur(t.errors) ? t.errors.slice(0) : [];
      if ((o = this.observableQuery) === null || o === void 0 || o.resetNotifications(), "incremental" in t && ur(t.incremental)) {
        var c = Z1(this.getDiff().result, t);
        t.data = c;
      } else if ("hasNext" in t && t.hasNext) {
        var u = this.getDiff();
        t.data = s.merge(u.result, t.data);
      }
      this.graphQLErrors = l, r.fetchPolicy === "no-cache" ? this.updateLastDiff({ result: t.data, complete: !0 }, this.getDiffOptions(r.variables)) : a !== 0 && (Ug(t, r.errorPolicy) ? this.cache.performTransaction(function(f) {
        if (i.shouldWrite(t, r.variables))
          f.writeQuery({
            query: n,
            data: t.data,
            variables: r.variables,
            overwrite: a === 1
          }), i.lastWrite = {
            result: t,
            variables: r.variables,
            dmCount: Ko.get(i.cache)
          };
        else if (i.lastDiff && i.lastDiff.diff.complete) {
          t.data = i.lastDiff.diff.result;
          return;
        }
        var d = i.getDiffOptions(r.variables), h = Ut("canonizeResults", function() {
          return f.diff(d);
        });
        !i.stopped && qe(i.variables, r.variables) && i.updateWatch(r.variables), i.updateLastDiff(h, d), h.complete && (t.data = h.result);
      }) : this.lastWrite = void 0);
    }, e.prototype.markReady = function() {
      return this.networkError = null, this.networkStatus = Ne.ready;
    }, e.prototype.markError = function(t) {
      var n;
      return this.networkStatus = Ne.error, this.lastWrite = void 0, (n = this.observableQuery) === null || n === void 0 || n.resetNotifications(), t.graphQLErrors && (this.graphQLErrors = t.graphQLErrors), t.networkError && (this.networkError = t.networkError), t;
    }, e;
  }()
);
function Ug(e, t) {
  t === void 0 && (t = "none");
  var n = t === "ignore" || t === "all", r = !Af(e);
  return !r && n && e.data && (r = !0), r;
}
var AI = Object.prototype.hasOwnProperty, Qx = /* @__PURE__ */ Object.create(null), RI = (
  /** @class */
  function() {
    function e(t) {
      var n = this;
      this.clientAwareness = {}, this.queries = /* @__PURE__ */ new Map(), this.fetchCancelFns = /* @__PURE__ */ new Map(), this.transformCache = new T1(
        Kr["queryManager.getDocumentInfo"] || 2e3
        /* defaultCacheSizes["queryManager.getDocumentInfo"] */
      ), this.queryIdCounter = 1, this.requestIdCounter = 1, this.mutationIdCounter = 1, this.inFlightLinkObservables = new na(!1), this.noCacheWarningsByQueryId = /* @__PURE__ */ new Set();
      var r = new V1(
        function(i) {
          return n.cache.transformDocument(i);
        },
        // Allow the apollo cache to manage its own transform caches
        { cache: !1 }
      );
      this.cache = t.cache, this.link = t.link, this.defaultOptions = t.defaultOptions, this.queryDeduplication = t.queryDeduplication, this.clientAwareness = t.clientAwareness, this.localState = t.localState, this.ssrMode = t.ssrMode, this.assumeImmutableResults = t.assumeImmutableResults, this.dataMasking = t.dataMasking;
      var a = t.documentTransform;
      this.documentTransform = a ? r.concat(a).concat(r) : r, this.defaultContext = t.defaultContext || /* @__PURE__ */ Object.create(null), (this.onBroadcast = t.onBroadcast) && (this.mutationStore = /* @__PURE__ */ Object.create(null));
    }
    return e.prototype.stop = function() {
      var t = this;
      this.queries.forEach(function(n, r) {
        t.stopQueryNoBroadcast(r);
      }), this.cancelPendingFetches(Gt(35));
    }, e.prototype.cancelPendingFetches = function(t) {
      this.fetchCancelFns.forEach(function(n) {
        return n(t);
      }), this.fetchCancelFns.clear();
    }, e.prototype.mutate = function(t) {
      return ma(this, arguments, void 0, function(n) {
        var r, a, i, o, s, l, c, u = n.mutation, f = n.variables, d = n.optimisticResponse, h = n.updateQueries, g = n.refetchQueries, v = g === void 0 ? [] : g, b = n.awaitRefetchQueries, p = b === void 0 ? !1 : b, m = n.update, w = n.onQueryUpdated, x = n.fetchPolicy, S = x === void 0 ? ((l = this.defaultOptions.mutate) === null || l === void 0 ? void 0 : l.fetchPolicy) || "network-only" : x, T = n.errorPolicy, E = T === void 0 ? ((c = this.defaultOptions.mutate) === null || c === void 0 ? void 0 : c.errorPolicy) || "none" : T, O = n.keepRootFields, D = n.context;
        return ga(this, function(A) {
          switch (A.label) {
            case 0:
              return W(u, 36), W(S === "network-only" || S === "no-cache", 37), r = this.generateMutationId(), u = this.cache.transformForLink(this.transform(u)), a = this.getDocumentInfo(u).hasClientExports, f = this.getVariables(u, f), a ? [4, this.localState.addExportedVariables(u, f, D)] : [3, 2];
            case 1:
              f = A.sent(), A.label = 2;
            case 2:
              return i = this.mutationStore && (this.mutationStore[r] = {
                mutation: u,
                variables: f,
                loading: !0,
                error: null
              }), o = d && this.markMutationOptimistic(d, {
                mutationId: r,
                document: u,
                variables: f,
                fetchPolicy: S,
                errorPolicy: E,
                context: D,
                updateQueries: h,
                update: m,
                keepRootFields: O
              }), this.broadcastQueries(), s = this, [2, new Promise(function(U, R) {
                return Sp(s.getObservableFromLink(u, M(M({}, D), { optimisticResponse: o ? d : void 0 }), f, {}, !1), function(q) {
                  if (Af(q) && E === "none")
                    throw new Ti({
                      graphQLErrors: kg(q)
                    });
                  i && (i.loading = !1, i.error = null);
                  var z = M({}, q);
                  return typeof v == "function" && (v = v(z)), E === "ignore" && Af(z) && delete z.errors, s.markMutationResult({
                    mutationId: r,
                    result: z,
                    document: u,
                    variables: f,
                    fetchPolicy: S,
                    errorPolicy: E,
                    context: D,
                    update: m,
                    updateQueries: h,
                    awaitRefetchQueries: p,
                    refetchQueries: v,
                    removeOptimistic: o ? r : void 0,
                    onQueryUpdated: w,
                    keepRootFields: O
                  });
                }).subscribe({
                  next: function(q) {
                    s.broadcastQueries(), (!("hasNext" in q) || q.hasNext === !1) && U(M(M({}, q), { data: s.maskOperation({
                      document: u,
                      data: q.data,
                      fetchPolicy: S,
                      id: r
                    }) }));
                  },
                  error: function(q) {
                    i && (i.loading = !1, i.error = q), o && s.cache.removeOptimistic(r), s.broadcastQueries(), R(q instanceof Ti ? q : new Ti({
                      networkError: q
                    }));
                  }
                });
              })];
          }
        });
      });
    }, e.prototype.markMutationResult = function(t, n) {
      var r = this;
      n === void 0 && (n = this.cache);
      var a = t.result, i = [], o = t.fetchPolicy === "no-cache";
      if (!o && Ug(a, t.errorPolicy)) {
        if (is(a) || i.push({
          result: a.data,
          dataId: "ROOT_MUTATION",
          query: t.document,
          variables: t.variables
        }), is(a) && ur(a.incremental)) {
          var s = n.diff({
            id: "ROOT_MUTATION",
            // The cache complains if passed a mutation where it expects a
            // query, so we transform mutations and subscriptions to queries
            // (only once, thanks to this.transformCache).
            query: this.getDocumentInfo(t.document).asQuery,
            variables: t.variables,
            optimistic: !1,
            returnPartialData: !0
          }), l = void 0;
          s.result && (l = Z1(s.result, a)), typeof l < "u" && (a.data = l, i.push({
            result: l,
            dataId: "ROOT_MUTATION",
            query: t.document,
            variables: t.variables
          }));
        }
        var c = t.updateQueries;
        c && this.queries.forEach(function(f, d) {
          var h = f.observableQuery, g = h && h.queryName;
          if (!(!g || !AI.call(c, g))) {
            var v = c[g], b = r.queries.get(d), p = b.document, m = b.variables, w = n.diff({
              query: p,
              variables: m,
              returnPartialData: !0,
              optimistic: !1
            }), x = w.result, S = w.complete;
            if (S && x) {
              var T = v(x, {
                mutationResult: a,
                queryName: p && ql(p) || void 0,
                queryVariables: m
              });
              T && i.push({
                result: T,
                dataId: "ROOT_QUERY",
                query: p,
                variables: m
              });
            }
          }
        });
      }
      if (i.length > 0 || (t.refetchQueries || "").length > 0 || t.update || t.onQueryUpdated || t.removeOptimistic) {
        var u = [];
        if (this.refetchQueries({
          updateCache: function(f) {
            o || i.forEach(function(v) {
              return f.write(v);
            });
            var d = t.update, h = !TP(a) || is(a) && !a.hasNext;
            if (d) {
              if (!o) {
                var g = f.diff({
                  id: "ROOT_MUTATION",
                  // The cache complains if passed a mutation where it expects a
                  // query, so we transform mutations and subscriptions to queries
                  // (only once, thanks to this.transformCache).
                  query: r.getDocumentInfo(t.document).asQuery,
                  variables: t.variables,
                  optimistic: !1,
                  returnPartialData: !0
                });
                g.complete && (a = M(M({}, a), { data: g.result }), "incremental" in a && delete a.incremental, "hasNext" in a && delete a.hasNext);
              }
              h && d(f, a, {
                context: t.context,
                variables: t.variables
              });
            }
            !o && !t.keepRootFields && h && f.modify({
              id: "ROOT_MUTATION",
              fields: function(v, b) {
                var p = b.fieldName, m = b.DELETE;
                return p === "__typename" ? v : m;
              }
            });
          },
          include: t.refetchQueries,
          // Write the final mutation.result to the root layer of the cache.
          optimistic: !1,
          // Remove the corresponding optimistic layer at the same time as we
          // write the final non-optimistic result.
          removeOptimistic: t.removeOptimistic,
          // Let the caller of client.mutate optionally determine the refetching
          // behavior for watched queries after the mutation.update function runs.
          // If no onQueryUpdated function was provided for this mutation, pass
          // null instead of undefined to disable the default refetching behavior.
          onQueryUpdated: t.onQueryUpdated || null
        }).forEach(function(f) {
          return u.push(f);
        }), t.awaitRefetchQueries || t.onQueryUpdated)
          return Promise.all(u).then(function() {
            return a;
          });
      }
      return Promise.resolve(a);
    }, e.prototype.markMutationOptimistic = function(t, n) {
      var r = this, a = typeof t == "function" ? t(n.variables, { IGNORE: Qx }) : t;
      return a === Qx ? !1 : (this.cache.recordOptimisticTransaction(function(i) {
        try {
          r.markMutationResult(M(M({}, n), { result: { data: a } }), i);
        } catch (o) {
          globalThis.__DEV__ !== !1 && W.error(o);
        }
      }, n.mutationId), !0);
    }, e.prototype.fetchQuery = function(t, n, r) {
      return this.fetchConcastWithInfo(this.getOrCreateQuery(t), n, r).concast.promise;
    }, e.prototype.getQueryStore = function() {
      var t = /* @__PURE__ */ Object.create(null);
      return this.queries.forEach(function(n, r) {
        t[r] = {
          variables: n.variables,
          networkStatus: n.networkStatus,
          networkError: n.networkError,
          graphQLErrors: n.graphQLErrors
        };
      }), t;
    }, e.prototype.resetErrors = function(t) {
      var n = this.queries.get(t);
      n && (n.networkError = void 0, n.graphQLErrors = []);
    }, e.prototype.transform = function(t) {
      return this.documentTransform.transformDocument(t);
    }, e.prototype.getDocumentInfo = function(t) {
      var n = this.transformCache;
      if (!n.has(t)) {
        var r = {
          // TODO These three calls (hasClientExports, shouldForceResolvers, and
          // usesNonreactiveDirective) are performing independent full traversals
          // of the transformed document. We should consider merging these
          // traversals into a single pass in the future, though the work is
          // cached after the first time.
          hasClientExports: oj(t),
          hasForcedResolvers: this.localState.shouldForceResolvers(t),
          hasNonreactiveDirective: Dc(["nonreactive"], t),
          nonReactiveQuery: lP(t),
          clientQuery: this.localState.clientQuery(t),
          serverQuery: H1([
            { name: "client", remove: !0 },
            { name: "connection" },
            { name: "nonreactive" },
            { name: "unmask" }
          ], t),
          defaultVars: By(Ji(t)),
          // Transform any mutation or subscription operations to query operations
          // so we can read/write them from/to the cache.
          asQuery: M(M({}, t), { definitions: t.definitions.map(function(a) {
            return a.kind === "OperationDefinition" && a.operation !== "query" ? M(M({}, a), { operation: "query" }) : a;
          }) })
        };
        n.set(t, r);
      }
      return n.get(t);
    }, e.prototype.getVariables = function(t, n) {
      return M(M({}, this.getDocumentInfo(t).defaultVars), n);
    }, e.prototype.watchQuery = function(t) {
      var n = this.transform(t.query);
      t = M(M({}, t), { variables: this.getVariables(n, t.variables) }), typeof t.notifyOnNetworkStatusChange > "u" && (t.notifyOnNetworkStatusChange = !1);
      var r = new Np(this), a = new Df({
        queryManager: this,
        queryInfo: r,
        options: t
      });
      return a.lastQuery = n, Df.inactiveOnCreation.getValue() || this.queries.set(a.queryId, r), r.init({
        document: n,
        observableQuery: a,
        variables: a.variables
      }), a;
    }, e.prototype.query = function(t, n) {
      var r = this;
      n === void 0 && (n = this.generateQueryId()), W(t.query, 38), W(t.query.kind === "Document", 39), W(!t.returnPartialData, 40), W(!t.pollInterval, 41);
      var a = this.transform(t.query);
      return this.fetchQuery(n, M(M({}, t), { query: a })).then(function(i) {
        return i && M(M({}, i), { data: r.maskOperation({
          document: a,
          data: i.data,
          fetchPolicy: t.fetchPolicy,
          id: n
        }) });
      }).finally(function() {
        return r.stopQuery(n);
      });
    }, e.prototype.generateQueryId = function() {
      return String(this.queryIdCounter++);
    }, e.prototype.generateRequestId = function() {
      return this.requestIdCounter++;
    }, e.prototype.generateMutationId = function() {
      return String(this.mutationIdCounter++);
    }, e.prototype.stopQueryInStore = function(t) {
      this.stopQueryInStoreNoBroadcast(t), this.broadcastQueries();
    }, e.prototype.stopQueryInStoreNoBroadcast = function(t) {
      var n = this.queries.get(t);
      n && n.stop();
    }, e.prototype.clearStore = function(t) {
      return t === void 0 && (t = {
        discardWatches: !0
      }), this.cancelPendingFetches(Gt(42)), this.queries.forEach(function(n) {
        n.observableQuery ? n.networkStatus = Ne.loading : n.stop();
      }), this.mutationStore && (this.mutationStore = /* @__PURE__ */ Object.create(null)), this.cache.reset(t);
    }, e.prototype.getObservableQueries = function(t) {
      var n = this;
      t === void 0 && (t = "active");
      var r = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Set();
      return Array.isArray(t) && t.forEach(function(s) {
        if (typeof s == "string")
          a.set(s, s), i.set(s, !1);
        else if (Lj(s)) {
          var l = _i(n.transform(s));
          a.set(l, ql(s)), i.set(l, !1);
        } else it(s) && s.query && o.add(s);
      }), this.queries.forEach(function(s, l) {
        var c = s.observableQuery, u = s.document;
        if (c) {
          if (t === "all") {
            r.set(l, c);
            return;
          }
          var f = c.queryName, d = c.options.fetchPolicy;
          if (d === "standby" || t === "active" && !c.hasObservers())
            return;
          (t === "active" || f && i.has(f) || u && i.has(_i(u))) && (r.set(l, c), f && i.set(f, !0), u && i.set(_i(u), !0));
        }
      }), o.size && o.forEach(function(s) {
        var l = wg("legacyOneTimeQuery"), c = n.getOrCreateQuery(l).init({
          document: s.query,
          variables: s.variables
        }), u = new Df({
          queryManager: n,
          queryInfo: c,
          options: M(M({}, s), { fetchPolicy: "network-only" })
        });
        W(u.queryId === l), c.setObservableQuery(u), r.set(l, u);
      }), globalThis.__DEV__ !== !1 && i.size && i.forEach(function(s, l) {
        if (!s) {
          var c = a.get(l);
          c ? globalThis.__DEV__ !== !1 && W.warn(43, c) : globalThis.__DEV__ !== !1 && W.warn(44);
        }
      }), r;
    }, e.prototype.reFetchObservableQueries = function(t) {
      var n = this;
      t === void 0 && (t = !1);
      var r = [];
      return this.getObservableQueries(t ? "all" : "active").forEach(function(a, i) {
        var o = a.options.fetchPolicy;
        Ut("resetLastResults", function() {
          return a.resetLastResults();
        }), (t || o !== "standby" && o !== "cache-only") && r.push(a.refetch()), (n.queries.get(i) || a.queryInfo).setDiff(null);
      }), this.broadcastQueries(), Promise.all(r);
    }, e.prototype.startGraphQLSubscription = function(t) {
      var n = this, r = t.query, a = t.variables, i = t.fetchPolicy, o = t.errorPolicy, s = o === void 0 ? "none" : o, l = t.context, c = l === void 0 ? {} : l, u = t.extensions, f = u === void 0 ? {} : u;
      r = this.transform(r), a = this.getVariables(r, a);
      var d = function(g) {
        return n.getObservableFromLink(r, c, g, f).map(function(v) {
          i !== "no-cache" && (Ug(v, s) && n.cache.write({
            query: r,
            result: v.data,
            dataId: "ROOT_SUBSCRIPTION",
            variables: g
          }), n.broadcastQueries());
          var b = Af(v), p = eA(v);
          if (b || p) {
            var m = {};
            if (b && (m.graphQLErrors = v.errors), p && (m.protocolErrors = v.extensions[sh]), s === "none" || p)
              throw new Ti(m);
          }
          return s === "ignore" && delete v.errors, v;
        });
      };
      if (this.getDocumentInfo(r).hasClientExports) {
        var h = this.localState.addExportedVariables(r, a, c).then(d);
        return new ke(function(g) {
          var v = null;
          return h.then(function(b) {
            return v = b.subscribe(g);
          }, g.error), function() {
            return v && v.unsubscribe();
          };
        });
      }
      return d(a);
    }, e.prototype.stopQuery = function(t) {
      this.stopQueryNoBroadcast(t), this.broadcastQueries();
    }, e.prototype.stopQueryNoBroadcast = function(t) {
      this.stopQueryInStoreNoBroadcast(t), this.removeQuery(t);
    }, e.prototype.removeQuery = function(t) {
      var n;
      this.fetchCancelFns.delete(t), this.queries.has(t) && ((n = this.queries.get(t)) === null || n === void 0 || n.stop(), this.queries.delete(t));
    }, e.prototype.broadcastQueries = function() {
      this.onBroadcast && this.onBroadcast(), this.queries.forEach(function(t) {
        var n;
        return (n = t.observableQuery) === null || n === void 0 ? void 0 : n.notify();
      });
    }, e.prototype.getLocalState = function() {
      return this.localState;
    }, e.prototype.getObservableFromLink = function(t, n, r, a, i) {
      var o = this, s;
      i === void 0 && (i = (s = n == null ? void 0 : n.queryDeduplication) !== null && s !== void 0 ? s : this.queryDeduplication);
      var l, c = this.getDocumentInfo(t), u = c.serverQuery, f = c.clientQuery;
      if (u) {
        var d = this, h = d.inFlightLinkObservables, g = d.link, v = {
          query: u,
          variables: r,
          operationName: ql(u) || void 0,
          context: this.prepareContext(M(M({}, n), { forceFetch: !i })),
          extensions: a
        };
        if (n = v.context, i) {
          var b = _i(u), p = Ya(r), m = h.lookup(b, p);
          if (l = m.observable, !l) {
            var w = new _o([
              Lg(g, v)
            ]);
            l = m.observable = w, w.beforeNext(function x(S, T) {
              S === "next" && "hasNext" in T && T.hasNext ? w.beforeNext(x) : h.remove(b, p);
            });
          }
        } else
          l = new _o([
            Lg(g, v)
          ]);
      } else
        l = new _o([ke.of({ data: {} })]), n = this.prepareContext(n);
      return f && (l = Sp(l, function(x) {
        return o.localState.runResolvers({
          document: f,
          remoteResult: x,
          context: n,
          variables: r
        });
      })), l;
    }, e.prototype.getResultsFromLink = function(t, n, r) {
      var a = t.lastRequestId = this.generateRequestId(), i = this.cache.transformForLink(r.query);
      return Sp(this.getObservableFromLink(i, r.context, r.variables), function(o) {
        var s = kg(o), l = s.length > 0, c = r.errorPolicy;
        if (a >= t.lastRequestId) {
          if (l && c === "none")
            throw t.markError(new Ti({
              graphQLErrors: s
            }));
          t.markResult(o, i, r, n), t.markReady();
        }
        var u = {
          data: o.data,
          loading: !1,
          networkStatus: Ne.ready
        };
        return l && c === "none" && (u.data = void 0), l && c !== "ignore" && (u.errors = s, u.networkStatus = Ne.error), u;
      }, function(o) {
        var s = tA(o) ? o : new Ti({ networkError: o });
        throw a >= t.lastRequestId && t.markError(s), s;
      });
    }, e.prototype.fetchConcastWithInfo = function(t, n, r, a) {
      var i = this;
      r === void 0 && (r = Ne.loading), a === void 0 && (a = n.query);
      var o = this.getVariables(a, n.variables), s = this.defaultOptions.watchQuery, l = n.fetchPolicy, c = l === void 0 ? s && s.fetchPolicy || "cache-first" : l, u = n.errorPolicy, f = u === void 0 ? s && s.errorPolicy || "none" : u, d = n.returnPartialData, h = d === void 0 ? !1 : d, g = n.notifyOnNetworkStatusChange, v = g === void 0 ? !1 : g, b = n.context, p = b === void 0 ? {} : b, m = Object.assign({}, n, {
        query: a,
        variables: o,
        fetchPolicy: c,
        errorPolicy: f,
        returnPartialData: h,
        notifyOnNetworkStatusChange: v,
        context: p
      }), w = function(O) {
        m.variables = O;
        var D = i.fetchQueryByPolicy(t, m, r);
        return (
          // If we're in standby, postpone advancing options.fetchPolicy using
          // applyNextFetchPolicy.
          m.fetchPolicy !== "standby" && // The "standby" policy currently returns [] from fetchQueryByPolicy, so
          // this is another way to detect when nothing was done/fetched.
          D.sources.length > 0 && t.observableQuery && t.observableQuery.applyNextFetchPolicy("after-fetch", n), D
        );
      }, x = function() {
        return i.fetchCancelFns.delete(t.queryId);
      };
      this.fetchCancelFns.set(t.queryId, function(O) {
        x(), setTimeout(function() {
          return S.cancel(O);
        });
      });
      var S, T;
      if (this.getDocumentInfo(m.query).hasClientExports)
        S = new _o(this.localState.addExportedVariables(m.query, m.variables, m.context).then(w).then(function(O) {
          return O.sources;
        })), T = !0;
      else {
        var E = w(m.variables);
        T = E.fromLink, S = new _o(E.sources);
      }
      return S.promise.then(x, x), {
        concast: S,
        fromLink: T
      };
    }, e.prototype.refetchQueries = function(t) {
      var n = this, r = t.updateCache, a = t.include, i = t.optimistic, o = i === void 0 ? !1 : i, s = t.removeOptimistic, l = s === void 0 ? o ? wg("refetchQueries") : void 0 : s, c = t.onQueryUpdated, u = /* @__PURE__ */ new Map();
      a && this.getObservableQueries(a).forEach(function(d, h) {
        u.set(h, {
          oq: d,
          lastDiff: (n.queries.get(h) || d.queryInfo).getDiff()
        });
      });
      var f = /* @__PURE__ */ new Map();
      return r && this.cache.batch({
        update: r,
        // Since you can perform any combination of cache reads and/or writes in
        // the cache.batch update function, its optimistic option can be either
        // a boolean or a string, representing three distinct modes of
        // operation:
        //
        // * false: read/write only the root layer
        // * true: read/write the topmost layer
        // * string: read/write a fresh optimistic layer with that ID string
        //
        // When typeof optimistic === "string", a new optimistic layer will be
        // temporarily created within cache.batch with that string as its ID. If
        // we then pass that same string as the removeOptimistic option, we can
        // make cache.batch immediately remove the optimistic layer after
        // running the updateCache function, triggering only one broadcast.
        //
        // However, the refetchQueries method accepts only true or false for its
        // optimistic option (not string). We interpret true to mean a temporary
        // optimistic layer should be created, to allow efficiently rolling back
        // the effect of the updateCache function, which involves passing a
        // string instead of true as the optimistic option to cache.batch, when
        // refetchQueries receives optimistic: true.
        //
        // In other words, we are deliberately not supporting the use case of
        // writing to an *existing* optimistic layer (using the refetchQueries
        // updateCache function), since that would potentially interfere with
        // other optimistic updates in progress. Instead, you can read/write
        // only the root layer by passing optimistic: false to refetchQueries,
        // or you can read/write a brand new optimistic layer that will be
        // automatically removed by passing optimistic: true.
        optimistic: o && l || !1,
        // The removeOptimistic option can also be provided by itself, even if
        // optimistic === false, to remove some previously-added optimistic
        // layer safely and efficiently, like we do in markMutationResult.
        //
        // If an explicit removeOptimistic string is provided with optimistic:
        // true, the removeOptimistic string will determine the ID of the
        // temporary optimistic layer, in case that ever matters.
        removeOptimistic: l,
        onWatchUpdated: function(d, h, g) {
          var v = d.watcher instanceof Np && d.watcher.observableQuery;
          if (v) {
            if (c) {
              u.delete(v.queryId);
              var b = c(v, h, g);
              return b === !0 && (b = v.refetch()), b !== !1 && f.set(v, b), b;
            }
            c !== null && u.set(v.queryId, { oq: v, lastDiff: g, diff: h });
          }
        }
      }), u.size && u.forEach(function(d, h) {
        var g = d.oq, v = d.lastDiff, b = d.diff, p;
        c && (b || (b = Ut("canonizeResults", function() {
          return n.cache.diff(g.queryInfo.getDiffOptions());
        })), p = c(g, b, v)), (!c || p === !0) && (p = g.refetch()), p !== !1 && f.set(g, p), h.indexOf("legacyOneTimeQuery") >= 0 && n.stopQueryNoBroadcast(h);
      }), l && this.cache.removeOptimistic(l), f;
    }, e.prototype.maskOperation = function(t) {
      var n, r, a, i = t.document, o = t.data;
      if (globalThis.__DEV__ !== !1) {
        var s = t.fetchPolicy, l = t.id, c = (n = Ji(i)) === null || n === void 0 ? void 0 : n.operation, u = ((r = c == null ? void 0 : c[0]) !== null && r !== void 0 ? r : "o") + l;
        this.dataMasking && s === "no-cache" && !gj(i) && !this.noCacheWarningsByQueryId.has(u) && (this.noCacheWarningsByQueryId.add(u), globalThis.__DEV__ !== !1 && W.warn(
          45,
          (a = ql(i)) !== null && a !== void 0 ? a : "Unnamed ".concat(c ?? "operation")
        ));
      }
      return this.dataMasking ? lI(o, i, this.cache) : o;
    }, e.prototype.maskFragment = function(t) {
      var n = t.data, r = t.fragment, a = t.fragmentName;
      return this.dataMasking ? pA(n, r, this.cache, a) : n;
    }, e.prototype.fetchQueryByPolicy = function(t, n, r) {
      var a = this, i = n.query, o = n.variables, s = n.fetchPolicy, l = n.refetchWritePolicy, c = n.errorPolicy, u = n.returnPartialData, f = n.context, d = n.notifyOnNetworkStatusChange, h = t.networkStatus;
      t.init({
        document: i,
        variables: o,
        networkStatus: r
      });
      var g = function() {
        return t.getDiff();
      }, v = function(x, S) {
        S === void 0 && (S = t.networkStatus || Ne.loading);
        var T = x.result;
        globalThis.__DEV__ !== !1 && !u && !qe(T, {}) && _A(x.missing);
        var E = function(O) {
          return ke.of(M({ data: O, loading: Yo(S), networkStatus: S }, x.complete ? null : { partial: !0 }));
        };
        return T && a.getDocumentInfo(i).hasForcedResolvers ? a.localState.runResolvers({
          document: i,
          remoteResult: { data: T },
          context: f,
          variables: o,
          onlyRunForcedResolvers: !0
        }).then(function(O) {
          return E(O.data || void 0);
        }) : c === "none" && S === Ne.refetch && Array.isArray(x.missing) ? E(void 0) : E(T);
      }, b = s === "no-cache" ? 0 : r === Ne.refetch && l !== "merge" ? 1 : 2, p = function() {
        return a.getResultsFromLink(t, b, {
          query: i,
          variables: o,
          context: f,
          fetchPolicy: s,
          errorPolicy: c
        });
      }, m = d && typeof h == "number" && h !== r && Yo(r);
      switch (s) {
        default:
        case "cache-first": {
          var w = g();
          return w.complete ? {
            fromLink: !1,
            sources: [v(w, t.markReady())]
          } : u || m ? {
            fromLink: !0,
            sources: [v(w), p()]
          } : { fromLink: !0, sources: [p()] };
        }
        case "cache-and-network": {
          var w = g();
          return w.complete || u || m ? {
            fromLink: !0,
            sources: [v(w), p()]
          } : { fromLink: !0, sources: [p()] };
        }
        case "cache-only":
          return {
            fromLink: !1,
            sources: [v(g(), t.markReady())]
          };
        case "network-only":
          return m ? {
            fromLink: !0,
            sources: [v(g()), p()]
          } : { fromLink: !0, sources: [p()] };
        case "no-cache":
          return m ? {
            fromLink: !0,
            // Note that queryInfo.getDiff() for no-cache queries does not call
            // cache.diff, but instead returns a { complete: false } stub result
            // when there is no queryInfo.diff already defined.
            sources: [v(t.getDiff()), p()]
          } : { fromLink: !0, sources: [p()] };
        case "standby":
          return { fromLink: !1, sources: [] };
      }
    }, e.prototype.getOrCreateQuery = function(t) {
      return t && !this.queries.has(t) && this.queries.set(t, new Np(this, t)), this.queries.get(t);
    }, e.prototype.prepareContext = function(t) {
      t === void 0 && (t = {});
      var n = this.localState.prepareContext(t);
      return M(M(M({}, this.defaultContext), n), { clientAwareness: this.clientAwareness });
    }, e;
  }()
), _I = (
  /** @class */
  function() {
    function e(t) {
      var n = t.cache, r = t.client, a = t.resolvers, i = t.fragmentMatcher;
      this.selectionsToResolveCache = /* @__PURE__ */ new WeakMap(), this.cache = n, r && (this.client = r), a && this.addResolvers(a), i && this.setFragmentMatcher(i);
    }
    return e.prototype.addResolvers = function(t) {
      var n = this;
      this.resolvers = this.resolvers || {}, Array.isArray(t) ? t.forEach(function(r) {
        n.resolvers = fx(n.resolvers, r);
      }) : this.resolvers = fx(this.resolvers, t);
    }, e.prototype.setResolvers = function(t) {
      this.resolvers = {}, this.addResolvers(t);
    }, e.prototype.getResolvers = function() {
      return this.resolvers || {};
    }, e.prototype.runResolvers = function(t) {
      return ma(this, arguments, void 0, function(n) {
        var r = n.document, a = n.remoteResult, i = n.context, o = n.variables, s = n.onlyRunForcedResolvers, l = s === void 0 ? !1 : s;
        return ga(this, function(c) {
          return r ? [2, this.resolveDocument(r, a.data, i, o, this.fragmentMatcher, l).then(function(u) {
            return M(M({}, a), { data: u.result });
          })] : [2, a];
        });
      });
    }, e.prototype.setFragmentMatcher = function(t) {
      this.fragmentMatcher = t;
    }, e.prototype.getFragmentMatcher = function() {
      return this.fragmentMatcher;
    }, e.prototype.clientQuery = function(t) {
      return Dc(["client"], t) && this.resolvers ? t : null;
    }, e.prototype.serverQuery = function(t) {
      return $1(t);
    }, e.prototype.prepareContext = function(t) {
      var n = this.cache;
      return M(M({}, t), {
        cache: n,
        // Getting an entry's cache key is useful for local state resolvers.
        getCacheKey: function(r) {
          return n.identify(r);
        }
      });
    }, e.prototype.addExportedVariables = function(t) {
      return ma(this, arguments, void 0, function(n, r, a) {
        return r === void 0 && (r = {}), a === void 0 && (a = {}), ga(this, function(i) {
          return n ? [2, this.resolveDocument(n, this.buildRootValueFromCache(n, r) || {}, this.prepareContext(a), r).then(function(o) {
            return M(M({}, r), o.exportedVariables);
          })] : [2, M({}, r)];
        });
      });
    }, e.prototype.shouldForceResolvers = function(t) {
      var n = !1;
      return Vn(t, {
        Directive: {
          enter: function(r) {
            if (r.name.value === "client" && r.arguments && (n = r.arguments.some(function(a) {
              return a.name.value === "always" && a.value.kind === "BooleanValue" && a.value.value === !0;
            }), n))
              return eh;
          }
        }
      }), n;
    }, e.prototype.buildRootValueFromCache = function(t, n) {
      return this.cache.diff({
        query: sP(t),
        variables: n,
        returnPartialData: !0,
        optimistic: !1
      }).result;
    }, e.prototype.resolveDocument = function(t, n) {
      return ma(this, arguments, void 0, function(r, a, i, o, s, l) {
        var c, u, f, d, h, g, v, b, p, m, w;
        return i === void 0 && (i = {}), o === void 0 && (o = {}), s === void 0 && (s = function() {
          return !0;
        }), l === void 0 && (l = !1), ga(this, function(x) {
          return c = fu(r), u = el(r), f = Zs(u), d = this.collectSelectionsToResolve(c, f), h = c.operation, g = h ? h.charAt(0).toUpperCase() + h.slice(1) : "Query", v = this, b = v.cache, p = v.client, m = {
            fragmentMap: f,
            context: M(M({}, i), { cache: b, client: p }),
            variables: o,
            fragmentMatcher: s,
            defaultOperationType: g,
            exportedVariables: {},
            selectionsToResolve: d,
            onlyRunForcedResolvers: l
          }, w = !1, [2, this.resolveSelectionSet(c.selectionSet, w, a, m).then(function(S) {
            return {
              result: S,
              exportedVariables: m.exportedVariables
            };
          })];
        });
      });
    }, e.prototype.resolveSelectionSet = function(t, n, r, a) {
      return ma(this, void 0, void 0, function() {
        var i, o, s, l, c, u = this;
        return ga(this, function(f) {
          return i = a.fragmentMap, o = a.context, s = a.variables, l = [r], c = function(d) {
            return ma(u, void 0, void 0, function() {
              var h, g;
              return ga(this, function(v) {
                return !n && !a.selectionsToResolve.has(d) ? [
                  2
                  /*return*/
                ] : uu(d, s) ? ei(d) ? [2, this.resolveField(d, n, r, a).then(function(b) {
                  var p;
                  typeof b < "u" && l.push((p = {}, p[Xr(d)] = b, p));
                })] : ($j(d) ? h = d : (h = i[d.name.value], W(h, 21, d.name.value)), h && h.typeCondition && (g = h.typeCondition.name.value, a.fragmentMatcher(r, g, o)) ? [2, this.resolveSelectionSet(h.selectionSet, n, r, a).then(function(b) {
                  l.push(b);
                })] : [
                  2
                  /*return*/
                ]) : [
                  2
                  /*return*/
                ];
              });
            });
          }, [2, Promise.all(t.selections.map(c)).then(function() {
            return oh(l);
          })];
        });
      });
    }, e.prototype.resolveField = function(t, n, r, a) {
      return ma(this, void 0, void 0, function() {
        var i, o, s, l, c, u, f, d, h, g = this;
        return ga(this, function(v) {
          return r ? (i = a.variables, o = t.name.value, s = Xr(t), l = o !== s, c = r[s] || r[o], u = Promise.resolve(c), (!a.onlyRunForcedResolvers || this.shouldForceResolvers(t)) && (f = r.__typename || a.defaultOperationType, d = this.resolvers && this.resolvers[f], d && (h = d[l ? o : s], h && (u = Promise.resolve(
            // In case the resolve function accesses reactive variables,
            // set cacheSlot to the current cache instance.
            Zy.withValue(this.cache, h, [
              r,
              rh(t, i),
              a.context,
              { field: t, fragmentMap: a.fragmentMap }
            ])
          )))), [2, u.then(function(b) {
            var p, m;
            if (b === void 0 && (b = c), t.directives && t.directives.forEach(function(x) {
              x.name.value === "export" && x.arguments && x.arguments.forEach(function(S) {
                S.name.value === "as" && S.value.kind === "StringValue" && (a.exportedVariables[S.value.value] = b);
              });
            }), !t.selectionSet || b == null)
              return b;
            var w = (m = (p = t.directives) === null || p === void 0 ? void 0 : p.some(function(x) {
              return x.name.value === "client";
            })) !== null && m !== void 0 ? m : !1;
            if (Array.isArray(b))
              return g.resolveSubSelectedArray(t, n || w, b, a);
            if (t.selectionSet)
              return g.resolveSelectionSet(t.selectionSet, n || w, b, a);
          })]) : [2, null];
        });
      });
    }, e.prototype.resolveSubSelectedArray = function(t, n, r, a) {
      var i = this;
      return Promise.all(r.map(function(o) {
        if (o === null)
          return null;
        if (Array.isArray(o))
          return i.resolveSubSelectedArray(t, n, o, a);
        if (t.selectionSet)
          return i.resolveSelectionSet(t.selectionSet, n, o, a);
      }));
    }, e.prototype.collectSelectionsToResolve = function(t, n) {
      var r = function(o) {
        return !Array.isArray(o);
      }, a = this.selectionsToResolveCache;
      function i(o) {
        if (!a.has(o)) {
          var s = /* @__PURE__ */ new Set();
          a.set(o, s), Vn(o, {
            Directive: function(l, c, u, f, d) {
              l.name.value === "client" && d.forEach(function(h) {
                r(h) && nx(h) && s.add(h);
              });
            },
            FragmentSpread: function(l, c, u, f, d) {
              var h = n[l.name.value];
              W(h, 22, l.name.value);
              var g = i(h);
              g.size > 0 && (d.forEach(function(v) {
                r(v) && nx(v) && s.add(v);
              }), s.add(l), g.forEach(function(v) {
                s.add(v);
              }));
            }
          });
        }
        return a.get(o);
      }
      return i(t);
    }, e;
  }()
), Hx = !1, DA = (
  /** @class */
  function() {
    function e(t) {
      var n = this, r, a, i;
      if (this.resetStoreCallbacks = [], this.clearStoreCallbacks = [], !t.cache)
        throw Gt(16);
      var o = t.uri, s = t.credentials, l = t.headers, c = t.cache, u = t.documentTransform, f = t.ssrMode, d = f === void 0 ? !1 : f, h = t.ssrForceFetchDelay, g = h === void 0 ? 0 : h, v = t.connectToDevTools, b = t.queryDeduplication, p = b === void 0 ? !0 : b, m = t.defaultOptions, w = t.defaultContext, x = t.assumeImmutableResults, S = x === void 0 ? c.assumeImmutableResults : x, T = t.resolvers, E = t.typeDefs, O = t.fragmentMatcher, D = t.clientAwareness, A = t.name, U = t.version, R = t.devtools, q = t.dataMasking;
      globalThis.__DEV__ !== !1 && (st(t, "connectToDevTools", "ApolloClient", "Please use `devtools.enabled` instead."), st(t, "uri", "ApolloClient", "Please initialize an instance of `HttpLink` with `uri` instead."), st(t, "credentials", "ApolloClient", "Please initialize an instance of `HttpLink` with `credentials` instead."), st(t, "headers", "ApolloClient", "Please initialize an instance of `HttpLink` with `headers` instead."), st(t, "name", "ApolloClient", "Please use the `clientAwareness.name` option instead."), st(t, "version", "ApolloClient", "Please use the `clientAwareness.version` option instead."), st(t, "typeDefs", "ApolloClient"), t.link || globalThis.__DEV__ !== !1 && W.warn(17));
      var z = t.link;
      z || (z = o ? new eI({ uri: o, credentials: s, headers: l }) : gr.empty()), this.link = z, this.cache = c, this.disableNetworkFetches = d || g > 0, this.queryDeduplication = p, this.defaultOptions = m || /* @__PURE__ */ Object.create(null), this.typeDefs = E, this.devtoolsConfig = M(M({}, R), { enabled: (r = R == null ? void 0 : R.enabled) !== null && r !== void 0 ? r : v }), this.devtoolsConfig.enabled === void 0 && (this.devtoolsConfig.enabled = globalThis.__DEV__ !== !1), g && setTimeout(function() {
        return n.disableNetworkFetches = !1;
      }, g), this.watchQuery = this.watchQuery.bind(this), this.query = this.query.bind(this), this.mutate = this.mutate.bind(this), this.watchFragment = this.watchFragment.bind(this), this.resetStore = this.resetStore.bind(this), this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this), this.version = zy, this.localState = new _I({
        cache: c,
        client: this,
        resolvers: T,
        fragmentMatcher: O
      }), this.queryManager = new RI({
        cache: this.cache,
        link: this.link,
        defaultOptions: this.defaultOptions,
        defaultContext: w,
        documentTransform: u,
        queryDeduplication: p,
        ssrMode: d,
        dataMasking: !!q,
        clientAwareness: {
          name: (a = D == null ? void 0 : D.name) !== null && a !== void 0 ? a : A,
          version: (i = D == null ? void 0 : D.version) !== null && i !== void 0 ? i : U
        },
        localState: this.localState,
        assumeImmutableResults: S,
        onBroadcast: this.devtoolsConfig.enabled ? function() {
          n.devToolsHookCb && n.devToolsHookCb({
            action: {},
            state: {
              queries: n.queryManager.getQueryStore(),
              mutations: n.queryManager.mutationStore || {}
            },
            dataWithOptimisticResults: n.cache.extract(!0)
          });
        } : void 0
      }), this.devtoolsConfig.enabled && this.connectToDevTools();
    }
    return Object.defineProperty(e.prototype, "prioritizeCacheValues", {
      /**
       * Whether to prioritize cache values over network results when `query` or `watchQuery` is called.
       * This will essentially turn a `"network-only"` or `"cache-and-network"` fetchPolicy into a `"cache-first"` fetchPolicy,
       * but without influencing the `fetchPolicy` of the created `ObservableQuery` long-term.
       *
       * This can e.g. be used to prioritize the cache during the first render after SSR.
       */
      get: function() {
        return this.disableNetworkFetches;
      },
      set: function(t) {
        this.disableNetworkFetches = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.connectToDevTools = function() {
      if (!(typeof window > "u")) {
        var t = window, n = Symbol.for("apollo.devtools");
        (t[n] = t[n] || []).push(this), t.__APOLLO_CLIENT__ = this, !Hx && globalThis.__DEV__ !== !1 && (Hx = !0, window.document && window.top === window.self && /^(https?|file):$/.test(window.location.protocol) && setTimeout(function() {
          if (!window.__APOLLO_DEVTOOLS_GLOBAL_HOOK__) {
            var r = window.navigator, a = r && r.userAgent, i = void 0;
            typeof a == "string" && (a.indexOf("Chrome/") > -1 ? i = "https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm" : a.indexOf("Firefox/") > -1 && (i = "https://addons.mozilla.org/en-US/firefox/addon/apollo-developer-tools/")), i && globalThis.__DEV__ !== !1 && W.log("Download the Apollo DevTools for a better development experience: %s", i);
          }
        }, 1e4));
      }
    }, Object.defineProperty(e.prototype, "documentTransform", {
      /**
       * The `DocumentTransform` used to modify GraphQL documents before a request
       * is made. If a custom `DocumentTransform` is not provided, this will be the
       * default document transform.
       */
      get: function() {
        return this.queryManager.documentTransform;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.stop = function() {
      this.queryManager.stop();
    }, e.prototype.watchQuery = function(t) {
      return this.defaultOptions.watchQuery && (t = Tp(this.defaultOptions.watchQuery, t)), this.disableNetworkFetches && (t.fetchPolicy === "network-only" || t.fetchPolicy === "cache-and-network") && (t = M(M({}, t), { fetchPolicy: "cache-first" })), globalThis.__DEV__ !== !1 && (st(t, "canonizeResults", "client.watchQuery"), st(t, "partialRefetch", "client.watchQuery")), this.queryManager.watchQuery(t);
    }, e.prototype.query = function(t) {
      return this.defaultOptions.query && (t = Tp(this.defaultOptions.query, t)), W(t.fetchPolicy !== "cache-and-network", 18), this.disableNetworkFetches && t.fetchPolicy === "network-only" && (t = M(M({}, t), { fetchPolicy: "cache-first" })), globalThis.__DEV__ !== !1 && (st(t, "canonizeResults", "client.query"), st(t, "notifyOnNetworkStatusChange", "client.query", "This option does not affect `client.query` and can be safely removed."), t.fetchPolicy === "standby" && globalThis.__DEV__ !== !1 && W.warn(19)), this.queryManager.query(t);
    }, e.prototype.mutate = function(t) {
      return this.defaultOptions.mutate && (t = Tp(this.defaultOptions.mutate, t)), this.queryManager.mutate(t);
    }, e.prototype.subscribe = function(t) {
      var n = this, r = this.queryManager.generateQueryId();
      return this.queryManager.startGraphQLSubscription(t).map(function(a) {
        return M(M({}, a), { data: n.queryManager.maskOperation({
          document: t.query,
          data: a.data,
          fetchPolicy: t.fetchPolicy,
          id: r
        }) });
      });
    }, e.prototype.readQuery = function(t, n) {
      return n === void 0 && (n = !1), this.cache.readQuery(t, n);
    }, e.prototype.watchFragment = function(t) {
      var n;
      return this.cache.watchFragment(M(M({}, t), (n = {}, n[Symbol.for("apollo.dataMasking")] = this.queryManager.dataMasking, n)));
    }, e.prototype.readFragment = function(t, n) {
      return n === void 0 && (n = !1), this.cache.readFragment(t, n);
    }, e.prototype.writeQuery = function(t) {
      var n = this.cache.writeQuery(t);
      return t.broadcast !== !1 && this.queryManager.broadcastQueries(), n;
    }, e.prototype.writeFragment = function(t) {
      var n = this.cache.writeFragment(t);
      return t.broadcast !== !1 && this.queryManager.broadcastQueries(), n;
    }, e.prototype.__actionHookForDevTools = function(t) {
      this.devToolsHookCb = t;
    }, e.prototype.__requestRaw = function(t) {
      return Lg(this.link, t);
    }, e.prototype.resetStore = function() {
      var t = this;
      return Promise.resolve().then(function() {
        return t.queryManager.clearStore({
          discardWatches: !1
        });
      }).then(function() {
        return Promise.all(t.resetStoreCallbacks.map(function(n) {
          return n();
        }));
      }).then(function() {
        return t.reFetchObservableQueries();
      });
    }, e.prototype.clearStore = function() {
      var t = this;
      return Promise.resolve().then(function() {
        return t.queryManager.clearStore({
          discardWatches: !0
        });
      }).then(function() {
        return Promise.all(t.clearStoreCallbacks.map(function(n) {
          return n();
        }));
      });
    }, e.prototype.onResetStore = function(t) {
      var n = this;
      return this.resetStoreCallbacks.push(t), function() {
        n.resetStoreCallbacks = n.resetStoreCallbacks.filter(function(r) {
          return r !== t;
        });
      };
    }, e.prototype.onClearStore = function(t) {
      var n = this;
      return this.clearStoreCallbacks.push(t), function() {
        n.clearStoreCallbacks = n.clearStoreCallbacks.filter(function(r) {
          return r !== t;
        });
      };
    }, e.prototype.reFetchObservableQueries = function(t) {
      return this.queryManager.reFetchObservableQueries(t);
    }, e.prototype.refetchQueries = function(t) {
      var n = this.queryManager.refetchQueries(t), r = [], a = [];
      n.forEach(function(o, s) {
        r.push(s), a.push(o);
      });
      var i = Promise.all(a);
      return i.queries = r, i.results = a, i.catch(function(o) {
        globalThis.__DEV__ !== !1 && W.debug(20, o);
      }), i;
    }, e.prototype.getObservableQueries = function(t) {
      return t === void 0 && (t = "active"), this.queryManager.getObservableQueries(t);
    }, e.prototype.extract = function(t) {
      return this.cache.extract(t);
    }, e.prototype.restore = function(t) {
      return this.cache.restore(t);
    }, e.prototype.addResolvers = function(t) {
      this.localState.addResolvers(t);
    }, e.prototype.setResolvers = function(t) {
      this.localState.setResolvers(t);
    }, e.prototype.getResolvers = function() {
      return this.localState.getResolvers();
    }, e.prototype.setLocalStateFragmentMatcher = function(t) {
      this.localState.setFragmentMatcher(t);
    }, e.prototype.setLink = function(t) {
      this.link = this.queryManager.link = t;
    }, Object.defineProperty(e.prototype, "defaultContext", {
      get: function() {
        return this.queryManager.defaultContext;
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }()
);
globalThis.__DEV__ !== !1 && (DA.prototype.getMemoryInternals = Cj);
var NA = { exports: {} };
(function(e) {
  e.exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = void 0, e.exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = void 0, e.exports.__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = void 0, Object.assign(e.exports, y);
})(NA);
var Ka = NA.exports;
const DI = /* @__PURE__ */ _d(Ka), NI = /* @__PURE__ */ wS({
  __proto__: null,
  default: DI
}, [Ka]);
var $x = qy ? Symbol.for("__APOLLO_CONTEXT__") : "__APOLLO_CONTEXT__";
function kI() {
  W("createContext" in NI, 69);
  var e = Ka.createContext[$x];
  return e || (Object.defineProperty(Ka.createContext, $x, {
    value: e = Ka.createContext({}),
    enumerable: !1,
    writable: !1,
    configurable: !0
  }), e.displayName = "ApolloContext"), e;
}
var kA = function(e) {
  var t = e.client, n = e.children, r = kI(), a = Ka.useContext(r), i = Ka.useMemo(function() {
    return M(M({}, a), { client: t || a.client });
  }, [a, t]);
  return W(i.client, 71), Ka.createElement(r.Provider, { value: i }, n);
};
const MI = (e, t, n, r) => {
  var i, o, s, l;
  const a = [n, {
    code: t,
    ...r || {}
  }];
  if ((o = (i = e == null ? void 0 : e.services) == null ? void 0 : i.logger) != null && o.forward)
    return e.services.logger.forward(a, "warn", "react-i18next::", !0);
  Hi(a[0]) && (a[0] = `react-i18next:: ${a[0]}`), (l = (s = e == null ? void 0 : e.services) == null ? void 0 : s.logger) != null && l.warn ? e.services.logger.warn(...a) : console != null && console.warn && console.warn(...a);
}, Gx = {}, qg = (e, t, n, r) => {
  Hi(n) && Gx[n] || (Hi(n) && (Gx[n] = /* @__PURE__ */ new Date()), MI(e, t, n, r));
}, MA = (e, t) => () => {
  if (e.isInitialized)
    t();
  else {
    const n = () => {
      setTimeout(() => {
        e.off("initialized", n);
      }, 0), t();
    };
    e.on("initialized", n);
  }
}, Bg = (e, t, n) => {
  e.loadNamespaces(t, MA(e, n));
}, Yx = (e, t, n, r) => {
  if (Hi(n) && (n = [n]), e.options.preload && e.options.preload.indexOf(t) > -1) return Bg(e, n, r);
  n.forEach((a) => {
    e.options.ns.indexOf(a) < 0 && e.options.ns.push(a);
  }), e.loadLanguages(t, MA(e, r));
}, LI = (e, t, n = {}) => !t.languages || !t.languages.length ? (qg(t, "NO_LANGUAGES", "i18n.languages were undefined or empty", {
  languages: t.languages
}), !0) : t.hasLoadedNamespace(e, {
  lng: n.lng,
  precheck: (r, a) => {
    if (n.bindI18n && n.bindI18n.indexOf("languageChanging") > -1 && r.services.backendConnector.backend && r.isLanguageChangingTo && !a(r.isLanguageChangingTo, e)) return !1;
  }
}), Hi = (e) => typeof e == "string", zI = (e) => typeof e == "object" && e !== null, jI = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g, PI = {
  "&amp;": "&",
  "&#38;": "&",
  "&lt;": "<",
  "&#60;": "<",
  "&gt;": ">",
  "&#62;": ">",
  "&apos;": "'",
  "&#39;": "'",
  "&quot;": '"',
  "&#34;": '"',
  "&nbsp;": " ",
  "&#160;": " ",
  "&copy;": "",
  "&#169;": "",
  "&reg;": "",
  "&#174;": "",
  "&hellip;": "",
  "&#8230;": "",
  "&#x2F;": "/",
  "&#47;": "/"
}, II = (e) => PI[e], FI = (e) => e.replace(jI, II);
let Vg = {
  bindI18n: "languageChanged",
  bindI18nStore: "",
  transEmptyNodeValue: "",
  transSupportBasicHtmlNodes: !0,
  transWrapTextNodes: "",
  transKeepBasicHtmlNodesFor: ["br", "strong", "i", "p"],
  useSuspense: !0,
  unescape: FI
};
const UI = (e = {}) => {
  Vg = {
    ...Vg,
    ...e
  };
}, qI = () => Vg;
let LA;
const BI = (e) => {
  LA = e;
}, VI = () => LA, QI = {
  type: "3rdParty",
  init(e) {
    UI(e.options.react), BI(e);
  }
}, zA = y.createContext();
class HI {
  constructor() {
    this.usedNamespaces = {};
  }
  addUsedNamespaces(t) {
    t.forEach((n) => {
      this.usedNamespaces[n] || (this.usedNamespaces[n] = !0);
    });
  }
  getUsedNamespaces() {
    return Object.keys(this.usedNamespaces);
  }
}
const $I = (e, t) => {
  const n = y.useRef();
  return y.useEffect(() => {
    n.current = e;
  }, [e, t]), n.current;
}, jA = (e, t, n, r) => e.getFixedT(t, n, r), GI = (e, t, n, r) => y.useCallback(jA(e, t, n, r), [e, t, n, r]), YI = (e, t = {}) => {
  var x, S, T, E;
  const {
    i18n: n
  } = t, {
    i18n: r,
    defaultNS: a
  } = y.useContext(zA) || {}, i = n || r || VI();
  if (i && !i.reportNamespaces && (i.reportNamespaces = new HI()), !i) {
    qg(i, "NO_I18NEXT_INSTANCE", "useTranslation: You will need to pass in an i18next instance by using initReactI18next");
    const O = (A, U) => Hi(U) ? U : zI(U) && Hi(U.defaultValue) ? U.defaultValue : Array.isArray(A) ? A[A.length - 1] : A, D = [O, {}, !1];
    return D.t = O, D.i18n = {}, D.ready = !1, D;
  }
  (x = i.options.react) != null && x.wait && qg(i, "DEPRECATED_OPTION", "useTranslation: It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");
  const o = {
    ...qI(),
    ...i.options.react,
    ...t
  }, {
    useSuspense: s,
    keyPrefix: l
  } = o;
  let c = a || ((S = i.options) == null ? void 0 : S.defaultNS);
  c = Hi(c) ? [c] : c || ["translation"], (E = (T = i.reportNamespaces).addUsedNamespaces) == null || E.call(T, c);
  const u = (i.isInitialized || i.initializedStoreOnce) && c.every((O) => LI(O, i, o)), f = GI(i, t.lng || null, o.nsMode === "fallback" ? c : c[0], l), d = () => f, h = () => jA(i, t.lng || null, o.nsMode === "fallback" ? c : c[0], l), [g, v] = y.useState(d);
  let b = c.join();
  t.lng && (b = `${t.lng}${b}`);
  const p = $I(b), m = y.useRef(!0);
  y.useEffect(() => {
    const {
      bindI18n: O,
      bindI18nStore: D
    } = o;
    m.current = !0, !u && !s && (t.lng ? Yx(i, t.lng, c, () => {
      m.current && v(h);
    }) : Bg(i, c, () => {
      m.current && v(h);
    })), u && p && p !== b && m.current && v(h);
    const A = () => {
      m.current && v(h);
    };
    return O && (i == null || i.on(O, A)), D && (i == null || i.store.on(D, A)), () => {
      m.current = !1, i && O && (O == null || O.split(" ").forEach((U) => i.off(U, A))), D && i && D.split(" ").forEach((U) => i.store.off(U, A));
    };
  }, [i, b]), y.useEffect(() => {
    m.current && u && v(d);
  }, [i, l, u]);
  const w = [g, i, u];
  if (w.t = g, w.i18n = i, w.ready = u, u || !u && !s) return w;
  throw new Promise((O) => {
    t.lng ? Yx(i, t.lng, c, () => O()) : Bg(i, c, () => O());
  });
};
function KI({
  i18n: e,
  defaultNS: t,
  children: n
}) {
  const r = y.useMemo(() => ({
    i18n: e,
    defaultNS: t
  }), [e, t]);
  return y.createElement(zA.Provider, {
    value: r
  }, n);
}
function PA(e) {
  var t, n, r = "";
  if (typeof e == "string" || typeof e == "number") r += e;
  else if (typeof e == "object") if (Array.isArray(e)) {
    var a = e.length;
    for (t = 0; t < a; t++) e[t] && (n = PA(e[t])) && (r && (r += " "), r += n);
  } else for (n in e) e[n] && (r && (r += " "), r += n);
  return r;
}
function XI() {
  for (var e, t, n = 0, r = "", a = arguments.length; n < a; n++) (e = arguments[n]) && (t = PA(e)) && (r && (r += " "), r += t);
  return r;
}
const nb = "-", WI = (e) => {
  const t = JI(e), {
    conflictingClassGroups: n,
    conflictingClassGroupModifiers: r
  } = e;
  return {
    getClassGroupId: (o) => {
      const s = o.split(nb);
      return s[0] === "" && s.length !== 1 && s.shift(), IA(s, t) || ZI(o);
    },
    getConflictingClassGroupIds: (o, s) => {
      const l = n[o] || [];
      return s && r[o] ? [...l, ...r[o]] : l;
    }
  };
}, IA = (e, t) => {
  var o;
  if (e.length === 0)
    return t.classGroupId;
  const n = e[0], r = t.nextPart.get(n), a = r ? IA(e.slice(1), r) : void 0;
  if (a)
    return a;
  if (t.validators.length === 0)
    return;
  const i = e.join(nb);
  return (o = t.validators.find(({
    validator: s
  }) => s(i))) == null ? void 0 : o.classGroupId;
}, Kx = /^\[(.+)\]$/, ZI = (e) => {
  if (Kx.test(e)) {
    const t = Kx.exec(e)[1], n = t == null ? void 0 : t.substring(0, t.indexOf(":"));
    if (n)
      return "arbitrary.." + n;
  }
}, JI = (e) => {
  const {
    theme: t,
    prefix: n
  } = e, r = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  return tF(Object.entries(e.classGroups), n).forEach(([i, o]) => {
    Qg(o, r, i, t);
  }), r;
}, Qg = (e, t, n, r) => {
  e.forEach((a) => {
    if (typeof a == "string") {
      const i = a === "" ? t : Xx(t, a);
      i.classGroupId = n;
      return;
    }
    if (typeof a == "function") {
      if (eF(a)) {
        Qg(a(r), t, n, r);
        return;
      }
      t.validators.push({
        validator: a,
        classGroupId: n
      });
      return;
    }
    Object.entries(a).forEach(([i, o]) => {
      Qg(o, Xx(t, i), n, r);
    });
  });
}, Xx = (e, t) => {
  let n = e;
  return t.split(nb).forEach((r) => {
    n.nextPart.has(r) || n.nextPart.set(r, {
      nextPart: /* @__PURE__ */ new Map(),
      validators: []
    }), n = n.nextPart.get(r);
  }), n;
}, eF = (e) => e.isThemeGetter, tF = (e, t) => t ? e.map(([n, r]) => {
  const a = r.map((i) => typeof i == "string" ? t + i : typeof i == "object" ? Object.fromEntries(Object.entries(i).map(([o, s]) => [t + o, s])) : i);
  return [n, a];
}) : e, nF = (e) => {
  if (e < 1)
    return {
      get: () => {
      },
      set: () => {
      }
    };
  let t = 0, n = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map();
  const a = (i, o) => {
    n.set(i, o), t++, t > e && (t = 0, r = n, n = /* @__PURE__ */ new Map());
  };
  return {
    get(i) {
      let o = n.get(i);
      if (o !== void 0)
        return o;
      if ((o = r.get(i)) !== void 0)
        return a(i, o), o;
    },
    set(i, o) {
      n.has(i) ? n.set(i, o) : a(i, o);
    }
  };
}, FA = "!", rF = (e) => {
  const {
    separator: t,
    experimentalParseClassName: n
  } = e, r = t.length === 1, a = t[0], i = t.length, o = (s) => {
    const l = [];
    let c = 0, u = 0, f;
    for (let b = 0; b < s.length; b++) {
      let p = s[b];
      if (c === 0) {
        if (p === a && (r || s.slice(b, b + i) === t)) {
          l.push(s.slice(u, b)), u = b + i;
          continue;
        }
        if (p === "/") {
          f = b;
          continue;
        }
      }
      p === "[" ? c++ : p === "]" && c--;
    }
    const d = l.length === 0 ? s : s.substring(u), h = d.startsWith(FA), g = h ? d.substring(1) : d, v = f && f > u ? f - u : void 0;
    return {
      modifiers: l,
      hasImportantModifier: h,
      baseClassName: g,
      maybePostfixModifierPosition: v
    };
  };
  return n ? (s) => n({
    className: s,
    parseClassName: o
  }) : o;
}, aF = (e) => {
  if (e.length <= 1)
    return e;
  const t = [];
  let n = [];
  return e.forEach((r) => {
    r[0] === "[" ? (t.push(...n.sort(), r), n = []) : n.push(r);
  }), t.push(...n.sort()), t;
}, iF = (e) => ({
  cache: nF(e.cacheSize),
  parseClassName: rF(e),
  ...WI(e)
}), oF = /\s+/, sF = (e, t) => {
  const {
    parseClassName: n,
    getClassGroupId: r,
    getConflictingClassGroupIds: a
  } = t, i = [], o = e.trim().split(oF);
  let s = "";
  for (let l = o.length - 1; l >= 0; l -= 1) {
    const c = o[l], {
      modifiers: u,
      hasImportantModifier: f,
      baseClassName: d,
      maybePostfixModifierPosition: h
    } = n(c);
    let g = !!h, v = r(g ? d.substring(0, h) : d);
    if (!v) {
      if (!g) {
        s = c + (s.length > 0 ? " " + s : s);
        continue;
      }
      if (v = r(d), !v) {
        s = c + (s.length > 0 ? " " + s : s);
        continue;
      }
      g = !1;
    }
    const b = aF(u).join(":"), p = f ? b + FA : b, m = p + v;
    if (i.includes(m))
      continue;
    i.push(m);
    const w = a(v, g);
    for (let x = 0; x < w.length; ++x) {
      const S = w[x];
      i.push(p + S);
    }
    s = c + (s.length > 0 ? " " + s : s);
  }
  return s;
};
function lF() {
  let e = 0, t, n, r = "";
  for (; e < arguments.length; )
    (t = arguments[e++]) && (n = UA(t)) && (r && (r += " "), r += n);
  return r;
}
const UA = (e) => {
  if (typeof e == "string")
    return e;
  let t, n = "";
  for (let r = 0; r < e.length; r++)
    e[r] && (t = UA(e[r])) && (n && (n += " "), n += t);
  return n;
};
function cF(e, ...t) {
  let n, r, a, i = o;
  function o(l) {
    const c = t.reduce((u, f) => f(u), e());
    return n = iF(c), r = n.cache.get, a = n.cache.set, i = s, s(l);
  }
  function s(l) {
    const c = r(l);
    if (c)
      return c;
    const u = sF(l, n);
    return a(l, u), u;
  }
  return function() {
    return i(lF.apply(null, arguments));
  };
}
const $e = (e) => {
  const t = (n) => n[e] || [];
  return t.isThemeGetter = !0, t;
}, qA = /^\[(?:([a-z-]+):)?(.+)\]$/i, uF = /^\d+\/\d+$/, fF = /* @__PURE__ */ new Set(["px", "full", "screen"]), dF = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, hF = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, pF = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/, mF = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, gF = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, Rr = (e) => ss(e) || fF.has(e) || uF.test(e), oa = (e) => nl(e, "length", TF), ss = (e) => !!e && !Number.isNaN(Number(e)), kp = (e) => nl(e, "number", ss), Cl = (e) => !!e && Number.isInteger(Number(e)), vF = (e) => e.endsWith("%") && ss(e.slice(0, -1)), ve = (e) => qA.test(e), sa = (e) => dF.test(e), yF = /* @__PURE__ */ new Set(["length", "size", "percentage"]), bF = (e) => nl(e, yF, BA), wF = (e) => nl(e, "position", BA), xF = /* @__PURE__ */ new Set(["image", "url"]), EF = (e) => nl(e, xF, OF), SF = (e) => nl(e, "", CF), Ol = () => !0, nl = (e, t, n) => {
  const r = qA.exec(e);
  return r ? r[1] ? typeof t == "string" ? r[1] === t : t.has(r[1]) : n(r[2]) : !1;
}, TF = (e) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  hF.test(e) && !pF.test(e)
), BA = () => !1, CF = (e) => mF.test(e), OF = (e) => gF.test(e), AF = () => {
  const e = $e("colors"), t = $e("spacing"), n = $e("blur"), r = $e("brightness"), a = $e("borderColor"), i = $e("borderRadius"), o = $e("borderSpacing"), s = $e("borderWidth"), l = $e("contrast"), c = $e("grayscale"), u = $e("hueRotate"), f = $e("invert"), d = $e("gap"), h = $e("gradientColorStops"), g = $e("gradientColorStopPositions"), v = $e("inset"), b = $e("margin"), p = $e("opacity"), m = $e("padding"), w = $e("saturate"), x = $e("scale"), S = $e("sepia"), T = $e("skew"), E = $e("space"), O = $e("translate"), D = () => ["auto", "contain", "none"], A = () => ["auto", "hidden", "clip", "visible", "scroll"], U = () => ["auto", ve, t], R = () => [ve, t], q = () => ["", Rr, oa], z = () => ["auto", ss, ve], Q = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"], k = () => ["solid", "dashed", "dotted", "double", "none"], P = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], F = () => ["start", "end", "center", "between", "around", "evenly", "stretch"], H = () => ["", "0", ve], K = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], Z = () => [ss, ve];
  return {
    cacheSize: 500,
    separator: ":",
    theme: {
      colors: [Ol],
      spacing: [Rr, oa],
      blur: ["none", "", sa, ve],
      brightness: Z(),
      borderColor: [e],
      borderRadius: ["none", "", "full", sa, ve],
      borderSpacing: R(),
      borderWidth: q(),
      contrast: Z(),
      grayscale: H(),
      hueRotate: Z(),
      invert: H(),
      gap: R(),
      gradientColorStops: [e],
      gradientColorStopPositions: [vF, oa],
      inset: U(),
      margin: U(),
      opacity: Z(),
      padding: R(),
      saturate: Z(),
      scale: Z(),
      sepia: H(),
      skew: Z(),
      space: R(),
      translate: R()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", ve]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [sa]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": K()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": K()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [...Q(), ve]
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: A()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": A()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": A()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: D()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": D()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": D()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [v]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [v]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [v]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [v]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [v]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [v]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [v]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [v]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [v]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", Cl, ve]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: U()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", ve]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: H()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: H()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", Cl, ve]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [Ol]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", Cl, ve]
        }, ve]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": z()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": z()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [Ol]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [Cl, ve]
        }, ve]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": z()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": z()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", ve]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", ve]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [d]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [d]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [d]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal", ...F()]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...F(), "baseline"]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [...F(), "baseline"]
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [m]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [m]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [m]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [m]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [m]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [m]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [m]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [m]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [m]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [b]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [b]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [b]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [b]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [b]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [b]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [b]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [b]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [b]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [E]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [E]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", ve, t]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [ve, t, "min", "max", "fit"]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [ve, t, "none", "full", "min", "max", "fit", "prose", {
          screen: [sa]
        }, sa]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [ve, t, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": [ve, t, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [ve, t, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Size
       * @see https://tailwindcss.com/docs/size
       */
      size: [{
        size: [ve, t, "auto", "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", sa, oa]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", kp]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [Ol]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", ve]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", ss, kp]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", Rr, ve]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", ve]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", ve]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [e]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [p]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [e]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [p]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...k(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", Rr, oa]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", Rr, ve]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [e]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: R()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", ve]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", ve]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [p]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [...Q(), wF]
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", bF]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, EF]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [e]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [g]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [g]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [g]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [h]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [h]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [h]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [i]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [i]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [i]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [i]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [i]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [i]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [i]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [i]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [i]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [i]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [i]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [i]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [i]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [i]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [i]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [s]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [s]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [s]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [s]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [s]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [s]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [s]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [s]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [s]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [p]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...k(), "hidden"]
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [s]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [s]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [p]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: k()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [a]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [a]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [a]
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": [a]
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": [a]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [a]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [a]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [a]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [a]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [a]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: ["", ...k()]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [Rr, ve]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [Rr, oa]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [e]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: q()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [e]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [p]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [Rr, oa]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [e]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", sa, SF]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [Ol]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [p]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...P(), "plus-lighter", "plus-darker"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": P()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [n]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [r]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [l]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", sa, ve]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [c]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [u]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [f]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [w]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [S]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [n]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [r]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [l]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [c]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [u]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [f]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [p]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [w]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [S]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [o]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [o]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [o]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", ve]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: Z()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", ve]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: Z()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", ve]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [x]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [x]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [x]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [Cl, ve]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [O]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [O]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [T]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [T]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", ve]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", e]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", ve]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [e]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": R()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": R()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": R()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": R()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": R()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": R()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": R()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": R()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": R()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": R()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": R()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": R()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": R()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": R()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": R()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": R()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": R()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": R()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", ve]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [e, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [Rr, oa, kp]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [e, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
}, RF = /* @__PURE__ */ cF(AF);
function at(...e) {
  return RF(XI(e));
}
const _F = () => Math.random().toString(36).substring(2);
var Wx = (e) => typeof e == "boolean" ? `${e}` : e === 0 ? "0" : e, Zt = (e) => !e || typeof e != "object" || Object.keys(e).length === 0, DF = (e, t) => JSON.stringify(e) === JSON.stringify(t);
function VA(e, t) {
  e.forEach(function(n) {
    Array.isArray(n) ? VA(n, t) : t.push(n);
  });
}
function QA(e) {
  let t = [];
  return VA(e, t), t;
}
var HA = (...e) => QA(e).filter(Boolean), $A = (e, t) => {
  let n = {}, r = Object.keys(e), a = Object.keys(t);
  for (let i of r) if (a.includes(i)) {
    let o = e[i], s = t[i];
    Array.isArray(o) || Array.isArray(s) ? n[i] = HA(s, o) : typeof o == "object" && typeof s == "object" ? n[i] = $A(o, s) : n[i] = s + " " + o;
  } else n[i] = e[i];
  for (let i of a) r.includes(i) || (n[i] = t[i]);
  return n;
}, Zx = (e) => !e || typeof e != "string" ? e : e.replace(/\s+/g, " ").trim();
const rb = "-", NF = (e) => {
  const t = MF(e), {
    conflictingClassGroups: n,
    conflictingClassGroupModifiers: r
  } = e;
  return {
    getClassGroupId: (o) => {
      const s = o.split(rb);
      return s[0] === "" && s.length !== 1 && s.shift(), GA(s, t) || kF(o);
    },
    getConflictingClassGroupIds: (o, s) => {
      const l = n[o] || [];
      return s && r[o] ? [...l, ...r[o]] : l;
    }
  };
}, GA = (e, t) => {
  var o;
  if (e.length === 0)
    return t.classGroupId;
  const n = e[0], r = t.nextPart.get(n), a = r ? GA(e.slice(1), r) : void 0;
  if (a)
    return a;
  if (t.validators.length === 0)
    return;
  const i = e.join(rb);
  return (o = t.validators.find(({
    validator: s
  }) => s(i))) == null ? void 0 : o.classGroupId;
}, Jx = /^\[(.+)\]$/, kF = (e) => {
  if (Jx.test(e)) {
    const t = Jx.exec(e)[1], n = t == null ? void 0 : t.substring(0, t.indexOf(":"));
    if (n)
      return "arbitrary.." + n;
  }
}, MF = (e) => {
  const {
    theme: t,
    prefix: n
  } = e, r = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  return zF(Object.entries(e.classGroups), n).forEach(([i, o]) => {
    Hg(o, r, i, t);
  }), r;
}, Hg = (e, t, n, r) => {
  e.forEach((a) => {
    if (typeof a == "string") {
      const i = a === "" ? t : eE(t, a);
      i.classGroupId = n;
      return;
    }
    if (typeof a == "function") {
      if (LF(a)) {
        Hg(a(r), t, n, r);
        return;
      }
      t.validators.push({
        validator: a,
        classGroupId: n
      });
      return;
    }
    Object.entries(a).forEach(([i, o]) => {
      Hg(o, eE(t, i), n, r);
    });
  });
}, eE = (e, t) => {
  let n = e;
  return t.split(rb).forEach((r) => {
    n.nextPart.has(r) || n.nextPart.set(r, {
      nextPart: /* @__PURE__ */ new Map(),
      validators: []
    }), n = n.nextPart.get(r);
  }), n;
}, LF = (e) => e.isThemeGetter, zF = (e, t) => t ? e.map(([n, r]) => {
  const a = r.map((i) => typeof i == "string" ? t + i : typeof i == "object" ? Object.fromEntries(Object.entries(i).map(([o, s]) => [t + o, s])) : i);
  return [n, a];
}) : e, jF = (e) => {
  if (e < 1)
    return {
      get: () => {
      },
      set: () => {
      }
    };
  let t = 0, n = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map();
  const a = (i, o) => {
    n.set(i, o), t++, t > e && (t = 0, r = n, n = /* @__PURE__ */ new Map());
  };
  return {
    get(i) {
      let o = n.get(i);
      if (o !== void 0)
        return o;
      if ((o = r.get(i)) !== void 0)
        return a(i, o), o;
    },
    set(i, o) {
      n.has(i) ? n.set(i, o) : a(i, o);
    }
  };
}, YA = "!", PF = (e) => {
  const {
    separator: t,
    experimentalParseClassName: n
  } = e, r = t.length === 1, a = t[0], i = t.length, o = (s) => {
    const l = [];
    let c = 0, u = 0, f;
    for (let b = 0; b < s.length; b++) {
      let p = s[b];
      if (c === 0) {
        if (p === a && (r || s.slice(b, b + i) === t)) {
          l.push(s.slice(u, b)), u = b + i;
          continue;
        }
        if (p === "/") {
          f = b;
          continue;
        }
      }
      p === "[" ? c++ : p === "]" && c--;
    }
    const d = l.length === 0 ? s : s.substring(u), h = d.startsWith(YA), g = h ? d.substring(1) : d, v = f && f > u ? f - u : void 0;
    return {
      modifiers: l,
      hasImportantModifier: h,
      baseClassName: g,
      maybePostfixModifierPosition: v
    };
  };
  return n ? (s) => n({
    className: s,
    parseClassName: o
  }) : o;
}, IF = (e) => {
  if (e.length <= 1)
    return e;
  const t = [];
  let n = [];
  return e.forEach((r) => {
    r[0] === "[" ? (t.push(...n.sort(), r), n = []) : n.push(r);
  }), t.push(...n.sort()), t;
}, FF = (e) => ({
  cache: jF(e.cacheSize),
  parseClassName: PF(e),
  ...NF(e)
}), UF = /\s+/, qF = (e, t) => {
  const {
    parseClassName: n,
    getClassGroupId: r,
    getConflictingClassGroupIds: a
  } = t, i = [], o = e.trim().split(UF);
  let s = "";
  for (let l = o.length - 1; l >= 0; l -= 1) {
    const c = o[l], {
      modifiers: u,
      hasImportantModifier: f,
      baseClassName: d,
      maybePostfixModifierPosition: h
    } = n(c);
    let g = !!h, v = r(g ? d.substring(0, h) : d);
    if (!v) {
      if (!g) {
        s = c + (s.length > 0 ? " " + s : s);
        continue;
      }
      if (v = r(d), !v) {
        s = c + (s.length > 0 ? " " + s : s);
        continue;
      }
      g = !1;
    }
    const b = IF(u).join(":"), p = f ? b + YA : b, m = p + v;
    if (i.includes(m))
      continue;
    i.push(m);
    const w = a(v, g);
    for (let x = 0; x < w.length; ++x) {
      const S = w[x];
      i.push(p + S);
    }
    s = c + (s.length > 0 ? " " + s : s);
  }
  return s;
};
function BF() {
  let e = 0, t, n, r = "";
  for (; e < arguments.length; )
    (t = arguments[e++]) && (n = KA(t)) && (r && (r += " "), r += n);
  return r;
}
const KA = (e) => {
  if (typeof e == "string")
    return e;
  let t, n = "";
  for (let r = 0; r < e.length; r++)
    e[r] && (t = KA(e[r])) && (n && (n += " "), n += t);
  return n;
};
function $g(e, ...t) {
  let n, r, a, i = o;
  function o(l) {
    const c = t.reduce((u, f) => f(u), e());
    return n = FF(c), r = n.cache.get, a = n.cache.set, i = s, s(l);
  }
  function s(l) {
    const c = r(l);
    if (c)
      return c;
    const u = qF(l, n);
    return a(l, u), u;
  }
  return function() {
    return i(BF.apply(null, arguments));
  };
}
const Ge = (e) => {
  const t = (n) => n[e] || [];
  return t.isThemeGetter = !0, t;
}, XA = /^\[(?:([a-z-]+):)?(.+)\]$/i, VF = /^\d+\/\d+$/, QF = /* @__PURE__ */ new Set(["px", "full", "screen"]), HF = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, $F = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, GF = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/, YF = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, KF = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, _r = (e) => ls(e) || QF.has(e) || VF.test(e), la = (e) => rl(e, "length", r5), ls = (e) => !!e && !Number.isNaN(Number(e)), Mp = (e) => rl(e, "number", ls), Al = (e) => !!e && Number.isInteger(Number(e)), XF = (e) => e.endsWith("%") && ls(e.slice(0, -1)), ye = (e) => XA.test(e), ca = (e) => HF.test(e), WF = /* @__PURE__ */ new Set(["length", "size", "percentage"]), ZF = (e) => rl(e, WF, WA), JF = (e) => rl(e, "position", WA), e5 = /* @__PURE__ */ new Set(["image", "url"]), t5 = (e) => rl(e, e5, i5), n5 = (e) => rl(e, "", a5), Rl = () => !0, rl = (e, t, n) => {
  const r = XA.exec(e);
  return r ? r[1] ? typeof t == "string" ? r[1] === t : t.has(r[1]) : n(r[2]) : !1;
}, r5 = (e) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  $F.test(e) && !GF.test(e)
), WA = () => !1, a5 = (e) => YF.test(e), i5 = (e) => KF.test(e), Gg = () => {
  const e = Ge("colors"), t = Ge("spacing"), n = Ge("blur"), r = Ge("brightness"), a = Ge("borderColor"), i = Ge("borderRadius"), o = Ge("borderSpacing"), s = Ge("borderWidth"), l = Ge("contrast"), c = Ge("grayscale"), u = Ge("hueRotate"), f = Ge("invert"), d = Ge("gap"), h = Ge("gradientColorStops"), g = Ge("gradientColorStopPositions"), v = Ge("inset"), b = Ge("margin"), p = Ge("opacity"), m = Ge("padding"), w = Ge("saturate"), x = Ge("scale"), S = Ge("sepia"), T = Ge("skew"), E = Ge("space"), O = Ge("translate"), D = () => ["auto", "contain", "none"], A = () => ["auto", "hidden", "clip", "visible", "scroll"], U = () => ["auto", ye, t], R = () => [ye, t], q = () => ["", _r, la], z = () => ["auto", ls, ye], Q = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"], k = () => ["solid", "dashed", "dotted", "double", "none"], P = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], F = () => ["start", "end", "center", "between", "around", "evenly", "stretch"], H = () => ["", "0", ye], K = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], Z = () => [ls, ye];
  return {
    cacheSize: 500,
    separator: ":",
    theme: {
      colors: [Rl],
      spacing: [_r, la],
      blur: ["none", "", ca, ye],
      brightness: Z(),
      borderColor: [e],
      borderRadius: ["none", "", "full", ca, ye],
      borderSpacing: R(),
      borderWidth: q(),
      contrast: Z(),
      grayscale: H(),
      hueRotate: Z(),
      invert: H(),
      gap: R(),
      gradientColorStops: [e],
      gradientColorStopPositions: [XF, la],
      inset: U(),
      margin: U(),
      opacity: Z(),
      padding: R(),
      saturate: Z(),
      scale: Z(),
      sepia: H(),
      skew: Z(),
      space: R(),
      translate: R()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", ye]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [ca]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": K()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": K()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [...Q(), ye]
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: A()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": A()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": A()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: D()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": D()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": D()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [v]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [v]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [v]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [v]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [v]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [v]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [v]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [v]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [v]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", Al, ye]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: U()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", ye]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: H()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: H()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", Al, ye]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [Rl]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", Al, ye]
        }, ye]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": z()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": z()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [Rl]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [Al, ye]
        }, ye]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": z()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": z()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", ye]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", ye]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [d]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [d]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [d]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal", ...F()]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...F(), "baseline"]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [...F(), "baseline"]
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [m]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [m]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [m]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [m]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [m]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [m]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [m]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [m]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [m]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [b]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [b]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [b]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [b]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [b]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [b]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [b]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [b]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [b]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [E]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [E]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", ye, t]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [ye, t, "min", "max", "fit"]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [ye, t, "none", "full", "min", "max", "fit", "prose", {
          screen: [ca]
        }, ca]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [ye, t, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": [ye, t, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [ye, t, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Size
       * @see https://tailwindcss.com/docs/size
       */
      size: [{
        size: [ye, t, "auto", "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", ca, la]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", Mp]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [Rl]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractons"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", ye]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", ls, Mp]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", _r, ye]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", ye]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", ye]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [e]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [p]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [e]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [p]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...k(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", _r, la]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", _r, ye]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [e]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: R()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", ye]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", ye]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [p]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [...Q(), JF]
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", ZF]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, t5]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [e]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [g]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [g]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [g]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [h]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [h]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [h]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [i]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [i]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [i]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [i]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [i]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [i]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [i]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [i]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [i]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [i]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [i]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [i]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [i]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [i]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [i]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [s]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [s]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [s]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [s]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [s]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [s]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [s]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [s]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [s]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [p]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...k(), "hidden"]
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [s]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [s]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [p]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: k()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [a]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [a]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [a]
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": [a]
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": [a]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [a]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [a]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [a]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [a]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [a]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: ["", ...k()]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [_r, ye]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [_r, la]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [e]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: q()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [e]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [p]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [_r, la]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [e]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", ca, n5]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [Rl]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [p]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...P(), "plus-lighter", "plus-darker"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": P()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [n]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [r]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [l]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", ca, ye]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [c]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [u]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [f]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [w]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [S]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [n]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [r]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [l]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [c]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [u]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [f]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [p]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [w]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [S]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [o]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [o]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [o]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", ye]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: Z()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", ye]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: Z()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", ye]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [x]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [x]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [x]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [Al, ye]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [O]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [O]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [T]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [T]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", ye]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", e]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", ye]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [e]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": R()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": R()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": R()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": R()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": R()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": R()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": R()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": R()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": R()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": R()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": R()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": R()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": R()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": R()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": R()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": R()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": R()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": R()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", ye]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [e, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [_r, la, Mp]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [e, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
}, o5 = (e, {
  cacheSize: t,
  prefix: n,
  separator: r,
  experimentalParseClassName: a,
  extend: i = {},
  override: o = {}
}) => {
  Vl(e, "cacheSize", t), Vl(e, "prefix", n), Vl(e, "separator", r), Vl(e, "experimentalParseClassName", a);
  for (const s in o)
    s5(e[s], o[s]);
  for (const s in i)
    l5(e[s], i[s]);
  return e;
}, Vl = (e, t, n) => {
  n !== void 0 && (e[t] = n);
}, s5 = (e, t) => {
  if (t)
    for (const n in t)
      Vl(e, n, t[n]);
}, l5 = (e, t) => {
  if (t)
    for (const n in t) {
      const r = t[n];
      r !== void 0 && (e[n] = (e[n] || []).concat(r));
    }
}, c5 = (e, ...t) => typeof e == "function" ? $g(Gg, e, ...t) : $g(() => o5(Gg(), e), ...t), u5 = /* @__PURE__ */ $g(Gg);
var f5 = { twMerge: !0, twMergeConfig: {}, responsiveVariants: !1 }, ZA = (e) => e || void 0, zc = (...e) => ZA(QA(e).filter(Boolean).join(" ")), Lp = null, Mr = {}, Yg = !1, _l = (...e) => (t) => t.twMerge ? ((!Lp || Yg) && (Yg = !1, Lp = Zt(Mr) ? u5 : c5({ ...Mr, extend: { theme: Mr.theme, classGroups: Mr.classGroups, conflictingClassGroupModifiers: Mr.conflictingClassGroupModifiers, conflictingClassGroups: Mr.conflictingClassGroups, ...Mr.extend } })), ZA(Lp(zc(e)))) : zc(e), tE = (e, t) => {
  for (let n in t) e.hasOwnProperty(n) ? e[n] = zc(e[n], t[n]) : e[n] = t[n];
  return e;
}, du = (e, t) => {
  let { extend: n = null, slots: r = {}, variants: a = {}, compoundVariants: i = [], compoundSlots: o = [], defaultVariants: s = {} } = e, l = { ...f5, ...t }, c = n != null && n.base ? zc(n.base, e == null ? void 0 : e.base) : e == null ? void 0 : e.base, u = n != null && n.variants && !Zt(n.variants) ? $A(a, n.variants) : a, f = n != null && n.defaultVariants && !Zt(n.defaultVariants) ? { ...n.defaultVariants, ...s } : s;
  !Zt(l.twMergeConfig) && !DF(l.twMergeConfig, Mr) && (Yg = !0, Mr = l.twMergeConfig);
  let d = Zt(n == null ? void 0 : n.slots), h = Zt(r) ? {} : { base: zc(e == null ? void 0 : e.base, d && (n == null ? void 0 : n.base)), ...r }, g = d ? h : tE({ ...n == null ? void 0 : n.slots }, Zt(h) ? { base: e == null ? void 0 : e.base } : h), v = Zt(n == null ? void 0 : n.compoundVariants) ? i : HA(n == null ? void 0 : n.compoundVariants, i), b = (m) => {
    if (Zt(u) && Zt(r) && d) return _l(c, m == null ? void 0 : m.class, m == null ? void 0 : m.className)(l);
    if (v && !Array.isArray(v)) throw new TypeError(`The "compoundVariants" prop must be an array. Received: ${typeof v}`);
    if (o && !Array.isArray(o)) throw new TypeError(`The "compoundSlots" prop must be an array. Received: ${typeof o}`);
    let w = (R, q, z = [], Q) => {
      let k = z;
      if (typeof q == "string") k = k.concat(Zx(q).split(" ").map((P) => `${R}:${P}`));
      else if (Array.isArray(q)) k = k.concat(q.reduce((P, F) => P.concat(`${R}:${F}`), []));
      else if (typeof q == "object" && typeof Q == "string") {
        for (let P in q) if (q.hasOwnProperty(P) && P === Q) {
          let F = q[P];
          if (F && typeof F == "string") {
            let H = Zx(F);
            k[Q] ? k[Q] = k[Q].concat(H.split(" ").map((K) => `${R}:${K}`)) : k[Q] = H.split(" ").map((K) => `${R}:${K}`);
          } else Array.isArray(F) && F.length > 0 && (k[Q] = F.reduce((H, K) => H.concat(`${R}:${K}`), []));
        }
      }
      return k;
    }, x = (R, q = u, z = null, Q = null) => {
      var k;
      let P = q[R];
      if (!P || Zt(P)) return null;
      let F = (k = Q == null ? void 0 : Q[R]) != null ? k : m == null ? void 0 : m[R];
      if (F === null) return null;
      let H = Wx(F), K = Array.isArray(l.responsiveVariants) && l.responsiveVariants.length > 0 || l.responsiveVariants === !0, Z = f == null ? void 0 : f[R], I = [];
      if (typeof H == "object" && K) for (let [J, we] of Object.entries(H)) {
        let Se = P[we];
        if (J === "initial") {
          Z = we;
          continue;
        }
        Array.isArray(l.responsiveVariants) && !l.responsiveVariants.includes(J) || (I = w(J, Se, I, z));
      }
      let G = H != null && typeof H != "object" ? H : Wx(Z), ee = P[G || "false"];
      return typeof I == "object" && typeof z == "string" && I[z] ? tE(I, ee) : I.length > 0 ? (I.push(ee), z === "base" ? I.join(" ") : I) : ee;
    }, S = () => u ? Object.keys(u).map((R) => x(R, u)) : null, T = (R, q) => {
      if (!u || typeof u != "object") return null;
      let z = new Array();
      for (let Q in u) {
        let k = x(Q, u, R, q), P = R === "base" && typeof k == "string" ? k : k && k[R];
        P && (z[z.length] = P);
      }
      return z;
    }, E = {};
    for (let R in m) m[R] !== void 0 && (E[R] = m[R]);
    let O = (R, q) => {
      var z;
      let Q = typeof (m == null ? void 0 : m[R]) == "object" ? { [R]: (z = m[R]) == null ? void 0 : z.initial } : {};
      return { ...f, ...E, ...Q, ...q };
    }, D = (R = [], q) => {
      let z = [];
      for (let { class: Q, className: k, ...P } of R) {
        let F = !0;
        for (let [H, K] of Object.entries(P)) {
          let Z = O(H, q)[H];
          if (Array.isArray(K)) {
            if (!K.includes(Z)) {
              F = !1;
              break;
            }
          } else {
            let I = (G) => G == null || G === !1;
            if (I(K) && I(Z)) continue;
            if (Z !== K) {
              F = !1;
              break;
            }
          }
        }
        F && (Q && z.push(Q), k && z.push(k));
      }
      return z;
    }, A = (R) => {
      let q = D(v, R);
      if (!Array.isArray(q)) return q;
      let z = {};
      for (let Q of q) if (typeof Q == "string" && (z.base = _l(z.base, Q)(l)), typeof Q == "object") for (let [k, P] of Object.entries(Q)) z[k] = _l(z[k], P)(l);
      return z;
    }, U = (R) => {
      if (o.length < 1) return null;
      let q = {};
      for (let { slots: z = [], class: Q, className: k, ...P } of o) {
        if (!Zt(P)) {
          let F = !0;
          for (let H of Object.keys(P)) {
            let K = O(H, R)[H];
            if (K === void 0 || (Array.isArray(P[H]) ? !P[H].includes(K) : P[H] !== K)) {
              F = !1;
              break;
            }
          }
          if (!F) continue;
        }
        for (let F of z) q[F] = q[F] || [], q[F].push([Q, k]);
      }
      return q;
    };
    if (!Zt(r) || !d) {
      let R = {};
      if (typeof g == "object" && !Zt(g)) for (let q of Object.keys(g)) R[q] = (z) => {
        var Q, k;
        return _l(g[q], T(q, z), ((Q = A(z)) != null ? Q : [])[q], ((k = U(z)) != null ? k : [])[q], z == null ? void 0 : z.class, z == null ? void 0 : z.className)(l);
      };
      return R;
    }
    return _l(c, S(), D(v), m == null ? void 0 : m.class, m == null ? void 0 : m.className)(l);
  }, p = () => {
    if (!(!u || typeof u != "object")) return Object.keys(u);
  };
  return b.variantKeys = p(), b.extend = n, b.base = c, b.slots = g, b.variants = u, b.defaultVariants = f, b.compoundSlots = o, b.compoundVariants = v, b;
};
const d5 = du({
  base: [
    "transition-all duration-200 ease-in-out cursor-pointer",
    "hover:bg-neutral-2 rounded-lg"
  ]
}), lc = y.memo(
  ({
    size: e = "md",
    name: t,
    iconClassName: n,
    colorFill: r,
    ...a
  }) => {
    const i = y.useMemo(() => d5(), []);
    return /* @__PURE__ */ N.jsx(
      "button",
      {
        type: "button",
        "aria-label": a["aria-label"] ?? t,
        className: at(i, n),
        ...a,
        children: /* @__PURE__ */ N.jsx(
          Fs,
          {
            size: e,
            name: t,
            className: n,
            colorFill: r,
            "aria-hidden": "true"
          }
        )
      }
    );
  }
);
lc.displayName = "ButtonIcon";
const h5 = du({
  base: "flex items-center justify-center",
  variants: {
    size: {
      xxs: "icon-xxs",
      xs: "icon-xs",
      sm: "icon-sm",
      md: "icon-md",
      lg: "icon-lg",
      xl: "icon-xl"
    }
  },
  defaultVariants: {
    size: "sm"
  }
}), Fs = cn.memo(
  ({
    name: e,
    size: t = "sm",
    colorFill: n = "fill-current",
    className: r,
    "aria-hidden": a = !1,
    "aria-label": i,
    title: o,
    ...s
  }) => {
    if (!e)
      return null;
    const l = a || !i, c = l ? void 0 : `${e}-title`, u = i ?? `cone ${e.replace(/-/g, " ")}`, f = o ?? u, d = h5({ size: t }), [h, g] = y.useState(`icons.sprite.svg#${e}`);
    return y.useEffect(() => {
      if (typeof document < "u") {
        const v = () => {
          const p = document.querySelectorAll(
            "pas-assistant-embedded"
          );
          for (const m of p)
            if (m.shadowRoot && m.shadowRoot.getElementById(
              "icon-sprite-container"
            )) {
              g(`#${e}`);
              return;
            }
        };
        v();
        const b = setTimeout(v, 100);
        return () => clearTimeout(b);
      }
    }, [e]), /* @__PURE__ */ N.jsxs(
      "svg",
      {
        className: at(d, n, r),
        role: l ? "presentation" : "img",
        "aria-labelledby": l ? void 0 : c,
        "aria-hidden": l ? !0 : void 0,
        focusable: l ? !1 : void 0,
        ...s,
        children: [
          !l && /* @__PURE__ */ N.jsx("title", { id: c, children: f }),
          /* @__PURE__ */ N.jsx("use", { href: h })
        ]
      }
    );
  }
);
Fs.displayName = "Icon";
var Qt = /* @__PURE__ */ ((e) => (e.Dots = "dots", e.Spinner = "spinner", e))(Qt || {}), tn = /* @__PURE__ */ ((e) => (e.Small = "small", e.Medium = "medium", e.Large = "large", e))(tn || {});
const p5 = Qt.Dots, m5 = tn.Medium, zp = 2e3, g5 = 1500, v5 = 3e3, y5 = du({
  slots: {
    container: "inline-flex items-center justify-start",
    element: ""
  },
  variants: {
    variant: {
      [Qt.Dots]: {
        container: "inline-flex rounded-full animate-pulse",
        element: "bg-list-active rounded-full animate-pulse"
      },
      [Qt.Spinner]: {
        container: "inline-flex items-center justify-center",
        element: "rounded-full inline-block box-border"
      }
    },
    size: {
      [tn.Small]: {},
      [tn.Medium]: {},
      [tn.Large]: {}
    }
  },
  compoundVariants: [
    {
      variant: Qt.Dots,
      size: tn.Small,
      class: {
        container: "gap-0.5",
        element: "h-1 w-1"
      }
    },
    {
      variant: Qt.Dots,
      size: tn.Medium,
      class: {
        container: "gap-1",
        element: "h-1.5 w-1.5"
      }
    },
    {
      variant: Qt.Dots,
      size: tn.Large,
      class: {
        container: "gap-1.5",
        element: "h-2.5 w-2.5"
      }
    },
    {
      variant: Qt.Spinner,
      size: tn.Small,
      class: {
        element: "!h-2-5 !w-2-5"
      }
    },
    {
      variant: Qt.Spinner,
      size: tn.Medium,
      class: {
        element: ""
      }
    },
    {
      variant: Qt.Spinner,
      size: tn.Large,
      class: {
        element: "!h-6 !w-6"
      }
    }
  ],
  defaultVariants: {
    variant: Qt.Dots,
    size: tn.Medium
  }
}), ab = ({
  isLoading: e,
  variant: t = p5,
  size: n = m5,
  className: r,
  ...a
}) => {
  if (!e)
    return null;
  const { container: i, element: o } = y5({ variant: t, size: n });
  return t === Qt.Dots ? /* @__PURE__ */ N.jsxs(
    "div",
    {
      className: at(i(), r),
      "data-testid": "loader-dots-container",
      ...a,
      children: [
        /* @__PURE__ */ N.jsx(
          "div",
          {
            className: at(
              o(),
              "loader-dot",
              `duration-${zp}`
            ),
            "data-testid": "loader-dot-1"
          }
        ),
        /* @__PURE__ */ N.jsx(
          "div",
          {
            className: at(
              o(),
              "loader-dot",
              `duration-${zp} delay-${g5}`
            ),
            "data-testid": "loader-dot-2"
          }
        ),
        /* @__PURE__ */ N.jsx(
          "div",
          {
            className: at(
              o(),
              "loader-dot",
              `duration-${zp} delay-${v5}`
            ),
            "data-testid": "loader-dot-3"
          }
        )
      ]
    }
  ) : t === Qt.Spinner ? /* @__PURE__ */ N.jsx(
    "div",
    {
      className: at(i(), r),
      "data-testid": "loader-spinner-container",
      ...a,
      children: /* @__PURE__ */ N.jsx(
        "div",
        {
          className: at(o(), "loader-spinner"),
          "data-testid": "loader-spinner"
        }
      )
    }
  ) : null;
};
ab.displayName = "Loader";
function Ze(e, t, { checkForDefaultPrevented: n = !0 } = {}) {
  return function(a) {
    if (e == null || e(a), n === !1 || !a.defaultPrevented)
      return t == null ? void 0 : t(a);
  };
}
function nE(e, t) {
  if (typeof e == "function")
    return e(t);
  e != null && (e.current = t);
}
function ai(...e) {
  return (t) => {
    let n = !1;
    const r = e.map((a) => {
      const i = nE(a, t);
      return !n && typeof i == "function" && (n = !0), i;
    });
    if (n)
      return () => {
        for (let a = 0; a < r.length; a++) {
          const i = r[a];
          typeof i == "function" ? i() : nE(e[a], null);
        }
      };
  };
}
function Yt(...e) {
  return y.useCallback(ai(...e), e);
}
function b5(e, t) {
  const n = y.createContext(t), r = (i) => {
    const { children: o, ...s } = i, l = y.useMemo(() => s, Object.values(s));
    return /* @__PURE__ */ N.jsx(n.Provider, { value: l, children: o });
  };
  r.displayName = e + "Provider";
  function a(i) {
    const o = y.useContext(n);
    if (o) return o;
    if (t !== void 0) return t;
    throw new Error(`\`${i}\` must be used within \`${e}\``);
  }
  return [r, a];
}
function hu(e, t = []) {
  let n = [];
  function r(i, o) {
    const s = y.createContext(o), l = n.length;
    n = [...n, o];
    const c = (f) => {
      var p;
      const { scope: d, children: h, ...g } = f, v = ((p = d == null ? void 0 : d[e]) == null ? void 0 : p[l]) || s, b = y.useMemo(() => g, Object.values(g));
      return /* @__PURE__ */ N.jsx(v.Provider, { value: b, children: h });
    };
    c.displayName = i + "Provider";
    function u(f, d) {
      var v;
      const h = ((v = d == null ? void 0 : d[e]) == null ? void 0 : v[l]) || s, g = y.useContext(h);
      if (g) return g;
      if (o !== void 0) return o;
      throw new Error(`\`${f}\` must be used within \`${i}\``);
    }
    return [c, u];
  }
  const a = () => {
    const i = n.map((o) => y.createContext(o));
    return function(s) {
      const l = (s == null ? void 0 : s[e]) || i;
      return y.useMemo(
        () => ({ [`__scope${e}`]: { ...s, [e]: l } }),
        [s, l]
      );
    };
  };
  return a.scopeName = e, [r, w5(a, ...t)];
}
function w5(...e) {
  const t = e[0];
  if (e.length === 1) return t;
  const n = () => {
    const r = e.map((a) => ({
      useScope: a(),
      scopeName: a.scopeName
    }));
    return function(i) {
      const o = r.reduce((s, { useScope: l, scopeName: c }) => {
        const f = l(i)[`__scope${c}`];
        return { ...s, ...f };
      }, {});
      return y.useMemo(() => ({ [`__scope${t.scopeName}`]: o }), [o]);
    };
  };
  return n.scopeName = t.scopeName, n;
}
// @__NO_SIDE_EFFECTS__
function jc(e) {
  const t = /* @__PURE__ */ x5(e), n = y.forwardRef((r, a) => {
    const { children: i, ...o } = r, s = y.Children.toArray(i), l = s.find(S5);
    if (l) {
      const c = l.props.children, u = s.map((f) => f === l ? y.Children.count(c) > 1 ? y.Children.only(null) : y.isValidElement(c) ? c.props.children : null : f);
      return /* @__PURE__ */ N.jsx(t, { ...o, ref: a, children: y.isValidElement(c) ? y.cloneElement(c, void 0, u) : null });
    }
    return /* @__PURE__ */ N.jsx(t, { ...o, ref: a, children: i });
  });
  return n.displayName = `${e}.Slot`, n;
}
// @__NO_SIDE_EFFECTS__
function x5(e) {
  const t = y.forwardRef((n, r) => {
    const { children: a, ...i } = n;
    if (y.isValidElement(a)) {
      const o = C5(a), s = T5(i, a.props);
      return a.type !== y.Fragment && (s.ref = r ? ai(r, o) : o), y.cloneElement(a, s);
    }
    return y.Children.count(a) > 1 ? y.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var E5 = Symbol("radix.slottable");
function S5(e) {
  return y.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === E5;
}
function T5(e, t) {
  const n = { ...t };
  for (const r in t) {
    const a = e[r], i = t[r];
    /^on[A-Z]/.test(r) ? a && i ? n[r] = (...s) => {
      const l = i(...s);
      return a(...s), l;
    } : a && (n[r] = a) : r === "style" ? n[r] = { ...a, ...i } : r === "className" && (n[r] = [a, i].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function C5(e) {
  var r, a;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (a = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : a.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var O5 = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
], ut = O5.reduce((e, t) => {
  const n = /* @__PURE__ */ jc(`Primitive.${t}`), r = y.forwardRef((a, i) => {
    const { asChild: o, ...s } = a, l = o ? n : t;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ N.jsx(l, { ...s, ref: i });
  });
  return r.displayName = `Primitive.${t}`, { ...e, [t]: r };
}, {});
function JA(e, t) {
  e && Gc.flushSync(() => e.dispatchEvent(t));
}
function fr(e) {
  const t = y.useRef(e);
  return y.useEffect(() => {
    t.current = e;
  }), y.useMemo(() => (...n) => {
    var r;
    return (r = t.current) == null ? void 0 : r.call(t, ...n);
  }, []);
}
function A5(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = fr(e);
  y.useEffect(() => {
    const r = (a) => {
      a.key === "Escape" && n(a);
    };
    return t.addEventListener("keydown", r, { capture: !0 }), () => t.removeEventListener("keydown", r, { capture: !0 });
  }, [n, t]);
}
var R5 = "DismissableLayer", Kg = "dismissableLayer.update", _5 = "dismissableLayer.pointerDownOutside", D5 = "dismissableLayer.focusOutside", rE, eR = y.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), lh = y.forwardRef(
  (e, t) => {
    const {
      disableOutsidePointerEvents: n = !1,
      onEscapeKeyDown: r,
      onPointerDownOutside: a,
      onFocusOutside: i,
      onInteractOutside: o,
      onDismiss: s,
      ...l
    } = e, c = y.useContext(eR), [u, f] = y.useState(null), d = (u == null ? void 0 : u.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), [, h] = y.useState({}), g = Yt(t, (E) => f(E)), v = Array.from(c.layers), [b] = [...c.layersWithOutsidePointerEventsDisabled].slice(-1), p = v.indexOf(b), m = u ? v.indexOf(u) : -1, w = c.layersWithOutsidePointerEventsDisabled.size > 0, x = m >= p, S = k5((E) => {
      const O = E.target, D = [...c.branches].some((A) => A.contains(O));
      !x || D || (a == null || a(E), o == null || o(E), E.defaultPrevented || s == null || s());
    }, d), T = M5((E) => {
      const O = E.target;
      [...c.branches].some((A) => A.contains(O)) || (i == null || i(E), o == null || o(E), E.defaultPrevented || s == null || s());
    }, d);
    return A5((E) => {
      m === c.layers.size - 1 && (r == null || r(E), !E.defaultPrevented && s && (E.preventDefault(), s()));
    }, d), y.useEffect(() => {
      if (u)
        return n && (c.layersWithOutsidePointerEventsDisabled.size === 0 && (rE = d.body.style.pointerEvents, d.body.style.pointerEvents = "none"), c.layersWithOutsidePointerEventsDisabled.add(u)), c.layers.add(u), aE(), () => {
          n && c.layersWithOutsidePointerEventsDisabled.size === 1 && (d.body.style.pointerEvents = rE);
        };
    }, [u, d, n, c]), y.useEffect(() => () => {
      u && (c.layers.delete(u), c.layersWithOutsidePointerEventsDisabled.delete(u), aE());
    }, [u, c]), y.useEffect(() => {
      const E = () => h({});
      return document.addEventListener(Kg, E), () => document.removeEventListener(Kg, E);
    }, []), /* @__PURE__ */ N.jsx(
      ut.div,
      {
        ...l,
        ref: g,
        style: {
          pointerEvents: w ? x ? "auto" : "none" : void 0,
          ...e.style
        },
        onFocusCapture: Ze(e.onFocusCapture, T.onFocusCapture),
        onBlurCapture: Ze(e.onBlurCapture, T.onBlurCapture),
        onPointerDownCapture: Ze(
          e.onPointerDownCapture,
          S.onPointerDownCapture
        )
      }
    );
  }
);
lh.displayName = R5;
var N5 = "DismissableLayerBranch", tR = y.forwardRef((e, t) => {
  const n = y.useContext(eR), r = y.useRef(null), a = Yt(t, r);
  return y.useEffect(() => {
    const i = r.current;
    if (i)
      return n.branches.add(i), () => {
        n.branches.delete(i);
      };
  }, [n.branches]), /* @__PURE__ */ N.jsx(ut.div, { ...e, ref: a });
});
tR.displayName = N5;
function k5(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = fr(e), r = y.useRef(!1), a = y.useRef(() => {
  });
  return y.useEffect(() => {
    const i = (s) => {
      if (s.target && !r.current) {
        let l = function() {
          nR(
            _5,
            n,
            c,
            { discrete: !0 }
          );
        };
        const c = { originalEvent: s };
        s.pointerType === "touch" ? (t.removeEventListener("click", a.current), a.current = l, t.addEventListener("click", a.current, { once: !0 })) : l();
      } else
        t.removeEventListener("click", a.current);
      r.current = !1;
    }, o = window.setTimeout(() => {
      t.addEventListener("pointerdown", i);
    }, 0);
    return () => {
      window.clearTimeout(o), t.removeEventListener("pointerdown", i), t.removeEventListener("click", a.current);
    };
  }, [t, n]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => r.current = !0
  };
}
function M5(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = fr(e), r = y.useRef(!1);
  return y.useEffect(() => {
    const a = (i) => {
      i.target && !r.current && nR(D5, n, { originalEvent: i }, {
        discrete: !1
      });
    };
    return t.addEventListener("focusin", a), () => t.removeEventListener("focusin", a);
  }, [t, n]), {
    onFocusCapture: () => r.current = !0,
    onBlurCapture: () => r.current = !1
  };
}
function aE() {
  const e = new CustomEvent(Kg);
  document.dispatchEvent(e);
}
function nR(e, t, n, { discrete: r }) {
  const a = n.originalEvent.target, i = new CustomEvent(e, { bubbles: !1, cancelable: !0, detail: n });
  t && a.addEventListener(e, t, { once: !0 }), r ? JA(a, i) : a.dispatchEvent(i);
}
var L5 = lh, z5 = tR, jp = 0;
function rR() {
  y.useEffect(() => {
    const e = document.querySelectorAll("[data-radix-focus-guard]");
    return document.body.insertAdjacentElement("afterbegin", e[0] ?? iE()), document.body.insertAdjacentElement("beforeend", e[1] ?? iE()), jp++, () => {
      jp === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((t) => t.remove()), jp--;
    };
  }, []);
}
function iE() {
  const e = document.createElement("span");
  return e.setAttribute("data-radix-focus-guard", ""), e.tabIndex = 0, e.style.outline = "none", e.style.opacity = "0", e.style.position = "fixed", e.style.pointerEvents = "none", e;
}
var Pp = "focusScope.autoFocusOnMount", Ip = "focusScope.autoFocusOnUnmount", oE = { bubbles: !1, cancelable: !0 }, j5 = "FocusScope", ib = y.forwardRef((e, t) => {
  const {
    loop: n = !1,
    trapped: r = !1,
    onMountAutoFocus: a,
    onUnmountAutoFocus: i,
    ...o
  } = e, [s, l] = y.useState(null), c = fr(a), u = fr(i), f = y.useRef(null), d = Yt(t, (v) => l(v)), h = y.useRef({
    paused: !1,
    pause() {
      this.paused = !0;
    },
    resume() {
      this.paused = !1;
    }
  }).current;
  y.useEffect(() => {
    if (r) {
      let v = function(w) {
        if (h.paused || !s) return;
        const x = w.target;
        s.contains(x) ? f.current = x : da(f.current, { select: !0 });
      }, b = function(w) {
        if (h.paused || !s) return;
        const x = w.relatedTarget;
        x !== null && (s.contains(x) || da(f.current, { select: !0 }));
      }, p = function(w) {
        if (document.activeElement === document.body)
          for (const S of w)
            S.removedNodes.length > 0 && da(s);
      };
      document.addEventListener("focusin", v), document.addEventListener("focusout", b);
      const m = new MutationObserver(p);
      return s && m.observe(s, { childList: !0, subtree: !0 }), () => {
        document.removeEventListener("focusin", v), document.removeEventListener("focusout", b), m.disconnect();
      };
    }
  }, [r, s, h.paused]), y.useEffect(() => {
    if (s) {
      lE.add(h);
      const v = document.activeElement;
      if (!s.contains(v)) {
        const p = new CustomEvent(Pp, oE);
        s.addEventListener(Pp, c), s.dispatchEvent(p), p.defaultPrevented || (P5(B5(aR(s)), { select: !0 }), document.activeElement === v && da(s));
      }
      return () => {
        s.removeEventListener(Pp, c), setTimeout(() => {
          const p = new CustomEvent(Ip, oE);
          s.addEventListener(Ip, u), s.dispatchEvent(p), p.defaultPrevented || da(v ?? document.body, { select: !0 }), s.removeEventListener(Ip, u), lE.remove(h);
        }, 0);
      };
    }
  }, [s, c, u, h]);
  const g = y.useCallback(
    (v) => {
      if (!n && !r || h.paused) return;
      const b = v.key === "Tab" && !v.altKey && !v.ctrlKey && !v.metaKey, p = document.activeElement;
      if (b && p) {
        const m = v.currentTarget, [w, x] = I5(m);
        w && x ? !v.shiftKey && p === x ? (v.preventDefault(), n && da(w, { select: !0 })) : v.shiftKey && p === w && (v.preventDefault(), n && da(x, { select: !0 })) : p === m && v.preventDefault();
      }
    },
    [n, r, h.paused]
  );
  return /* @__PURE__ */ N.jsx(ut.div, { tabIndex: -1, ...o, ref: d, onKeyDown: g });
});
ib.displayName = j5;
function P5(e, { select: t = !1 } = {}) {
  const n = document.activeElement;
  for (const r of e)
    if (da(r, { select: t }), document.activeElement !== n) return;
}
function I5(e) {
  const t = aR(e), n = sE(t, e), r = sE(t.reverse(), e);
  return [n, r];
}
function aR(e) {
  const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (r) => {
      const a = r.tagName === "INPUT" && r.type === "hidden";
      return r.disabled || r.hidden || a ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n.nextNode(); ) t.push(n.currentNode);
  return t;
}
function sE(e, t) {
  for (const n of e)
    if (!F5(n, { upTo: t })) return n;
}
function F5(e, { upTo: t }) {
  if (getComputedStyle(e).visibility === "hidden") return !0;
  for (; e; ) {
    if (t !== void 0 && e === t) return !1;
    if (getComputedStyle(e).display === "none") return !0;
    e = e.parentElement;
  }
  return !1;
}
function U5(e) {
  return e instanceof HTMLInputElement && "select" in e;
}
function da(e, { select: t = !1 } = {}) {
  if (e && e.focus) {
    const n = document.activeElement;
    e.focus({ preventScroll: !0 }), e !== n && U5(e) && t && e.select();
  }
}
var lE = q5();
function q5() {
  let e = [];
  return {
    add(t) {
      const n = e[0];
      t !== n && (n == null || n.pause()), e = cE(e, t), e.unshift(t);
    },
    remove(t) {
      var n;
      e = cE(e, t), (n = e[0]) == null || n.resume();
    }
  };
}
function cE(e, t) {
  const n = [...e], r = n.indexOf(t);
  return r !== -1 && n.splice(r, 1), n;
}
function B5(e) {
  return e.filter((t) => t.tagName !== "A");
}
var Wr = globalThis != null && globalThis.document ? y.useLayoutEffect : () => {
}, V5 = wv[" useId ".trim().toString()] || (() => {
}), Q5 = 0;
function sr(e) {
  const [t, n] = y.useState(V5());
  return Wr(() => {
    n((r) => r ?? String(Q5++));
  }, [e]), e || (t ? `radix-${t}` : "");
}
const H5 = ["top", "right", "bottom", "left"], ii = Math.min, dn = Math.max, yd = Math.round, Wu = Math.floor, lr = (e) => ({
  x: e,
  y: e
}), $5 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, G5 = {
  start: "end",
  end: "start"
};
function Xg(e, t, n) {
  return dn(e, ii(t, n));
}
function Zr(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function Jr(e) {
  return e.split("-")[0];
}
function al(e) {
  return e.split("-")[1];
}
function ob(e) {
  return e === "x" ? "y" : "x";
}
function sb(e) {
  return e === "y" ? "height" : "width";
}
const Y5 = /* @__PURE__ */ new Set(["top", "bottom"]);
function rr(e) {
  return Y5.has(Jr(e)) ? "y" : "x";
}
function lb(e) {
  return ob(rr(e));
}
function K5(e, t, n) {
  n === void 0 && (n = !1);
  const r = al(e), a = lb(e), i = sb(a);
  let o = a === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
  return t.reference[i] > t.floating[i] && (o = bd(o)), [o, bd(o)];
}
function X5(e) {
  const t = bd(e);
  return [Wg(e), t, Wg(t)];
}
function Wg(e) {
  return e.replace(/start|end/g, (t) => G5[t]);
}
const uE = ["left", "right"], fE = ["right", "left"], W5 = ["top", "bottom"], Z5 = ["bottom", "top"];
function J5(e, t, n) {
  switch (e) {
    case "top":
    case "bottom":
      return n ? t ? fE : uE : t ? uE : fE;
    case "left":
    case "right":
      return t ? W5 : Z5;
    default:
      return [];
  }
}
function e3(e, t, n, r) {
  const a = al(e);
  let i = J5(Jr(e), n === "start", r);
  return a && (i = i.map((o) => o + "-" + a), t && (i = i.concat(i.map(Wg)))), i;
}
function bd(e) {
  return e.replace(/left|right|bottom|top/g, (t) => $5[t]);
}
function t3(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
function iR(e) {
  return typeof e != "number" ? t3(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function wd(e) {
  const {
    x: t,
    y: n,
    width: r,
    height: a
  } = e;
  return {
    width: r,
    height: a,
    top: n,
    left: t,
    right: t + r,
    bottom: n + a,
    x: t,
    y: n
  };
}
function dE(e, t, n) {
  let {
    reference: r,
    floating: a
  } = e;
  const i = rr(t), o = lb(t), s = sb(o), l = Jr(t), c = i === "y", u = r.x + r.width / 2 - a.width / 2, f = r.y + r.height / 2 - a.height / 2, d = r[s] / 2 - a[s] / 2;
  let h;
  switch (l) {
    case "top":
      h = {
        x: u,
        y: r.y - a.height
      };
      break;
    case "bottom":
      h = {
        x: u,
        y: r.y + r.height
      };
      break;
    case "right":
      h = {
        x: r.x + r.width,
        y: f
      };
      break;
    case "left":
      h = {
        x: r.x - a.width,
        y: f
      };
      break;
    default:
      h = {
        x: r.x,
        y: r.y
      };
  }
  switch (al(t)) {
    case "start":
      h[o] -= d * (n && c ? -1 : 1);
      break;
    case "end":
      h[o] += d * (n && c ? -1 : 1);
      break;
  }
  return h;
}
const n3 = async (e, t, n) => {
  const {
    placement: r = "bottom",
    strategy: a = "absolute",
    middleware: i = [],
    platform: o
  } = n, s = i.filter(Boolean), l = await (o.isRTL == null ? void 0 : o.isRTL(t));
  let c = await o.getElementRects({
    reference: e,
    floating: t,
    strategy: a
  }), {
    x: u,
    y: f
  } = dE(c, r, l), d = r, h = {}, g = 0;
  for (let v = 0; v < s.length; v++) {
    const {
      name: b,
      fn: p
    } = s[v], {
      x: m,
      y: w,
      data: x,
      reset: S
    } = await p({
      x: u,
      y: f,
      initialPlacement: r,
      placement: d,
      strategy: a,
      middlewareData: h,
      rects: c,
      platform: o,
      elements: {
        reference: e,
        floating: t
      }
    });
    u = m ?? u, f = w ?? f, h = {
      ...h,
      [b]: {
        ...h[b],
        ...x
      }
    }, S && g <= 50 && (g++, typeof S == "object" && (S.placement && (d = S.placement), S.rects && (c = S.rects === !0 ? await o.getElementRects({
      reference: e,
      floating: t,
      strategy: a
    }) : S.rects), {
      x: u,
      y: f
    } = dE(c, d, l)), v = -1);
  }
  return {
    x: u,
    y: f,
    placement: d,
    strategy: a,
    middlewareData: h
  };
};
async function Pc(e, t) {
  var n;
  t === void 0 && (t = {});
  const {
    x: r,
    y: a,
    platform: i,
    rects: o,
    elements: s,
    strategy: l
  } = e, {
    boundary: c = "clippingAncestors",
    rootBoundary: u = "viewport",
    elementContext: f = "floating",
    altBoundary: d = !1,
    padding: h = 0
  } = Zr(t, e), g = iR(h), b = s[d ? f === "floating" ? "reference" : "floating" : f], p = wd(await i.getClippingRect({
    element: (n = await (i.isElement == null ? void 0 : i.isElement(b))) == null || n ? b : b.contextElement || await (i.getDocumentElement == null ? void 0 : i.getDocumentElement(s.floating)),
    boundary: c,
    rootBoundary: u,
    strategy: l
  })), m = f === "floating" ? {
    x: r,
    y: a,
    width: o.floating.width,
    height: o.floating.height
  } : o.reference, w = await (i.getOffsetParent == null ? void 0 : i.getOffsetParent(s.floating)), x = await (i.isElement == null ? void 0 : i.isElement(w)) ? await (i.getScale == null ? void 0 : i.getScale(w)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, S = wd(i.convertOffsetParentRelativeRectToViewportRelativeRect ? await i.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: s,
    rect: m,
    offsetParent: w,
    strategy: l
  }) : m);
  return {
    top: (p.top - S.top + g.top) / x.y,
    bottom: (S.bottom - p.bottom + g.bottom) / x.y,
    left: (p.left - S.left + g.left) / x.x,
    right: (S.right - p.right + g.right) / x.x
  };
}
const r3 = (e) => ({
  name: "arrow",
  options: e,
  async fn(t) {
    const {
      x: n,
      y: r,
      placement: a,
      rects: i,
      platform: o,
      elements: s,
      middlewareData: l
    } = t, {
      element: c,
      padding: u = 0
    } = Zr(e, t) || {};
    if (c == null)
      return {};
    const f = iR(u), d = {
      x: n,
      y: r
    }, h = lb(a), g = sb(h), v = await o.getDimensions(c), b = h === "y", p = b ? "top" : "left", m = b ? "bottom" : "right", w = b ? "clientHeight" : "clientWidth", x = i.reference[g] + i.reference[h] - d[h] - i.floating[g], S = d[h] - i.reference[h], T = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(c));
    let E = T ? T[w] : 0;
    (!E || !await (o.isElement == null ? void 0 : o.isElement(T))) && (E = s.floating[w] || i.floating[g]);
    const O = x / 2 - S / 2, D = E / 2 - v[g] / 2 - 1, A = ii(f[p], D), U = ii(f[m], D), R = A, q = E - v[g] - U, z = E / 2 - v[g] / 2 + O, Q = Xg(R, z, q), k = !l.arrow && al(a) != null && z !== Q && i.reference[g] / 2 - (z < R ? A : U) - v[g] / 2 < 0, P = k ? z < R ? z - R : z - q : 0;
    return {
      [h]: d[h] + P,
      data: {
        [h]: Q,
        centerOffset: z - Q - P,
        ...k && {
          alignmentOffset: P
        }
      },
      reset: k
    };
  }
}), a3 = function(e) {
  return e === void 0 && (e = {}), {
    name: "flip",
    options: e,
    async fn(t) {
      var n, r;
      const {
        placement: a,
        middlewareData: i,
        rects: o,
        initialPlacement: s,
        platform: l,
        elements: c
      } = t, {
        mainAxis: u = !0,
        crossAxis: f = !0,
        fallbackPlacements: d,
        fallbackStrategy: h = "bestFit",
        fallbackAxisSideDirection: g = "none",
        flipAlignment: v = !0,
        ...b
      } = Zr(e, t);
      if ((n = i.arrow) != null && n.alignmentOffset)
        return {};
      const p = Jr(a), m = rr(s), w = Jr(s) === s, x = await (l.isRTL == null ? void 0 : l.isRTL(c.floating)), S = d || (w || !v ? [bd(s)] : X5(s)), T = g !== "none";
      !d && T && S.push(...e3(s, v, g, x));
      const E = [s, ...S], O = await Pc(t, b), D = [];
      let A = ((r = i.flip) == null ? void 0 : r.overflows) || [];
      if (u && D.push(O[p]), f) {
        const z = K5(a, o, x);
        D.push(O[z[0]], O[z[1]]);
      }
      if (A = [...A, {
        placement: a,
        overflows: D
      }], !D.every((z) => z <= 0)) {
        var U, R;
        const z = (((U = i.flip) == null ? void 0 : U.index) || 0) + 1, Q = E[z];
        if (Q && (!(f === "alignment" ? m !== rr(Q) : !1) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        A.every((F) => rr(F.placement) === m ? F.overflows[0] > 0 : !0)))
          return {
            data: {
              index: z,
              overflows: A
            },
            reset: {
              placement: Q
            }
          };
        let k = (R = A.filter((P) => P.overflows[0] <= 0).sort((P, F) => P.overflows[1] - F.overflows[1])[0]) == null ? void 0 : R.placement;
        if (!k)
          switch (h) {
            case "bestFit": {
              var q;
              const P = (q = A.filter((F) => {
                if (T) {
                  const H = rr(F.placement);
                  return H === m || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  H === "y";
                }
                return !0;
              }).map((F) => [F.placement, F.overflows.filter((H) => H > 0).reduce((H, K) => H + K, 0)]).sort((F, H) => F[1] - H[1])[0]) == null ? void 0 : q[0];
              P && (k = P);
              break;
            }
            case "initialPlacement":
              k = s;
              break;
          }
        if (a !== k)
          return {
            reset: {
              placement: k
            }
          };
      }
      return {};
    }
  };
};
function hE(e, t) {
  return {
    top: e.top - t.height,
    right: e.right - t.width,
    bottom: e.bottom - t.height,
    left: e.left - t.width
  };
}
function pE(e) {
  return H5.some((t) => e[t] >= 0);
}
const i3 = function(e) {
  return e === void 0 && (e = {}), {
    name: "hide",
    options: e,
    async fn(t) {
      const {
        rects: n
      } = t, {
        strategy: r = "referenceHidden",
        ...a
      } = Zr(e, t);
      switch (r) {
        case "referenceHidden": {
          const i = await Pc(t, {
            ...a,
            elementContext: "reference"
          }), o = hE(i, n.reference);
          return {
            data: {
              referenceHiddenOffsets: o,
              referenceHidden: pE(o)
            }
          };
        }
        case "escaped": {
          const i = await Pc(t, {
            ...a,
            altBoundary: !0
          }), o = hE(i, n.floating);
          return {
            data: {
              escapedOffsets: o,
              escaped: pE(o)
            }
          };
        }
        default:
          return {};
      }
    }
  };
}, oR = /* @__PURE__ */ new Set(["left", "top"]);
async function o3(e, t) {
  const {
    placement: n,
    platform: r,
    elements: a
  } = e, i = await (r.isRTL == null ? void 0 : r.isRTL(a.floating)), o = Jr(n), s = al(n), l = rr(n) === "y", c = oR.has(o) ? -1 : 1, u = i && l ? -1 : 1, f = Zr(t, e);
  let {
    mainAxis: d,
    crossAxis: h,
    alignmentAxis: g
  } = typeof f == "number" ? {
    mainAxis: f,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: f.mainAxis || 0,
    crossAxis: f.crossAxis || 0,
    alignmentAxis: f.alignmentAxis
  };
  return s && typeof g == "number" && (h = s === "end" ? g * -1 : g), l ? {
    x: h * u,
    y: d * c
  } : {
    x: d * c,
    y: h * u
  };
}
const s3 = function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(t) {
      var n, r;
      const {
        x: a,
        y: i,
        placement: o,
        middlewareData: s
      } = t, l = await o3(t, e);
      return o === ((n = s.offset) == null ? void 0 : n.placement) && (r = s.arrow) != null && r.alignmentOffset ? {} : {
        x: a + l.x,
        y: i + l.y,
        data: {
          ...l,
          placement: o
        }
      };
    }
  };
}, l3 = function(e) {
  return e === void 0 && (e = {}), {
    name: "shift",
    options: e,
    async fn(t) {
      const {
        x: n,
        y: r,
        placement: a
      } = t, {
        mainAxis: i = !0,
        crossAxis: o = !1,
        limiter: s = {
          fn: (b) => {
            let {
              x: p,
              y: m
            } = b;
            return {
              x: p,
              y: m
            };
          }
        },
        ...l
      } = Zr(e, t), c = {
        x: n,
        y: r
      }, u = await Pc(t, l), f = rr(Jr(a)), d = ob(f);
      let h = c[d], g = c[f];
      if (i) {
        const b = d === "y" ? "top" : "left", p = d === "y" ? "bottom" : "right", m = h + u[b], w = h - u[p];
        h = Xg(m, h, w);
      }
      if (o) {
        const b = f === "y" ? "top" : "left", p = f === "y" ? "bottom" : "right", m = g + u[b], w = g - u[p];
        g = Xg(m, g, w);
      }
      const v = s.fn({
        ...t,
        [d]: h,
        [f]: g
      });
      return {
        ...v,
        data: {
          x: v.x - n,
          y: v.y - r,
          enabled: {
            [d]: i,
            [f]: o
          }
        }
      };
    }
  };
}, c3 = function(e) {
  return e === void 0 && (e = {}), {
    options: e,
    fn(t) {
      const {
        x: n,
        y: r,
        placement: a,
        rects: i,
        middlewareData: o
      } = t, {
        offset: s = 0,
        mainAxis: l = !0,
        crossAxis: c = !0
      } = Zr(e, t), u = {
        x: n,
        y: r
      }, f = rr(a), d = ob(f);
      let h = u[d], g = u[f];
      const v = Zr(s, t), b = typeof v == "number" ? {
        mainAxis: v,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...v
      };
      if (l) {
        const w = d === "y" ? "height" : "width", x = i.reference[d] - i.floating[w] + b.mainAxis, S = i.reference[d] + i.reference[w] - b.mainAxis;
        h < x ? h = x : h > S && (h = S);
      }
      if (c) {
        var p, m;
        const w = d === "y" ? "width" : "height", x = oR.has(Jr(a)), S = i.reference[f] - i.floating[w] + (x && ((p = o.offset) == null ? void 0 : p[f]) || 0) + (x ? 0 : b.crossAxis), T = i.reference[f] + i.reference[w] + (x ? 0 : ((m = o.offset) == null ? void 0 : m[f]) || 0) - (x ? b.crossAxis : 0);
        g < S ? g = S : g > T && (g = T);
      }
      return {
        [d]: h,
        [f]: g
      };
    }
  };
}, u3 = function(e) {
  return e === void 0 && (e = {}), {
    name: "size",
    options: e,
    async fn(t) {
      var n, r;
      const {
        placement: a,
        rects: i,
        platform: o,
        elements: s
      } = t, {
        apply: l = () => {
        },
        ...c
      } = Zr(e, t), u = await Pc(t, c), f = Jr(a), d = al(a), h = rr(a) === "y", {
        width: g,
        height: v
      } = i.floating;
      let b, p;
      f === "top" || f === "bottom" ? (b = f, p = d === (await (o.isRTL == null ? void 0 : o.isRTL(s.floating)) ? "start" : "end") ? "left" : "right") : (p = f, b = d === "end" ? "top" : "bottom");
      const m = v - u.top - u.bottom, w = g - u.left - u.right, x = ii(v - u[b], m), S = ii(g - u[p], w), T = !t.middlewareData.shift;
      let E = x, O = S;
      if ((n = t.middlewareData.shift) != null && n.enabled.x && (O = w), (r = t.middlewareData.shift) != null && r.enabled.y && (E = m), T && !d) {
        const A = dn(u.left, 0), U = dn(u.right, 0), R = dn(u.top, 0), q = dn(u.bottom, 0);
        h ? O = g - 2 * (A !== 0 || U !== 0 ? A + U : dn(u.left, u.right)) : E = v - 2 * (R !== 0 || q !== 0 ? R + q : dn(u.top, u.bottom));
      }
      await l({
        ...t,
        availableWidth: O,
        availableHeight: E
      });
      const D = await o.getDimensions(s.floating);
      return g !== D.width || v !== D.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function ch() {
  return typeof window < "u";
}
function il(e) {
  return sR(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function bn(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function vr(e) {
  var t;
  return (t = (sR(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function sR(e) {
  return ch() ? e instanceof Node || e instanceof bn(e).Node : !1;
}
function Qn(e) {
  return ch() ? e instanceof Element || e instanceof bn(e).Element : !1;
}
function dr(e) {
  return ch() ? e instanceof HTMLElement || e instanceof bn(e).HTMLElement : !1;
}
function mE(e) {
  return !ch() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof bn(e).ShadowRoot;
}
const f3 = /* @__PURE__ */ new Set(["inline", "contents"]);
function pu(e) {
  const {
    overflow: t,
    overflowX: n,
    overflowY: r,
    display: a
  } = Hn(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !f3.has(a);
}
const d3 = /* @__PURE__ */ new Set(["table", "td", "th"]);
function h3(e) {
  return d3.has(il(e));
}
const p3 = [":popover-open", ":modal"];
function uh(e) {
  return p3.some((t) => {
    try {
      return e.matches(t);
    } catch {
      return !1;
    }
  });
}
const m3 = ["transform", "translate", "scale", "rotate", "perspective"], g3 = ["transform", "translate", "scale", "rotate", "perspective", "filter"], v3 = ["paint", "layout", "strict", "content"];
function cb(e) {
  const t = ub(), n = Qn(e) ? Hn(e) : e;
  return m3.some((r) => n[r] ? n[r] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || g3.some((r) => (n.willChange || "").includes(r)) || v3.some((r) => (n.contain || "").includes(r));
}
function y3(e) {
  let t = oi(e);
  for (; dr(t) && !Us(t); ) {
    if (cb(t))
      return t;
    if (uh(t))
      return null;
    t = oi(t);
  }
  return null;
}
function ub() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
const b3 = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function Us(e) {
  return b3.has(il(e));
}
function Hn(e) {
  return bn(e).getComputedStyle(e);
}
function fh(e) {
  return Qn(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.scrollX,
    scrollTop: e.scrollY
  };
}
function oi(e) {
  if (il(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    mE(e) && e.host || // Fallback.
    vr(e)
  );
  return mE(t) ? t.host : t;
}
function lR(e) {
  const t = oi(e);
  return Us(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : dr(t) && pu(t) ? t : lR(t);
}
function Ic(e, t, n) {
  var r;
  t === void 0 && (t = []), n === void 0 && (n = !0);
  const a = lR(e), i = a === ((r = e.ownerDocument) == null ? void 0 : r.body), o = bn(a);
  if (i) {
    const s = Zg(o);
    return t.concat(o, o.visualViewport || [], pu(a) ? a : [], s && n ? Ic(s) : []);
  }
  return t.concat(a, Ic(a, [], n));
}
function Zg(e) {
  return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
}
function cR(e) {
  const t = Hn(e);
  let n = parseFloat(t.width) || 0, r = parseFloat(t.height) || 0;
  const a = dr(e), i = a ? e.offsetWidth : n, o = a ? e.offsetHeight : r, s = yd(n) !== i || yd(r) !== o;
  return s && (n = i, r = o), {
    width: n,
    height: r,
    $: s
  };
}
function fb(e) {
  return Qn(e) ? e : e.contextElement;
}
function cs(e) {
  const t = fb(e);
  if (!dr(t))
    return lr(1);
  const n = t.getBoundingClientRect(), {
    width: r,
    height: a,
    $: i
  } = cR(t);
  let o = (i ? yd(n.width) : n.width) / r, s = (i ? yd(n.height) : n.height) / a;
  return (!o || !Number.isFinite(o)) && (o = 1), (!s || !Number.isFinite(s)) && (s = 1), {
    x: o,
    y: s
  };
}
const w3 = /* @__PURE__ */ lr(0);
function uR(e) {
  const t = bn(e);
  return !ub() || !t.visualViewport ? w3 : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function x3(e, t, n) {
  return t === void 0 && (t = !1), !n || t && n !== bn(e) ? !1 : t;
}
function eo(e, t, n, r) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const a = e.getBoundingClientRect(), i = fb(e);
  let o = lr(1);
  t && (r ? Qn(r) && (o = cs(r)) : o = cs(e));
  const s = x3(i, n, r) ? uR(i) : lr(0);
  let l = (a.left + s.x) / o.x, c = (a.top + s.y) / o.y, u = a.width / o.x, f = a.height / o.y;
  if (i) {
    const d = bn(i), h = r && Qn(r) ? bn(r) : r;
    let g = d, v = Zg(g);
    for (; v && r && h !== g; ) {
      const b = cs(v), p = v.getBoundingClientRect(), m = Hn(v), w = p.left + (v.clientLeft + parseFloat(m.paddingLeft)) * b.x, x = p.top + (v.clientTop + parseFloat(m.paddingTop)) * b.y;
      l *= b.x, c *= b.y, u *= b.x, f *= b.y, l += w, c += x, g = bn(v), v = Zg(g);
    }
  }
  return wd({
    width: u,
    height: f,
    x: l,
    y: c
  });
}
function dh(e, t) {
  const n = fh(e).scrollLeft;
  return t ? t.left + n : eo(vr(e)).left + n;
}
function fR(e, t) {
  const n = e.getBoundingClientRect(), r = n.left + t.scrollLeft - dh(e, n), a = n.top + t.scrollTop;
  return {
    x: r,
    y: a
  };
}
function E3(e) {
  let {
    elements: t,
    rect: n,
    offsetParent: r,
    strategy: a
  } = e;
  const i = a === "fixed", o = vr(r), s = t ? uh(t.floating) : !1;
  if (r === o || s && i)
    return n;
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  }, c = lr(1);
  const u = lr(0), f = dr(r);
  if ((f || !f && !i) && ((il(r) !== "body" || pu(o)) && (l = fh(r)), dr(r))) {
    const h = eo(r);
    c = cs(r), u.x = h.x + r.clientLeft, u.y = h.y + r.clientTop;
  }
  const d = o && !f && !i ? fR(o, l) : lr(0);
  return {
    width: n.width * c.x,
    height: n.height * c.y,
    x: n.x * c.x - l.scrollLeft * c.x + u.x + d.x,
    y: n.y * c.y - l.scrollTop * c.y + u.y + d.y
  };
}
function S3(e) {
  return Array.from(e.getClientRects());
}
function T3(e) {
  const t = vr(e), n = fh(e), r = e.ownerDocument.body, a = dn(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth), i = dn(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight);
  let o = -n.scrollLeft + dh(e);
  const s = -n.scrollTop;
  return Hn(r).direction === "rtl" && (o += dn(t.clientWidth, r.clientWidth) - a), {
    width: a,
    height: i,
    x: o,
    y: s
  };
}
const gE = 25;
function C3(e, t) {
  const n = bn(e), r = vr(e), a = n.visualViewport;
  let i = r.clientWidth, o = r.clientHeight, s = 0, l = 0;
  if (a) {
    i = a.width, o = a.height;
    const u = ub();
    (!u || u && t === "fixed") && (s = a.offsetLeft, l = a.offsetTop);
  }
  const c = dh(r);
  if (c <= 0) {
    const u = r.ownerDocument, f = u.body, d = getComputedStyle(f), h = u.compatMode === "CSS1Compat" && parseFloat(d.marginLeft) + parseFloat(d.marginRight) || 0, g = Math.abs(r.clientWidth - f.clientWidth - h);
    g <= gE && (i -= g);
  } else c <= gE && (i += c);
  return {
    width: i,
    height: o,
    x: s,
    y: l
  };
}
const O3 = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function A3(e, t) {
  const n = eo(e, !0, t === "fixed"), r = n.top + e.clientTop, a = n.left + e.clientLeft, i = dr(e) ? cs(e) : lr(1), o = e.clientWidth * i.x, s = e.clientHeight * i.y, l = a * i.x, c = r * i.y;
  return {
    width: o,
    height: s,
    x: l,
    y: c
  };
}
function vE(e, t, n) {
  let r;
  if (t === "viewport")
    r = C3(e, n);
  else if (t === "document")
    r = T3(vr(e));
  else if (Qn(t))
    r = A3(t, n);
  else {
    const a = uR(e);
    r = {
      x: t.x - a.x,
      y: t.y - a.y,
      width: t.width,
      height: t.height
    };
  }
  return wd(r);
}
function dR(e, t) {
  const n = oi(e);
  return n === t || !Qn(n) || Us(n) ? !1 : Hn(n).position === "fixed" || dR(n, t);
}
function R3(e, t) {
  const n = t.get(e);
  if (n)
    return n;
  let r = Ic(e, [], !1).filter((s) => Qn(s) && il(s) !== "body"), a = null;
  const i = Hn(e).position === "fixed";
  let o = i ? oi(e) : e;
  for (; Qn(o) && !Us(o); ) {
    const s = Hn(o), l = cb(o);
    !l && s.position === "fixed" && (a = null), (i ? !l && !a : !l && s.position === "static" && !!a && O3.has(a.position) || pu(o) && !l && dR(e, o)) ? r = r.filter((u) => u !== o) : a = s, o = oi(o);
  }
  return t.set(e, r), r;
}
function _3(e) {
  let {
    element: t,
    boundary: n,
    rootBoundary: r,
    strategy: a
  } = e;
  const o = [...n === "clippingAncestors" ? uh(t) ? [] : R3(t, this._c) : [].concat(n), r], s = o[0], l = o.reduce((c, u) => {
    const f = vE(t, u, a);
    return c.top = dn(f.top, c.top), c.right = ii(f.right, c.right), c.bottom = ii(f.bottom, c.bottom), c.left = dn(f.left, c.left), c;
  }, vE(t, s, a));
  return {
    width: l.right - l.left,
    height: l.bottom - l.top,
    x: l.left,
    y: l.top
  };
}
function D3(e) {
  const {
    width: t,
    height: n
  } = cR(e);
  return {
    width: t,
    height: n
  };
}
function N3(e, t, n) {
  const r = dr(t), a = vr(t), i = n === "fixed", o = eo(e, !0, i, t);
  let s = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const l = lr(0);
  function c() {
    l.x = dh(a);
  }
  if (r || !r && !i)
    if ((il(t) !== "body" || pu(a)) && (s = fh(t)), r) {
      const h = eo(t, !0, i, t);
      l.x = h.x + t.clientLeft, l.y = h.y + t.clientTop;
    } else a && c();
  i && !r && a && c();
  const u = a && !r && !i ? fR(a, s) : lr(0), f = o.left + s.scrollLeft - l.x - u.x, d = o.top + s.scrollTop - l.y - u.y;
  return {
    x: f,
    y: d,
    width: o.width,
    height: o.height
  };
}
function Fp(e) {
  return Hn(e).position === "static";
}
function yE(e, t) {
  if (!dr(e) || Hn(e).position === "fixed")
    return null;
  if (t)
    return t(e);
  let n = e.offsetParent;
  return vr(e) === n && (n = n.ownerDocument.body), n;
}
function hR(e, t) {
  const n = bn(e);
  if (uh(e))
    return n;
  if (!dr(e)) {
    let a = oi(e);
    for (; a && !Us(a); ) {
      if (Qn(a) && !Fp(a))
        return a;
      a = oi(a);
    }
    return n;
  }
  let r = yE(e, t);
  for (; r && h3(r) && Fp(r); )
    r = yE(r, t);
  return r && Us(r) && Fp(r) && !cb(r) ? n : r || y3(e) || n;
}
const k3 = async function(e) {
  const t = this.getOffsetParent || hR, n = this.getDimensions, r = await n(e.floating);
  return {
    reference: N3(e.reference, await t(e.floating), e.strategy),
    floating: {
      x: 0,
      y: 0,
      width: r.width,
      height: r.height
    }
  };
};
function M3(e) {
  return Hn(e).direction === "rtl";
}
const L3 = {
  convertOffsetParentRelativeRectToViewportRelativeRect: E3,
  getDocumentElement: vr,
  getClippingRect: _3,
  getOffsetParent: hR,
  getElementRects: k3,
  getClientRects: S3,
  getDimensions: D3,
  getScale: cs,
  isElement: Qn,
  isRTL: M3
};
function pR(e, t) {
  return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height;
}
function z3(e, t) {
  let n = null, r;
  const a = vr(e);
  function i() {
    var s;
    clearTimeout(r), (s = n) == null || s.disconnect(), n = null;
  }
  function o(s, l) {
    s === void 0 && (s = !1), l === void 0 && (l = 1), i();
    const c = e.getBoundingClientRect(), {
      left: u,
      top: f,
      width: d,
      height: h
    } = c;
    if (s || t(), !d || !h)
      return;
    const g = Wu(f), v = Wu(a.clientWidth - (u + d)), b = Wu(a.clientHeight - (f + h)), p = Wu(u), w = {
      rootMargin: -g + "px " + -v + "px " + -b + "px " + -p + "px",
      threshold: dn(0, ii(1, l)) || 1
    };
    let x = !0;
    function S(T) {
      const E = T[0].intersectionRatio;
      if (E !== l) {
        if (!x)
          return o();
        E ? o(!1, E) : r = setTimeout(() => {
          o(!1, 1e-7);
        }, 1e3);
      }
      E === 1 && !pR(c, e.getBoundingClientRect()) && o(), x = !1;
    }
    try {
      n = new IntersectionObserver(S, {
        ...w,
        // Handle <iframe>s
        root: a.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(S, w);
    }
    n.observe(e);
  }
  return o(!0), i;
}
function j3(e, t, n, r) {
  r === void 0 && (r = {});
  const {
    ancestorScroll: a = !0,
    ancestorResize: i = !0,
    elementResize: o = typeof ResizeObserver == "function",
    layoutShift: s = typeof IntersectionObserver == "function",
    animationFrame: l = !1
  } = r, c = fb(e), u = a || i ? [...c ? Ic(c) : [], ...Ic(t)] : [];
  u.forEach((p) => {
    a && p.addEventListener("scroll", n, {
      passive: !0
    }), i && p.addEventListener("resize", n);
  });
  const f = c && s ? z3(c, n) : null;
  let d = -1, h = null;
  o && (h = new ResizeObserver((p) => {
    let [m] = p;
    m && m.target === c && h && (h.unobserve(t), cancelAnimationFrame(d), d = requestAnimationFrame(() => {
      var w;
      (w = h) == null || w.observe(t);
    })), n();
  }), c && !l && h.observe(c), h.observe(t));
  let g, v = l ? eo(e) : null;
  l && b();
  function b() {
    const p = eo(e);
    v && !pR(v, p) && n(), v = p, g = requestAnimationFrame(b);
  }
  return n(), () => {
    var p;
    u.forEach((m) => {
      a && m.removeEventListener("scroll", n), i && m.removeEventListener("resize", n);
    }), f == null || f(), (p = h) == null || p.disconnect(), h = null, l && cancelAnimationFrame(g);
  };
}
const P3 = s3, I3 = l3, F3 = a3, U3 = u3, q3 = i3, bE = r3, B3 = c3, V3 = (e, t, n) => {
  const r = /* @__PURE__ */ new Map(), a = {
    platform: L3,
    ...n
  }, i = {
    ...a.platform,
    _c: r
  };
  return n3(e, t, {
    ...a,
    platform: i
  });
};
var Q3 = typeof document < "u", H3 = function() {
}, Nf = Q3 ? y.useLayoutEffect : H3;
function xd(e, t) {
  if (e === t)
    return !0;
  if (typeof e != typeof t)
    return !1;
  if (typeof e == "function" && e.toString() === t.toString())
    return !0;
  let n, r, a;
  if (e && t && typeof e == "object") {
    if (Array.isArray(e)) {
      if (n = e.length, n !== t.length) return !1;
      for (r = n; r-- !== 0; )
        if (!xd(e[r], t[r]))
          return !1;
      return !0;
    }
    if (a = Object.keys(e), n = a.length, n !== Object.keys(t).length)
      return !1;
    for (r = n; r-- !== 0; )
      if (!{}.hasOwnProperty.call(t, a[r]))
        return !1;
    for (r = n; r-- !== 0; ) {
      const i = a[r];
      if (!(i === "_owner" && e.$$typeof) && !xd(e[i], t[i]))
        return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
}
function mR(e) {
  return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function wE(e, t) {
  const n = mR(e);
  return Math.round(t * n) / n;
}
function Up(e) {
  const t = y.useRef(e);
  return Nf(() => {
    t.current = e;
  }), t;
}
function $3(e) {
  e === void 0 && (e = {});
  const {
    placement: t = "bottom",
    strategy: n = "absolute",
    middleware: r = [],
    platform: a,
    elements: {
      reference: i,
      floating: o
    } = {},
    transform: s = !0,
    whileElementsMounted: l,
    open: c
  } = e, [u, f] = y.useState({
    x: 0,
    y: 0,
    strategy: n,
    placement: t,
    middlewareData: {},
    isPositioned: !1
  }), [d, h] = y.useState(r);
  xd(d, r) || h(r);
  const [g, v] = y.useState(null), [b, p] = y.useState(null), m = y.useCallback((F) => {
    F !== T.current && (T.current = F, v(F));
  }, []), w = y.useCallback((F) => {
    F !== E.current && (E.current = F, p(F));
  }, []), x = i || g, S = o || b, T = y.useRef(null), E = y.useRef(null), O = y.useRef(u), D = l != null, A = Up(l), U = Up(a), R = Up(c), q = y.useCallback(() => {
    if (!T.current || !E.current)
      return;
    const F = {
      placement: t,
      strategy: n,
      middleware: d
    };
    U.current && (F.platform = U.current), V3(T.current, E.current, F).then((H) => {
      const K = {
        ...H,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: R.current !== !1
      };
      z.current && !xd(O.current, K) && (O.current = K, Gc.flushSync(() => {
        f(K);
      }));
    });
  }, [d, t, n, U, R]);
  Nf(() => {
    c === !1 && O.current.isPositioned && (O.current.isPositioned = !1, f((F) => ({
      ...F,
      isPositioned: !1
    })));
  }, [c]);
  const z = y.useRef(!1);
  Nf(() => (z.current = !0, () => {
    z.current = !1;
  }), []), Nf(() => {
    if (x && (T.current = x), S && (E.current = S), x && S) {
      if (A.current)
        return A.current(x, S, q);
      q();
    }
  }, [x, S, q, A, D]);
  const Q = y.useMemo(() => ({
    reference: T,
    floating: E,
    setReference: m,
    setFloating: w
  }), [m, w]), k = y.useMemo(() => ({
    reference: x,
    floating: S
  }), [x, S]), P = y.useMemo(() => {
    const F = {
      position: n,
      left: 0,
      top: 0
    };
    if (!k.floating)
      return F;
    const H = wE(k.floating, u.x), K = wE(k.floating, u.y);
    return s ? {
      ...F,
      transform: "translate(" + H + "px, " + K + "px)",
      ...mR(k.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: n,
      left: H,
      top: K
    };
  }, [n, s, k.floating, u.x, u.y]);
  return y.useMemo(() => ({
    ...u,
    update: q,
    refs: Q,
    elements: k,
    floatingStyles: P
  }), [u, q, Q, k, P]);
}
const G3 = (e) => {
  function t(n) {
    return {}.hasOwnProperty.call(n, "current");
  }
  return {
    name: "arrow",
    options: e,
    fn(n) {
      const {
        element: r,
        padding: a
      } = typeof e == "function" ? e(n) : e;
      return r && t(r) ? r.current != null ? bE({
        element: r.current,
        padding: a
      }).fn(n) : {} : r ? bE({
        element: r,
        padding: a
      }).fn(n) : {};
    }
  };
}, Y3 = (e, t) => ({
  ...P3(e),
  options: [e, t]
}), K3 = (e, t) => ({
  ...I3(e),
  options: [e, t]
}), X3 = (e, t) => ({
  ...B3(e),
  options: [e, t]
}), W3 = (e, t) => ({
  ...F3(e),
  options: [e, t]
}), Z3 = (e, t) => ({
  ...U3(e),
  options: [e, t]
}), J3 = (e, t) => ({
  ...q3(e),
  options: [e, t]
}), eU = (e, t) => ({
  ...G3(e),
  options: [e, t]
});
var tU = "Arrow", gR = y.forwardRef((e, t) => {
  const { children: n, width: r = 10, height: a = 5, ...i } = e;
  return /* @__PURE__ */ N.jsx(
    ut.svg,
    {
      ...i,
      ref: t,
      width: r,
      height: a,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: e.asChild ? n : /* @__PURE__ */ N.jsx("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
gR.displayName = tU;
var nU = gR;
function rU(e) {
  const [t, n] = y.useState(void 0);
  return Wr(() => {
    if (e) {
      n({ width: e.offsetWidth, height: e.offsetHeight });
      const r = new ResizeObserver((a) => {
        if (!Array.isArray(a) || !a.length)
          return;
        const i = a[0];
        let o, s;
        if ("borderBoxSize" in i) {
          const l = i.borderBoxSize, c = Array.isArray(l) ? l[0] : l;
          o = c.inlineSize, s = c.blockSize;
        } else
          o = e.offsetWidth, s = e.offsetHeight;
        n({ width: o, height: s });
      });
      return r.observe(e, { box: "border-box" }), () => r.unobserve(e);
    } else
      n(void 0);
  }, [e]), t;
}
var db = "Popper", [vR, yR] = hu(db), [aU, bR] = vR(db), wR = (e) => {
  const { __scopePopper: t, children: n } = e, [r, a] = y.useState(null);
  return /* @__PURE__ */ N.jsx(aU, { scope: t, anchor: r, onAnchorChange: a, children: n });
};
wR.displayName = db;
var xR = "PopperAnchor", ER = y.forwardRef(
  (e, t) => {
    const { __scopePopper: n, virtualRef: r, ...a } = e, i = bR(xR, n), o = y.useRef(null), s = Yt(t, o), l = y.useRef(null);
    return y.useEffect(() => {
      const c = l.current;
      l.current = (r == null ? void 0 : r.current) || o.current, c !== l.current && i.onAnchorChange(l.current);
    }), r ? null : /* @__PURE__ */ N.jsx(ut.div, { ...a, ref: s });
  }
);
ER.displayName = xR;
var hb = "PopperContent", [iU, oU] = vR(hb), SR = y.forwardRef(
  (e, t) => {
    var Se, Tt, ft, yr, yt, br;
    const {
      __scopePopper: n,
      side: r = "bottom",
      sideOffset: a = 0,
      align: i = "center",
      alignOffset: o = 0,
      arrowPadding: s = 0,
      avoidCollisions: l = !0,
      collisionBoundary: c = [],
      collisionPadding: u = 0,
      sticky: f = "partial",
      hideWhenDetached: d = !1,
      updatePositionStrategy: h = "optimized",
      onPlaced: g,
      ...v
    } = e, b = bR(hb, n), [p, m] = y.useState(null), w = Yt(t, (ra) => m(ra)), [x, S] = y.useState(null), T = rU(x), E = (T == null ? void 0 : T.width) ?? 0, O = (T == null ? void 0 : T.height) ?? 0, D = r + (i !== "center" ? "-" + i : ""), A = typeof u == "number" ? u : { top: 0, right: 0, bottom: 0, left: 0, ...u }, U = Array.isArray(c) ? c : [c], R = U.length > 0, q = {
      padding: A,
      boundary: U.filter(lU),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: R
    }, { refs: z, floatingStyles: Q, placement: k, isPositioned: P, middlewareData: F } = $3({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: D,
      whileElementsMounted: (...ra) => j3(...ra, {
        animationFrame: h === "always"
      }),
      elements: {
        reference: b.anchor
      },
      middleware: [
        Y3({ mainAxis: a + O, alignmentAxis: o }),
        l && K3({
          mainAxis: !0,
          crossAxis: !1,
          limiter: f === "partial" ? X3() : void 0,
          ...q
        }),
        l && W3({ ...q }),
        Z3({
          ...q,
          apply: ({ elements: ra, rects: yu, availableWidth: wr, availableHeight: xh }) => {
            const { width: Eh, height: bu } = yu.reference, ho = ra.floating.style;
            ho.setProperty("--radix-popper-available-width", `${wr}px`), ho.setProperty("--radix-popper-available-height", `${xh}px`), ho.setProperty("--radix-popper-anchor-width", `${Eh}px`), ho.setProperty("--radix-popper-anchor-height", `${bu}px`);
          }
        }),
        x && eU({ element: x, padding: s }),
        cU({ arrowWidth: E, arrowHeight: O }),
        d && J3({ strategy: "referenceHidden", ...q })
      ]
    }), [H, K] = OR(k), Z = fr(g);
    Wr(() => {
      P && (Z == null || Z());
    }, [P, Z]);
    const I = (Se = F.arrow) == null ? void 0 : Se.x, G = (Tt = F.arrow) == null ? void 0 : Tt.y, ee = ((ft = F.arrow) == null ? void 0 : ft.centerOffset) !== 0, [J, we] = y.useState();
    return Wr(() => {
      p && we(window.getComputedStyle(p).zIndex);
    }, [p]), /* @__PURE__ */ N.jsx(
      "div",
      {
        ref: z.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...Q,
          transform: P ? Q.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: J,
          "--radix-popper-transform-origin": [
            (yr = F.transformOrigin) == null ? void 0 : yr.x,
            (yt = F.transformOrigin) == null ? void 0 : yt.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...((br = F.hide) == null ? void 0 : br.referenceHidden) && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: e.dir,
        children: /* @__PURE__ */ N.jsx(
          iU,
          {
            scope: n,
            placedSide: H,
            onArrowChange: S,
            arrowX: I,
            arrowY: G,
            shouldHideArrow: ee,
            children: /* @__PURE__ */ N.jsx(
              ut.div,
              {
                "data-side": H,
                "data-align": K,
                ...v,
                ref: w,
                style: {
                  ...v.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: P ? void 0 : "none"
                }
              }
            )
          }
        )
      }
    );
  }
);
SR.displayName = hb;
var TR = "PopperArrow", sU = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
}, CR = y.forwardRef(function(t, n) {
  const { __scopePopper: r, ...a } = t, i = oU(TR, r), o = sU[i.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ N.jsx(
      "span",
      {
        ref: i.onArrowChange,
        style: {
          position: "absolute",
          left: i.arrowX,
          top: i.arrowY,
          [o]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[i.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: "rotate(180deg)",
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[i.placedSide],
          visibility: i.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ N.jsx(
          nU,
          {
            ...a,
            ref: n,
            style: {
              ...a.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
CR.displayName = TR;
function lU(e) {
  return e !== null;
}
var cU = (e) => ({
  name: "transformOrigin",
  options: e,
  fn(t) {
    var b, p, m;
    const { placement: n, rects: r, middlewareData: a } = t, o = ((b = a.arrow) == null ? void 0 : b.centerOffset) !== 0, s = o ? 0 : e.arrowWidth, l = o ? 0 : e.arrowHeight, [c, u] = OR(n), f = { start: "0%", center: "50%", end: "100%" }[u], d = (((p = a.arrow) == null ? void 0 : p.x) ?? 0) + s / 2, h = (((m = a.arrow) == null ? void 0 : m.y) ?? 0) + l / 2;
    let g = "", v = "";
    return c === "bottom" ? (g = o ? f : `${d}px`, v = `${-l}px`) : c === "top" ? (g = o ? f : `${d}px`, v = `${r.floating.height + l}px`) : c === "right" ? (g = `${-l}px`, v = o ? f : `${h}px`) : c === "left" && (g = `${r.floating.width + l}px`, v = o ? f : `${h}px`), { data: { x: g, y: v } };
  }
});
function OR(e) {
  const [t, n = "center"] = e.split("-");
  return [t, n];
}
var uU = wR, AR = ER, fU = SR, dU = CR, hU = "Portal", hh = y.forwardRef((e, t) => {
  var s;
  const { container: n, ...r } = e, [a, i] = y.useState(!1);
  Wr(() => i(!0), []);
  const o = n || a && ((s = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : s.body);
  return o ? XD.createPortal(/* @__PURE__ */ N.jsx(ut.div, { ...r, ref: t }), o) : null;
});
hh.displayName = hU;
function pU(e, t) {
  return y.useReducer((n, r) => t[n][r] ?? n, e);
}
var fo = (e) => {
  const { present: t, children: n } = e, r = mU(t), a = typeof n == "function" ? n({ present: r.isPresent }) : y.Children.only(n), i = Yt(r.ref, gU(a));
  return typeof n == "function" || r.isPresent ? y.cloneElement(a, { ref: i }) : null;
};
fo.displayName = "Presence";
function mU(e) {
  const [t, n] = y.useState(), r = y.useRef(null), a = y.useRef(e), i = y.useRef("none"), o = e ? "mounted" : "unmounted", [s, l] = pU(o, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return y.useEffect(() => {
    const c = Zu(r.current);
    i.current = s === "mounted" ? c : "none";
  }, [s]), Wr(() => {
    const c = r.current, u = a.current;
    if (u !== e) {
      const d = i.current, h = Zu(c);
      e ? l("MOUNT") : h === "none" || (c == null ? void 0 : c.display) === "none" ? l("UNMOUNT") : l(u && d !== h ? "ANIMATION_OUT" : "UNMOUNT"), a.current = e;
    }
  }, [e, l]), Wr(() => {
    if (t) {
      let c;
      const u = t.ownerDocument.defaultView ?? window, f = (h) => {
        const v = Zu(r.current).includes(CSS.escape(h.animationName));
        if (h.target === t && v && (l("ANIMATION_END"), !a.current)) {
          const b = t.style.animationFillMode;
          t.style.animationFillMode = "forwards", c = u.setTimeout(() => {
            t.style.animationFillMode === "forwards" && (t.style.animationFillMode = b);
          });
        }
      }, d = (h) => {
        h.target === t && (i.current = Zu(r.current));
      };
      return t.addEventListener("animationstart", d), t.addEventListener("animationcancel", f), t.addEventListener("animationend", f), () => {
        u.clearTimeout(c), t.removeEventListener("animationstart", d), t.removeEventListener("animationcancel", f), t.removeEventListener("animationend", f);
      };
    } else
      l("ANIMATION_END");
  }, [t, l]), {
    isPresent: ["mounted", "unmountSuspended"].includes(s),
    ref: y.useCallback((c) => {
      r.current = c ? getComputedStyle(c) : null, n(c);
    }, [])
  };
}
function Zu(e) {
  return (e == null ? void 0 : e.animationName) || "none";
}
function gU(e) {
  var r, a;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (a = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : a.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var vU = wv[" useInsertionEffect ".trim().toString()] || Wr;
function pb({
  prop: e,
  defaultProp: t,
  onChange: n = () => {
  },
  caller: r
}) {
  const [a, i, o] = yU({
    defaultProp: t,
    onChange: n
  }), s = e !== void 0, l = s ? e : a;
  {
    const u = y.useRef(e !== void 0);
    y.useEffect(() => {
      const f = u.current;
      f !== s && console.warn(
        `${r} is changing from ${f ? "controlled" : "uncontrolled"} to ${s ? "controlled" : "uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`
      ), u.current = s;
    }, [s, r]);
  }
  const c = y.useCallback(
    (u) => {
      var f;
      if (s) {
        const d = bU(u) ? u(e) : u;
        d !== e && ((f = o.current) == null || f.call(o, d));
      } else
        i(u);
    },
    [s, e, i, o]
  );
  return [l, c];
}
function yU({
  defaultProp: e,
  onChange: t
}) {
  const [n, r] = y.useState(e), a = y.useRef(n), i = y.useRef(t);
  return vU(() => {
    i.current = t;
  }, [t]), y.useEffect(() => {
    var o;
    a.current !== n && ((o = i.current) == null || o.call(i, n), a.current = n);
  }, [n, a]), [n, r, i];
}
function bU(e) {
  return typeof e == "function";
}
var wU = function(e) {
  if (typeof document > "u")
    return null;
  var t = Array.isArray(e) ? e[0] : e;
  return t.ownerDocument.body;
}, vo = /* @__PURE__ */ new WeakMap(), Ju = /* @__PURE__ */ new WeakMap(), ef = {}, qp = 0, RR = function(e) {
  return e && (e.host || RR(e.parentNode));
}, xU = function(e, t) {
  return t.map(function(n) {
    if (e.contains(n))
      return n;
    var r = RR(n);
    return r && e.contains(r) ? r : (console.error("aria-hidden", n, "in not contained inside", e, ". Doing nothing"), null);
  }).filter(function(n) {
    return !!n;
  });
}, EU = function(e, t, n, r) {
  var a = xU(t, Array.isArray(e) ? e : [e]);
  ef[n] || (ef[n] = /* @__PURE__ */ new WeakMap());
  var i = ef[n], o = [], s = /* @__PURE__ */ new Set(), l = new Set(a), c = function(f) {
    !f || s.has(f) || (s.add(f), c(f.parentNode));
  };
  a.forEach(c);
  var u = function(f) {
    !f || l.has(f) || Array.prototype.forEach.call(f.children, function(d) {
      if (s.has(d))
        u(d);
      else
        try {
          var h = d.getAttribute(r), g = h !== null && h !== "false", v = (vo.get(d) || 0) + 1, b = (i.get(d) || 0) + 1;
          vo.set(d, v), i.set(d, b), o.push(d), v === 1 && g && Ju.set(d, !0), b === 1 && d.setAttribute(n, "true"), g || d.setAttribute(r, "true");
        } catch (p) {
          console.error("aria-hidden: cannot operate on ", d, p);
        }
    });
  };
  return u(t), s.clear(), qp++, function() {
    o.forEach(function(f) {
      var d = vo.get(f) - 1, h = i.get(f) - 1;
      vo.set(f, d), i.set(f, h), d || (Ju.has(f) || f.removeAttribute(r), Ju.delete(f)), h || f.removeAttribute(n);
    }), qp--, qp || (vo = /* @__PURE__ */ new WeakMap(), vo = /* @__PURE__ */ new WeakMap(), Ju = /* @__PURE__ */ new WeakMap(), ef = {});
  };
}, _R = function(e, t, n) {
  n === void 0 && (n = "data-aria-hidden");
  var r = Array.from(Array.isArray(e) ? e : [e]), a = wU(e);
  return a ? (r.push.apply(r, Array.from(a.querySelectorAll("[aria-live], script"))), EU(r, a, n, "aria-hidden")) : function() {
    return null;
  };
}, kf = "right-scroll-bar-position", Mf = "width-before-scroll-bar", SU = "with-scroll-bars-hidden", TU = "--removed-body-scroll-bar-size";
function Bp(e, t) {
  return typeof e == "function" ? e(t) : e && (e.current = t), e;
}
function CU(e, t) {
  var n = y.useState(function() {
    return {
      // value
      value: e,
      // last callback
      callback: t,
      // "memoized" public interface
      facade: {
        get current() {
          return n.value;
        },
        set current(r) {
          var a = n.value;
          a !== r && (n.value = r, n.callback(r, a));
        }
      }
    };
  })[0];
  return n.callback = t, n.facade;
}
var OU = typeof window < "u" ? y.useLayoutEffect : y.useEffect, xE = /* @__PURE__ */ new WeakMap();
function AU(e, t) {
  var n = CU(null, function(r) {
    return e.forEach(function(a) {
      return Bp(a, r);
    });
  });
  return OU(function() {
    var r = xE.get(n);
    if (r) {
      var a = new Set(r), i = new Set(e), o = n.current;
      a.forEach(function(s) {
        i.has(s) || Bp(s, null);
      }), i.forEach(function(s) {
        a.has(s) || Bp(s, o);
      });
    }
    xE.set(n, e);
  }, [e]), n;
}
function RU(e) {
  return e;
}
function _U(e, t) {
  t === void 0 && (t = RU);
  var n = [], r = !1, a = {
    read: function() {
      if (r)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return n.length ? n[n.length - 1] : e;
    },
    useMedium: function(i) {
      var o = t(i, r);
      return n.push(o), function() {
        n = n.filter(function(s) {
          return s !== o;
        });
      };
    },
    assignSyncMedium: function(i) {
      for (r = !0; n.length; ) {
        var o = n;
        n = [], o.forEach(i);
      }
      n = {
        push: function(s) {
          return i(s);
        },
        filter: function() {
          return n;
        }
      };
    },
    assignMedium: function(i) {
      r = !0;
      var o = [];
      if (n.length) {
        var s = n;
        n = [], s.forEach(i), o = n;
      }
      var l = function() {
        var u = o;
        o = [], u.forEach(i);
      }, c = function() {
        return Promise.resolve().then(l);
      };
      c(), n = {
        push: function(u) {
          o.push(u), c();
        },
        filter: function(u) {
          return o = o.filter(u), n;
        }
      };
    }
  };
  return a;
}
function DU(e) {
  e === void 0 && (e = {});
  var t = _U(null);
  return t.options = M({ async: !0, ssr: !1 }, e), t;
}
var DR = function(e) {
  var t = e.sideCar, n = Ln(e, ["sideCar"]);
  if (!t)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var r = t.read();
  if (!r)
    throw new Error("Sidecar medium not found");
  return y.createElement(r, M({}, n));
};
DR.isSideCarExport = !0;
function NU(e, t) {
  return e.useMedium(t), DR;
}
var NR = DU(), Vp = function() {
}, ph = y.forwardRef(function(e, t) {
  var n = y.useRef(null), r = y.useState({
    onScrollCapture: Vp,
    onWheelCapture: Vp,
    onTouchMoveCapture: Vp
  }), a = r[0], i = r[1], o = e.forwardProps, s = e.children, l = e.className, c = e.removeScrollBar, u = e.enabled, f = e.shards, d = e.sideCar, h = e.noRelative, g = e.noIsolation, v = e.inert, b = e.allowPinchZoom, p = e.as, m = p === void 0 ? "div" : p, w = e.gapMode, x = Ln(e, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noRelative", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), S = d, T = AU([n, t]), E = M(M({}, x), a);
  return y.createElement(
    y.Fragment,
    null,
    u && y.createElement(S, { sideCar: NR, removeScrollBar: c, shards: f, noRelative: h, noIsolation: g, inert: v, setCallbacks: i, allowPinchZoom: !!b, lockRef: n, gapMode: w }),
    o ? y.cloneElement(y.Children.only(s), M(M({}, E), { ref: T })) : y.createElement(m, M({}, E, { className: l, ref: T }), s)
  );
});
ph.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
ph.classNames = {
  fullWidth: Mf,
  zeroRight: kf
};
var kU = function() {
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function MU() {
  if (!document)
    return null;
  var e = document.createElement("style");
  e.type = "text/css";
  var t = kU();
  return t && e.setAttribute("nonce", t), e;
}
function LU(e, t) {
  e.styleSheet ? e.styleSheet.cssText = t : e.appendChild(document.createTextNode(t));
}
function zU(e) {
  var t = document.head || document.getElementsByTagName("head")[0];
  t.appendChild(e);
}
var jU = function() {
  var e = 0, t = null;
  return {
    add: function(n) {
      e == 0 && (t = MU()) && (LU(t, n), zU(t)), e++;
    },
    remove: function() {
      e--, !e && t && (t.parentNode && t.parentNode.removeChild(t), t = null);
    }
  };
}, PU = function() {
  var e = jU();
  return function(t, n) {
    y.useEffect(function() {
      return e.add(t), function() {
        e.remove();
      };
    }, [t && n]);
  };
}, kR = function() {
  var e = PU(), t = function(n) {
    var r = n.styles, a = n.dynamic;
    return e(r, a), null;
  };
  return t;
}, IU = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
}, Qp = function(e) {
  return parseInt(e || "", 10) || 0;
}, FU = function(e) {
  var t = window.getComputedStyle(document.body), n = t[e === "padding" ? "paddingLeft" : "marginLeft"], r = t[e === "padding" ? "paddingTop" : "marginTop"], a = t[e === "padding" ? "paddingRight" : "marginRight"];
  return [Qp(n), Qp(r), Qp(a)];
}, UU = function(e) {
  if (e === void 0 && (e = "margin"), typeof window > "u")
    return IU;
  var t = FU(e), n = document.documentElement.clientWidth, r = window.innerWidth;
  return {
    left: t[0],
    top: t[1],
    right: t[2],
    gap: Math.max(0, r - n + t[2] - t[0])
  };
}, qU = kR(), us = "data-scroll-locked", BU = function(e, t, n, r) {
  var a = e.left, i = e.top, o = e.right, s = e.gap;
  return n === void 0 && (n = "margin"), `
  .`.concat(SU, ` {
   overflow: hidden `).concat(r, `;
   padding-right: `).concat(s, "px ").concat(r, `;
  }
  body[`).concat(us, `] {
    overflow: hidden `).concat(r, `;
    overscroll-behavior: contain;
    `).concat([
    t && "position: relative ".concat(r, ";"),
    n === "margin" && `
    padding-left: `.concat(a, `px;
    padding-top: `).concat(i, `px;
    padding-right: `).concat(o, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(s, "px ").concat(r, `;
    `),
    n === "padding" && "padding-right: ".concat(s, "px ").concat(r, ";")
  ].filter(Boolean).join(""), `
  }
  
  .`).concat(kf, ` {
    right: `).concat(s, "px ").concat(r, `;
  }
  
  .`).concat(Mf, ` {
    margin-right: `).concat(s, "px ").concat(r, `;
  }
  
  .`).concat(kf, " .").concat(kf, ` {
    right: 0 `).concat(r, `;
  }
  
  .`).concat(Mf, " .").concat(Mf, ` {
    margin-right: 0 `).concat(r, `;
  }
  
  body[`).concat(us, `] {
    `).concat(TU, ": ").concat(s, `px;
  }
`);
}, EE = function() {
  var e = parseInt(document.body.getAttribute(us) || "0", 10);
  return isFinite(e) ? e : 0;
}, VU = function() {
  y.useEffect(function() {
    return document.body.setAttribute(us, (EE() + 1).toString()), function() {
      var e = EE() - 1;
      e <= 0 ? document.body.removeAttribute(us) : document.body.setAttribute(us, e.toString());
    };
  }, []);
}, QU = function(e) {
  var t = e.noRelative, n = e.noImportant, r = e.gapMode, a = r === void 0 ? "margin" : r;
  VU();
  var i = y.useMemo(function() {
    return UU(a);
  }, [a]);
  return y.createElement(qU, { styles: BU(i, !t, a, n ? "" : "!important") });
}, Jg = !1;
if (typeof window < "u")
  try {
    var tf = Object.defineProperty({}, "passive", {
      get: function() {
        return Jg = !0, !0;
      }
    });
    window.addEventListener("test", tf, tf), window.removeEventListener("test", tf, tf);
  } catch {
    Jg = !1;
  }
var yo = Jg ? { passive: !1 } : !1, HU = function(e) {
  return e.tagName === "TEXTAREA";
}, MR = function(e, t) {
  if (!(e instanceof Element))
    return !1;
  var n = window.getComputedStyle(e);
  return (
    // not-not-scrollable
    n[t] !== "hidden" && // contains scroll inside self
    !(n.overflowY === n.overflowX && !HU(e) && n[t] === "visible")
  );
}, $U = function(e) {
  return MR(e, "overflowY");
}, GU = function(e) {
  return MR(e, "overflowX");
}, SE = function(e, t) {
  var n = t.ownerDocument, r = t;
  do {
    typeof ShadowRoot < "u" && r instanceof ShadowRoot && (r = r.host);
    var a = LR(e, r);
    if (a) {
      var i = zR(e, r), o = i[1], s = i[2];
      if (o > s)
        return !0;
    }
    r = r.parentNode;
  } while (r && r !== n.body);
  return !1;
}, YU = function(e) {
  var t = e.scrollTop, n = e.scrollHeight, r = e.clientHeight;
  return [
    t,
    n,
    r
  ];
}, KU = function(e) {
  var t = e.scrollLeft, n = e.scrollWidth, r = e.clientWidth;
  return [
    t,
    n,
    r
  ];
}, LR = function(e, t) {
  return e === "v" ? $U(t) : GU(t);
}, zR = function(e, t) {
  return e === "v" ? YU(t) : KU(t);
}, XU = function(e, t) {
  return e === "h" && t === "rtl" ? -1 : 1;
}, WU = function(e, t, n, r, a) {
  var i = XU(e, window.getComputedStyle(t).direction), o = i * r, s = n.target, l = t.contains(s), c = !1, u = o > 0, f = 0, d = 0;
  do {
    if (!s)
      break;
    var h = zR(e, s), g = h[0], v = h[1], b = h[2], p = v - b - i * g;
    (g || p) && LR(e, s) && (f += p, d += g);
    var m = s.parentNode;
    s = m && m.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? m.host : m;
  } while (
    // portaled content
    !l && s !== document.body || // self content
    l && (t.contains(s) || t === s)
  );
  return (u && Math.abs(f) < 1 || !u && Math.abs(d) < 1) && (c = !0), c;
}, nf = function(e) {
  return "changedTouches" in e ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY] : [0, 0];
}, TE = function(e) {
  return [e.deltaX, e.deltaY];
}, CE = function(e) {
  return e && "current" in e ? e.current : e;
}, ZU = function(e, t) {
  return e[0] === t[0] && e[1] === t[1];
}, JU = function(e) {
  return `
  .block-interactivity-`.concat(e, ` {pointer-events: none;}
  .allow-interactivity-`).concat(e, ` {pointer-events: all;}
`);
}, eq = 0, bo = [];
function tq(e) {
  var t = y.useRef([]), n = y.useRef([0, 0]), r = y.useRef(), a = y.useState(eq++)[0], i = y.useState(kR)[0], o = y.useRef(e);
  y.useEffect(function() {
    o.current = e;
  }, [e]), y.useEffect(function() {
    if (e.inert) {
      document.body.classList.add("block-interactivity-".concat(a));
      var v = Nt([e.lockRef.current], (e.shards || []).map(CE), !0).filter(Boolean);
      return v.forEach(function(b) {
        return b.classList.add("allow-interactivity-".concat(a));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(a)), v.forEach(function(b) {
          return b.classList.remove("allow-interactivity-".concat(a));
        });
      };
    }
  }, [e.inert, e.lockRef.current, e.shards]);
  var s = y.useCallback(function(v, b) {
    if ("touches" in v && v.touches.length === 2 || v.type === "wheel" && v.ctrlKey)
      return !o.current.allowPinchZoom;
    var p = nf(v), m = n.current, w = "deltaX" in v ? v.deltaX : m[0] - p[0], x = "deltaY" in v ? v.deltaY : m[1] - p[1], S, T = v.target, E = Math.abs(w) > Math.abs(x) ? "h" : "v";
    if ("touches" in v && E === "h" && T.type === "range")
      return !1;
    var O = SE(E, T);
    if (!O)
      return !0;
    if (O ? S = E : (S = E === "v" ? "h" : "v", O = SE(E, T)), !O)
      return !1;
    if (!r.current && "changedTouches" in v && (w || x) && (r.current = S), !S)
      return !0;
    var D = r.current || S;
    return WU(D, b, v, D === "h" ? w : x);
  }, []), l = y.useCallback(function(v) {
    var b = v;
    if (!(!bo.length || bo[bo.length - 1] !== i)) {
      var p = "deltaY" in b ? TE(b) : nf(b), m = t.current.filter(function(S) {
        return S.name === b.type && (S.target === b.target || b.target === S.shadowParent) && ZU(S.delta, p);
      })[0];
      if (m && m.should) {
        b.cancelable && b.preventDefault();
        return;
      }
      if (!m) {
        var w = (o.current.shards || []).map(CE).filter(Boolean).filter(function(S) {
          return S.contains(b.target);
        }), x = w.length > 0 ? s(b, w[0]) : !o.current.noIsolation;
        x && b.cancelable && b.preventDefault();
      }
    }
  }, []), c = y.useCallback(function(v, b, p, m) {
    var w = { name: v, delta: b, target: p, should: m, shadowParent: nq(p) };
    t.current.push(w), setTimeout(function() {
      t.current = t.current.filter(function(x) {
        return x !== w;
      });
    }, 1);
  }, []), u = y.useCallback(function(v) {
    n.current = nf(v), r.current = void 0;
  }, []), f = y.useCallback(function(v) {
    c(v.type, TE(v), v.target, s(v, e.lockRef.current));
  }, []), d = y.useCallback(function(v) {
    c(v.type, nf(v), v.target, s(v, e.lockRef.current));
  }, []);
  y.useEffect(function() {
    return bo.push(i), e.setCallbacks({
      onScrollCapture: f,
      onWheelCapture: f,
      onTouchMoveCapture: d
    }), document.addEventListener("wheel", l, yo), document.addEventListener("touchmove", l, yo), document.addEventListener("touchstart", u, yo), function() {
      bo = bo.filter(function(v) {
        return v !== i;
      }), document.removeEventListener("wheel", l, yo), document.removeEventListener("touchmove", l, yo), document.removeEventListener("touchstart", u, yo);
    };
  }, []);
  var h = e.removeScrollBar, g = e.inert;
  return y.createElement(
    y.Fragment,
    null,
    g ? y.createElement(i, { styles: JU(a) }) : null,
    h ? y.createElement(QU, { noRelative: e.noRelative, gapMode: e.gapMode }) : null
  );
}
function nq(e) {
  for (var t = null; e !== null; )
    e instanceof ShadowRoot && (t = e.host, e = e.host), e = e.parentNode;
  return t;
}
const rq = NU(NR, tq);
var mb = y.forwardRef(function(e, t) {
  return y.createElement(ph, M({}, e, { ref: t, sideCar: rq }));
});
mb.classNames = ph.classNames;
var mh = "Popover", [jR] = hu(mh, [
  yR
]), mu = yR(), [aq, di] = jR(mh), PR = (e) => {
  const {
    __scopePopover: t,
    children: n,
    open: r,
    defaultOpen: a,
    onOpenChange: i,
    modal: o = !1
  } = e, s = mu(t), l = y.useRef(null), [c, u] = y.useState(!1), [f, d] = pb({
    prop: r,
    defaultProp: a ?? !1,
    onChange: i,
    caller: mh
  });
  return /* @__PURE__ */ N.jsx(uU, { ...s, children: /* @__PURE__ */ N.jsx(
    aq,
    {
      scope: t,
      contentId: sr(),
      triggerRef: l,
      open: f,
      onOpenChange: d,
      onOpenToggle: y.useCallback(() => d((h) => !h), [d]),
      hasCustomAnchor: c,
      onCustomAnchorAdd: y.useCallback(() => u(!0), []),
      onCustomAnchorRemove: y.useCallback(() => u(!1), []),
      modal: o,
      children: n
    }
  ) });
};
PR.displayName = mh;
var IR = "PopoverAnchor", iq = y.forwardRef(
  (e, t) => {
    const { __scopePopover: n, ...r } = e, a = di(IR, n), i = mu(n), { onCustomAnchorAdd: o, onCustomAnchorRemove: s } = a;
    return y.useEffect(() => (o(), () => s()), [o, s]), /* @__PURE__ */ N.jsx(AR, { ...i, ...r, ref: t });
  }
);
iq.displayName = IR;
var FR = "PopoverTrigger", UR = y.forwardRef(
  (e, t) => {
    const { __scopePopover: n, ...r } = e, a = di(FR, n), i = mu(n), o = Yt(t, a.triggerRef), s = /* @__PURE__ */ N.jsx(
      ut.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": a.open,
        "aria-controls": a.contentId,
        "data-state": $R(a.open),
        ...r,
        ref: o,
        onClick: Ze(e.onClick, a.onOpenToggle)
      }
    );
    return a.hasCustomAnchor ? s : /* @__PURE__ */ N.jsx(AR, { asChild: !0, ...i, children: s });
  }
);
UR.displayName = FR;
var gb = "PopoverPortal", [oq, sq] = jR(gb, {
  forceMount: void 0
}), qR = (e) => {
  const { __scopePopover: t, forceMount: n, children: r, container: a } = e, i = di(gb, t);
  return /* @__PURE__ */ N.jsx(oq, { scope: t, forceMount: n, children: /* @__PURE__ */ N.jsx(fo, { present: n || i.open, children: /* @__PURE__ */ N.jsx(hh, { asChild: !0, container: a, children: r }) }) });
};
qR.displayName = gb;
var qs = "PopoverContent", BR = y.forwardRef(
  (e, t) => {
    const n = sq(qs, e.__scopePopover), { forceMount: r = n.forceMount, ...a } = e, i = di(qs, e.__scopePopover);
    return /* @__PURE__ */ N.jsx(fo, { present: r || i.open, children: i.modal ? /* @__PURE__ */ N.jsx(cq, { ...a, ref: t }) : /* @__PURE__ */ N.jsx(uq, { ...a, ref: t }) });
  }
);
BR.displayName = qs;
var lq = /* @__PURE__ */ jc("PopoverContent.RemoveScroll"), cq = y.forwardRef(
  (e, t) => {
    const n = di(qs, e.__scopePopover), r = y.useRef(null), a = Yt(t, r), i = y.useRef(!1);
    return y.useEffect(() => {
      const o = r.current;
      if (o) return _R(o);
    }, []), /* @__PURE__ */ N.jsx(mb, { as: lq, allowPinchZoom: !0, children: /* @__PURE__ */ N.jsx(
      VR,
      {
        ...e,
        ref: a,
        trapFocus: n.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: Ze(e.onCloseAutoFocus, (o) => {
          var s;
          o.preventDefault(), i.current || (s = n.triggerRef.current) == null || s.focus();
        }),
        onPointerDownOutside: Ze(
          e.onPointerDownOutside,
          (o) => {
            const s = o.detail.originalEvent, l = s.button === 0 && s.ctrlKey === !0, c = s.button === 2 || l;
            i.current = c;
          },
          { checkForDefaultPrevented: !1 }
        ),
        onFocusOutside: Ze(
          e.onFocusOutside,
          (o) => o.preventDefault(),
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
), uq = y.forwardRef(
  (e, t) => {
    const n = di(qs, e.__scopePopover), r = y.useRef(!1), a = y.useRef(!1);
    return /* @__PURE__ */ N.jsx(
      VR,
      {
        ...e,
        ref: t,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: (i) => {
          var o, s;
          (o = e.onCloseAutoFocus) == null || o.call(e, i), i.defaultPrevented || (r.current || (s = n.triggerRef.current) == null || s.focus(), i.preventDefault()), r.current = !1, a.current = !1;
        },
        onInteractOutside: (i) => {
          var l, c;
          (l = e.onInteractOutside) == null || l.call(e, i), i.defaultPrevented || (r.current = !0, i.detail.originalEvent.type === "pointerdown" && (a.current = !0));
          const o = i.target;
          ((c = n.triggerRef.current) == null ? void 0 : c.contains(o)) && i.preventDefault(), i.detail.originalEvent.type === "focusin" && a.current && i.preventDefault();
        }
      }
    );
  }
), VR = y.forwardRef(
  (e, t) => {
    const {
      __scopePopover: n,
      trapFocus: r,
      onOpenAutoFocus: a,
      onCloseAutoFocus: i,
      disableOutsidePointerEvents: o,
      onEscapeKeyDown: s,
      onPointerDownOutside: l,
      onFocusOutside: c,
      onInteractOutside: u,
      ...f
    } = e, d = di(qs, n), h = mu(n);
    return rR(), /* @__PURE__ */ N.jsx(
      ib,
      {
        asChild: !0,
        loop: !0,
        trapped: r,
        onMountAutoFocus: a,
        onUnmountAutoFocus: i,
        children: /* @__PURE__ */ N.jsx(
          lh,
          {
            asChild: !0,
            disableOutsidePointerEvents: o,
            onInteractOutside: u,
            onEscapeKeyDown: s,
            onPointerDownOutside: l,
            onFocusOutside: c,
            onDismiss: () => d.onOpenChange(!1),
            children: /* @__PURE__ */ N.jsx(
              fU,
              {
                "data-state": $R(d.open),
                role: "dialog",
                id: d.contentId,
                ...h,
                ...f,
                ref: t,
                style: {
                  ...f.style,
                  "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
                  "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
                  "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
                  "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
                  "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
                }
              }
            )
          }
        )
      }
    );
  }
), QR = "PopoverClose", fq = y.forwardRef(
  (e, t) => {
    const { __scopePopover: n, ...r } = e, a = di(QR, n);
    return /* @__PURE__ */ N.jsx(
      ut.button,
      {
        type: "button",
        ...r,
        ref: t,
        onClick: Ze(e.onClick, () => a.onOpenChange(!1))
      }
    );
  }
);
fq.displayName = QR;
var dq = "PopoverArrow", HR = y.forwardRef(
  (e, t) => {
    const { __scopePopover: n, ...r } = e, a = mu(n);
    return /* @__PURE__ */ N.jsx(dU, { ...a, ...r, ref: t });
  }
);
HR.displayName = dq;
function $R(e) {
  return e ? "open" : "closed";
}
var hq = PR, pq = UR, mq = qR, gq = BR, j8 = HR, OE = 1, vq = 0.9, yq = 0.8, bq = 0.17, Hp = 0.1, $p = 0.999, wq = 0.9999, xq = 0.99, Eq = /[\\\/_+.#"@\[\(\{&]/, Sq = /[\\\/_+.#"@\[\(\{&]/g, Tq = /[\s-]/, GR = /[\s-]/g;
function ev(e, t, n, r, a, i, o) {
  if (i === t.length) return a === e.length ? OE : xq;
  var s = `${a},${i}`;
  if (o[s] !== void 0) return o[s];
  for (var l = r.charAt(i), c = n.indexOf(l, a), u = 0, f, d, h, g; c >= 0; ) f = ev(e, t, n, r, c + 1, i + 1, o), f > u && (c === a ? f *= OE : Eq.test(e.charAt(c - 1)) ? (f *= yq, h = e.slice(a, c - 1).match(Sq), h && a > 0 && (f *= Math.pow($p, h.length))) : Tq.test(e.charAt(c - 1)) ? (f *= vq, g = e.slice(a, c - 1).match(GR), g && a > 0 && (f *= Math.pow($p, g.length))) : (f *= bq, a > 0 && (f *= Math.pow($p, c - a))), e.charAt(c) !== t.charAt(i) && (f *= wq)), (f < Hp && n.charAt(c - 1) === r.charAt(i + 1) || r.charAt(i + 1) === r.charAt(i) && n.charAt(c - 1) !== r.charAt(i)) && (d = ev(e, t, n, r, c + 1, i + 2, o), d * Hp > f && (f = d * Hp)), f > u && (u = f), c = n.indexOf(l, c + 1);
  return o[s] = u, u;
}
function AE(e) {
  return e.toLowerCase().replace(GR, " ");
}
function Cq(e, t, n) {
  return e = n && n.length > 0 ? `${e + " " + n.join(" ")}` : e, ev(e, t, AE(e), AE(t), 0, 0, {});
}
var gh = "Dialog", [YR] = hu(gh), [Oq, Kn] = YR(gh), KR = (e) => {
  const {
    __scopeDialog: t,
    children: n,
    open: r,
    defaultOpen: a,
    onOpenChange: i,
    modal: o = !0
  } = e, s = y.useRef(null), l = y.useRef(null), [c, u] = pb({
    prop: r,
    defaultProp: a ?? !1,
    onChange: i,
    caller: gh
  });
  return /* @__PURE__ */ N.jsx(
    Oq,
    {
      scope: t,
      triggerRef: s,
      contentRef: l,
      contentId: sr(),
      titleId: sr(),
      descriptionId: sr(),
      open: c,
      onOpenChange: u,
      onOpenToggle: y.useCallback(() => u((f) => !f), [u]),
      modal: o,
      children: n
    }
  );
};
KR.displayName = gh;
var XR = "DialogTrigger", WR = y.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, a = Kn(XR, n), i = Yt(t, a.triggerRef);
    return /* @__PURE__ */ N.jsx(
      ut.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": a.open,
        "aria-controls": a.contentId,
        "data-state": bb(a.open),
        ...r,
        ref: i,
        onClick: Ze(e.onClick, a.onOpenToggle)
      }
    );
  }
);
WR.displayName = XR;
var vb = "DialogPortal", [Aq, ZR] = YR(vb, {
  forceMount: void 0
}), JR = (e) => {
  const { __scopeDialog: t, forceMount: n, children: r, container: a } = e, i = Kn(vb, t);
  return /* @__PURE__ */ N.jsx(Aq, { scope: t, forceMount: n, children: y.Children.map(r, (o) => /* @__PURE__ */ N.jsx(fo, { present: n || i.open, children: /* @__PURE__ */ N.jsx(hh, { asChild: !0, container: a, children: o }) })) });
};
JR.displayName = vb;
var Ed = "DialogOverlay", e_ = y.forwardRef(
  (e, t) => {
    const n = ZR(Ed, e.__scopeDialog), { forceMount: r = n.forceMount, ...a } = e, i = Kn(Ed, e.__scopeDialog);
    return i.modal ? /* @__PURE__ */ N.jsx(fo, { present: r || i.open, children: /* @__PURE__ */ N.jsx(_q, { ...a, ref: t }) }) : null;
  }
);
e_.displayName = Ed;
var Rq = /* @__PURE__ */ jc("DialogOverlay.RemoveScroll"), _q = y.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, a = Kn(Ed, n);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      /* @__PURE__ */ N.jsx(mb, { as: Rq, allowPinchZoom: !0, shards: [a.contentRef], children: /* @__PURE__ */ N.jsx(
        ut.div,
        {
          "data-state": bb(a.open),
          ...r,
          ref: t,
          style: { pointerEvents: "auto", ...r.style }
        }
      ) })
    );
  }
), to = "DialogContent", t_ = y.forwardRef(
  (e, t) => {
    const n = ZR(to, e.__scopeDialog), { forceMount: r = n.forceMount, ...a } = e, i = Kn(to, e.__scopeDialog);
    return /* @__PURE__ */ N.jsx(fo, { present: r || i.open, children: i.modal ? /* @__PURE__ */ N.jsx(Dq, { ...a, ref: t }) : /* @__PURE__ */ N.jsx(Nq, { ...a, ref: t }) });
  }
);
t_.displayName = to;
var Dq = y.forwardRef(
  (e, t) => {
    const n = Kn(to, e.__scopeDialog), r = y.useRef(null), a = Yt(t, n.contentRef, r);
    return y.useEffect(() => {
      const i = r.current;
      if (i) return _R(i);
    }, []), /* @__PURE__ */ N.jsx(
      n_,
      {
        ...e,
        ref: a,
        trapFocus: n.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: Ze(e.onCloseAutoFocus, (i) => {
          var o;
          i.preventDefault(), (o = n.triggerRef.current) == null || o.focus();
        }),
        onPointerDownOutside: Ze(e.onPointerDownOutside, (i) => {
          const o = i.detail.originalEvent, s = o.button === 0 && o.ctrlKey === !0;
          (o.button === 2 || s) && i.preventDefault();
        }),
        onFocusOutside: Ze(
          e.onFocusOutside,
          (i) => i.preventDefault()
        )
      }
    );
  }
), Nq = y.forwardRef(
  (e, t) => {
    const n = Kn(to, e.__scopeDialog), r = y.useRef(!1), a = y.useRef(!1);
    return /* @__PURE__ */ N.jsx(
      n_,
      {
        ...e,
        ref: t,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: (i) => {
          var o, s;
          (o = e.onCloseAutoFocus) == null || o.call(e, i), i.defaultPrevented || (r.current || (s = n.triggerRef.current) == null || s.focus(), i.preventDefault()), r.current = !1, a.current = !1;
        },
        onInteractOutside: (i) => {
          var l, c;
          (l = e.onInteractOutside) == null || l.call(e, i), i.defaultPrevented || (r.current = !0, i.detail.originalEvent.type === "pointerdown" && (a.current = !0));
          const o = i.target;
          ((c = n.triggerRef.current) == null ? void 0 : c.contains(o)) && i.preventDefault(), i.detail.originalEvent.type === "focusin" && a.current && i.preventDefault();
        }
      }
    );
  }
), n_ = y.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, trapFocus: r, onOpenAutoFocus: a, onCloseAutoFocus: i, ...o } = e, s = Kn(to, n), l = y.useRef(null), c = Yt(t, l);
    return rR(), /* @__PURE__ */ N.jsxs(N.Fragment, { children: [
      /* @__PURE__ */ N.jsx(
        ib,
        {
          asChild: !0,
          loop: !0,
          trapped: r,
          onMountAutoFocus: a,
          onUnmountAutoFocus: i,
          children: /* @__PURE__ */ N.jsx(
            lh,
            {
              role: "dialog",
              id: s.contentId,
              "aria-describedby": s.descriptionId,
              "aria-labelledby": s.titleId,
              "data-state": bb(s.open),
              ...o,
              ref: c,
              onDismiss: () => s.onOpenChange(!1)
            }
          )
        }
      ),
      /* @__PURE__ */ N.jsxs(N.Fragment, { children: [
        /* @__PURE__ */ N.jsx(Mq, { titleId: s.titleId }),
        /* @__PURE__ */ N.jsx(zq, { contentRef: l, descriptionId: s.descriptionId })
      ] })
    ] });
  }
), yb = "DialogTitle", r_ = y.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, a = Kn(yb, n);
    return /* @__PURE__ */ N.jsx(ut.h2, { id: a.titleId, ...r, ref: t });
  }
);
r_.displayName = yb;
var a_ = "DialogDescription", i_ = y.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, a = Kn(a_, n);
    return /* @__PURE__ */ N.jsx(ut.p, { id: a.descriptionId, ...r, ref: t });
  }
);
i_.displayName = a_;
var o_ = "DialogClose", kq = y.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, a = Kn(o_, n);
    return /* @__PURE__ */ N.jsx(
      ut.button,
      {
        type: "button",
        ...r,
        ref: t,
        onClick: Ze(e.onClick, () => a.onOpenChange(!1))
      }
    );
  }
);
kq.displayName = o_;
function bb(e) {
  return e ? "open" : "closed";
}
var s_ = "DialogTitleWarning", [P8, l_] = b5(s_, {
  contentName: to,
  titleName: yb,
  docsSlug: "dialog"
}), Mq = ({ titleId: e }) => {
  const t = l_(s_), n = `\`${t.contentName}\` requires a \`${t.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${t.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${t.docsSlug}`;
  return y.useEffect(() => {
    e && (document.getElementById(e) || console.error(n));
  }, [n, e]), null;
}, Lq = "DialogDescriptionWarning", zq = ({ contentRef: e, descriptionId: t }) => {
  const r = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${l_(Lq).contentName}}.`;
  return y.useEffect(() => {
    var i;
    const a = (i = e.current) == null ? void 0 : i.getAttribute("aria-describedby");
    t && a && (document.getElementById(t) || console.warn(r));
  }, [r, e, t]), null;
}, jq = KR, I8 = WR, Pq = JR, Iq = e_, Fq = t_, F8 = r_, U8 = i_, Uq = Symbol.for("react.lazy"), Sd = wv[" use ".trim().toString()];
function qq(e) {
  return typeof e == "object" && e !== null && "then" in e;
}
function c_(e) {
  return e != null && typeof e == "object" && "$$typeof" in e && e.$$typeof === Uq && "_payload" in e && qq(e._payload);
}
// @__NO_SIDE_EFFECTS__
function Bq(e) {
  const t = /* @__PURE__ */ Vq(e), n = y.forwardRef((r, a) => {
    let { children: i, ...o } = r;
    c_(i) && typeof Sd == "function" && (i = Sd(i._payload));
    const s = y.Children.toArray(i), l = s.find(Hq);
    if (l) {
      const c = l.props.children, u = s.map((f) => f === l ? y.Children.count(c) > 1 ? y.Children.only(null) : y.isValidElement(c) ? c.props.children : null : f);
      return /* @__PURE__ */ N.jsx(t, { ...o, ref: a, children: y.isValidElement(c) ? y.cloneElement(c, void 0, u) : null });
    }
    return /* @__PURE__ */ N.jsx(t, { ...o, ref: a, children: i });
  });
  return n.displayName = `${e}.Slot`, n;
}
// @__NO_SIDE_EFFECTS__
function Vq(e) {
  const t = y.forwardRef((n, r) => {
    let { children: a, ...i } = n;
    if (c_(a) && typeof Sd == "function" && (a = Sd(a._payload)), y.isValidElement(a)) {
      const o = Gq(a), s = $q(i, a.props);
      return a.type !== y.Fragment && (s.ref = r ? ai(r, o) : o), y.cloneElement(a, s);
    }
    return y.Children.count(a) > 1 ? y.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var Qq = Symbol("radix.slottable");
function Hq(e) {
  return y.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === Qq;
}
function $q(e, t) {
  const n = { ...t };
  for (const r in t) {
    const a = e[r], i = t[r];
    /^on[A-Z]/.test(r) ? a && i ? n[r] = (...s) => {
      const l = i(...s);
      return a(...s), l;
    } : a && (n[r] = a) : r === "style" ? n[r] = { ...a, ...i } : r === "className" && (n[r] = [a, i].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function Gq(e) {
  var r, a;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (a = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : a.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var Yq = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
], hi = Yq.reduce((e, t) => {
  const n = /* @__PURE__ */ Bq(`Primitive.${t}`), r = y.forwardRef((a, i) => {
    const { asChild: o, ...s } = a, l = o ? n : t;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ N.jsx(l, { ...s, ref: i });
  });
  return r.displayName = `Primitive.${t}`, { ...e, [t]: r };
}, {}), Dl = '[cmdk-group=""]', Gp = '[cmdk-group-items=""]', Kq = '[cmdk-group-heading=""]', u_ = '[cmdk-item=""]', RE = `${u_}:not([aria-disabled="true"])`, tv = "cmdk-item-select", Do = "data-value", Xq = (e, t, n) => Cq(e, t, n), f_ = y.createContext(void 0), gu = () => y.useContext(f_), d_ = y.createContext(void 0), wb = () => y.useContext(d_), h_ = y.createContext(void 0), p_ = y.forwardRef((e, t) => {
  let n = No(() => {
    var I, G;
    return { search: "", value: (G = (I = e.value) != null ? I : e.defaultValue) != null ? G : "", selectedItemId: void 0, filtered: { count: 0, items: /* @__PURE__ */ new Map(), groups: /* @__PURE__ */ new Set() } };
  }), r = No(() => /* @__PURE__ */ new Set()), a = No(() => /* @__PURE__ */ new Map()), i = No(() => /* @__PURE__ */ new Map()), o = No(() => /* @__PURE__ */ new Set()), s = v_(e), { label: l, children: c, value: u, onValueChange: f, filter: d, shouldFilter: h, loop: g, disablePointerSelection: v = !1, vimBindings: b = !0, ...p } = e, m = sr(), w = sr(), x = sr(), S = y.useRef(null), T = o4();
  no(() => {
    if (u !== void 0) {
      let I = u.trim();
      n.current.value = I, E.emit();
    }
  }, [u]), no(() => {
    T(6, q);
  }, []);
  let E = y.useMemo(() => ({ subscribe: (I) => (o.current.add(I), () => o.current.delete(I)), snapshot: () => n.current, setState: (I, G, ee) => {
    var J, we, Se, Tt;
    if (!Object.is(n.current[I], G)) {
      if (n.current[I] = G, I === "search") R(), A(), T(1, U);
      else if (I === "value") {
        if (document.activeElement.hasAttribute("cmdk-input") || document.activeElement.hasAttribute("cmdk-root")) {
          let ft = document.getElementById(x);
          ft ? ft.focus() : (J = document.getElementById(m)) == null || J.focus();
        }
        if (T(7, () => {
          var ft;
          n.current.selectedItemId = (ft = z()) == null ? void 0 : ft.id, E.emit();
        }), ee || T(5, q), ((we = s.current) == null ? void 0 : we.value) !== void 0) {
          let ft = G ?? "";
          (Tt = (Se = s.current).onValueChange) == null || Tt.call(Se, ft);
          return;
        }
      }
      E.emit();
    }
  }, emit: () => {
    o.current.forEach((I) => I());
  } }), []), O = y.useMemo(() => ({ value: (I, G, ee) => {
    var J;
    G !== ((J = i.current.get(I)) == null ? void 0 : J.value) && (i.current.set(I, { value: G, keywords: ee }), n.current.filtered.items.set(I, D(G, ee)), T(2, () => {
      A(), E.emit();
    }));
  }, item: (I, G) => (r.current.add(I), G && (a.current.has(G) ? a.current.get(G).add(I) : a.current.set(G, /* @__PURE__ */ new Set([I]))), T(3, () => {
    R(), A(), n.current.value || U(), E.emit();
  }), () => {
    i.current.delete(I), r.current.delete(I), n.current.filtered.items.delete(I);
    let ee = z();
    T(4, () => {
      R(), (ee == null ? void 0 : ee.getAttribute("id")) === I && U(), E.emit();
    });
  }), group: (I) => (a.current.has(I) || a.current.set(I, /* @__PURE__ */ new Set()), () => {
    i.current.delete(I), a.current.delete(I);
  }), filter: () => s.current.shouldFilter, label: l || e["aria-label"], getDisablePointerSelection: () => s.current.disablePointerSelection, listId: m, inputId: x, labelId: w, listInnerRef: S }), []);
  function D(I, G) {
    var ee, J;
    let we = (J = (ee = s.current) == null ? void 0 : ee.filter) != null ? J : Xq;
    return I ? we(I, n.current.search, G) : 0;
  }
  function A() {
    if (!n.current.search || s.current.shouldFilter === !1) return;
    let I = n.current.filtered.items, G = [];
    n.current.filtered.groups.forEach((J) => {
      let we = a.current.get(J), Se = 0;
      we.forEach((Tt) => {
        let ft = I.get(Tt);
        Se = Math.max(ft, Se);
      }), G.push([J, Se]);
    });
    let ee = S.current;
    Q().sort((J, we) => {
      var Se, Tt;
      let ft = J.getAttribute("id"), yr = we.getAttribute("id");
      return ((Se = I.get(yr)) != null ? Se : 0) - ((Tt = I.get(ft)) != null ? Tt : 0);
    }).forEach((J) => {
      let we = J.closest(Gp);
      we ? we.appendChild(J.parentElement === we ? J : J.closest(`${Gp} > *`)) : ee.appendChild(J.parentElement === ee ? J : J.closest(`${Gp} > *`));
    }), G.sort((J, we) => we[1] - J[1]).forEach((J) => {
      var we;
      let Se = (we = S.current) == null ? void 0 : we.querySelector(`${Dl}[${Do}="${encodeURIComponent(J[0])}"]`);
      Se == null || Se.parentElement.appendChild(Se);
    });
  }
  function U() {
    let I = Q().find((ee) => ee.getAttribute("aria-disabled") !== "true"), G = I == null ? void 0 : I.getAttribute(Do);
    E.setState("value", G || void 0);
  }
  function R() {
    var I, G, ee, J;
    if (!n.current.search || s.current.shouldFilter === !1) {
      n.current.filtered.count = r.current.size;
      return;
    }
    n.current.filtered.groups = /* @__PURE__ */ new Set();
    let we = 0;
    for (let Se of r.current) {
      let Tt = (G = (I = i.current.get(Se)) == null ? void 0 : I.value) != null ? G : "", ft = (J = (ee = i.current.get(Se)) == null ? void 0 : ee.keywords) != null ? J : [], yr = D(Tt, ft);
      n.current.filtered.items.set(Se, yr), yr > 0 && we++;
    }
    for (let [Se, Tt] of a.current) for (let ft of Tt) if (n.current.filtered.items.get(ft) > 0) {
      n.current.filtered.groups.add(Se);
      break;
    }
    n.current.filtered.count = we;
  }
  function q() {
    var I, G, ee;
    let J = z();
    J && (((I = J.parentElement) == null ? void 0 : I.firstChild) === J && ((ee = (G = J.closest(Dl)) == null ? void 0 : G.querySelector(Kq)) == null || ee.scrollIntoView({ block: "nearest" })), J.scrollIntoView({ block: "nearest" }));
  }
  function z() {
    var I;
    return (I = S.current) == null ? void 0 : I.querySelector(`${u_}[aria-selected="true"]`);
  }
  function Q() {
    var I;
    return Array.from(((I = S.current) == null ? void 0 : I.querySelectorAll(RE)) || []);
  }
  function k(I) {
    let G = Q()[I];
    G && E.setState("value", G.getAttribute(Do));
  }
  function P(I) {
    var G;
    let ee = z(), J = Q(), we = J.findIndex((Tt) => Tt === ee), Se = J[we + I];
    (G = s.current) != null && G.loop && (Se = we + I < 0 ? J[J.length - 1] : we + I === J.length ? J[0] : J[we + I]), Se && E.setState("value", Se.getAttribute(Do));
  }
  function F(I) {
    let G = z(), ee = G == null ? void 0 : G.closest(Dl), J;
    for (; ee && !J; ) ee = I > 0 ? a4(ee, Dl) : i4(ee, Dl), J = ee == null ? void 0 : ee.querySelector(RE);
    J ? E.setState("value", J.getAttribute(Do)) : P(I);
  }
  let H = () => k(Q().length - 1), K = (I) => {
    I.preventDefault(), I.metaKey ? H() : I.altKey ? F(1) : P(1);
  }, Z = (I) => {
    I.preventDefault(), I.metaKey ? k(0) : I.altKey ? F(-1) : P(-1);
  };
  return y.createElement(hi.div, { ref: t, tabIndex: -1, ...p, "cmdk-root": "", onKeyDown: (I) => {
    var G;
    (G = p.onKeyDown) == null || G.call(p, I);
    let ee = I.nativeEvent.isComposing || I.keyCode === 229;
    if (!(I.defaultPrevented || ee)) switch (I.key) {
      case "n":
      case "j": {
        b && I.ctrlKey && K(I);
        break;
      }
      case "ArrowDown": {
        K(I);
        break;
      }
      case "p":
      case "k": {
        b && I.ctrlKey && Z(I);
        break;
      }
      case "ArrowUp": {
        Z(I);
        break;
      }
      case "Home": {
        I.preventDefault(), k(0);
        break;
      }
      case "End": {
        I.preventDefault(), H();
        break;
      }
      case "Enter": {
        I.preventDefault();
        let J = z();
        if (J) {
          let we = new Event(tv);
          J.dispatchEvent(we);
        }
      }
    }
  } }, y.createElement("label", { "cmdk-label": "", htmlFor: O.inputId, id: O.labelId, style: l4 }, l), vh(e, (I) => y.createElement(d_.Provider, { value: E }, y.createElement(f_.Provider, { value: O }, I))));
}), m_ = y.forwardRef((e, t) => {
  var n, r;
  let a = sr(), i = y.useRef(null), o = y.useContext(h_), s = gu(), l = v_(e), c = (r = (n = l.current) == null ? void 0 : n.forceMount) != null ? r : o == null ? void 0 : o.forceMount;
  no(() => {
    if (!c) return s.item(a, o == null ? void 0 : o.id);
  }, [c]);
  let u = y_(a, i, [e.value, e.children, i], e.keywords), f = wb(), d = si((T) => T.value && T.value === u.current), h = si((T) => c || s.filter() === !1 ? !0 : T.search ? T.filtered.items.get(a) > 0 : !0);
  y.useEffect(() => {
    let T = i.current;
    if (!(!T || e.disabled)) return T.addEventListener(tv, g), () => T.removeEventListener(tv, g);
  }, [h, e.onSelect, e.disabled]);
  function g() {
    var T, E;
    v(), (E = (T = l.current).onSelect) == null || E.call(T, u.current);
  }
  function v() {
    f.setState("value", u.current, !0);
  }
  if (!h) return null;
  let { disabled: b, value: p, onSelect: m, forceMount: w, keywords: x, ...S } = e;
  return y.createElement(hi.div, { ref: ai(i, t), ...S, id: a, "cmdk-item": "", role: "option", "aria-disabled": !!b, "aria-selected": !!d, "data-disabled": !!b, "data-selected": !!d, onPointerMove: b || s.getDisablePointerSelection() ? void 0 : v, onClick: b ? void 0 : g }, e.children);
}), g_ = y.forwardRef((e, t) => {
  let { heading: n, children: r, forceMount: a, ...i } = e, o = sr(), s = y.useRef(null), l = y.useRef(null), c = sr(), u = gu(), f = si((h) => a || u.filter() === !1 ? !0 : h.search ? h.filtered.groups.has(o) : !0);
  no(() => u.group(o), []), y_(o, s, [e.value, e.heading, l]);
  let d = y.useMemo(() => ({ id: o, forceMount: a }), [a]);
  return y.createElement(hi.div, { ref: ai(s, t), ...i, "cmdk-group": "", role: "presentation", hidden: f ? void 0 : !0 }, n && y.createElement("div", { ref: l, "cmdk-group-heading": "", "aria-hidden": !0, id: c }, n), vh(e, (h) => y.createElement("div", { "cmdk-group-items": "", role: "group", "aria-labelledby": n ? c : void 0 }, y.createElement(h_.Provider, { value: d }, h))));
}), Wq = y.forwardRef((e, t) => {
  let { alwaysRender: n, ...r } = e, a = y.useRef(null), i = si((o) => !o.search);
  return !n && !i ? null : y.createElement(hi.div, { ref: ai(a, t), ...r, "cmdk-separator": "", role: "separator" });
}), Zq = y.forwardRef((e, t) => {
  let { onValueChange: n, ...r } = e, a = e.value != null, i = wb(), o = si((c) => c.search), s = si((c) => c.selectedItemId), l = gu();
  return y.useEffect(() => {
    e.value != null && i.setState("search", e.value);
  }, [e.value]), y.createElement(hi.input, { ref: t, ...r, "cmdk-input": "", autoComplete: "off", autoCorrect: "off", spellCheck: !1, "aria-autocomplete": "list", role: "combobox", "aria-expanded": !0, "aria-controls": l.listId, "aria-labelledby": l.labelId, "aria-activedescendant": s, id: l.inputId, type: "text", value: a ? e.value : o, onChange: (c) => {
    a || i.setState("search", c.target.value), n == null || n(c.target.value);
  } });
}), Jq = y.forwardRef((e, t) => {
  let { children: n, label: r = "Suggestions", ...a } = e, i = y.useRef(null), o = y.useRef(null), s = si((c) => c.selectedItemId), l = gu();
  return y.useEffect(() => {
    if (o.current && i.current) {
      let c = o.current, u = i.current, f, d = new ResizeObserver(() => {
        f = requestAnimationFrame(() => {
          let h = c.offsetHeight;
          u.style.setProperty("--cmdk-list-height", h.toFixed(1) + "px");
        });
      });
      return d.observe(c), () => {
        cancelAnimationFrame(f), d.unobserve(c);
      };
    }
  }, []), y.createElement(hi.div, { ref: ai(i, t), ...a, "cmdk-list": "", role: "listbox", tabIndex: -1, "aria-activedescendant": s, "aria-label": r, id: l.listId }, vh(e, (c) => y.createElement("div", { ref: ai(o, l.listInnerRef), "cmdk-list-sizer": "" }, c)));
}), e4 = y.forwardRef((e, t) => {
  let { open: n, onOpenChange: r, overlayClassName: a, contentClassName: i, container: o, ...s } = e;
  return y.createElement(jq, { open: n, onOpenChange: r }, y.createElement(Pq, { container: o }, y.createElement(Iq, { "cmdk-overlay": "", className: a }), y.createElement(Fq, { "aria-label": e.label, "cmdk-dialog": "", className: i }, y.createElement(p_, { ref: t, ...s }))));
}), t4 = y.forwardRef((e, t) => si((n) => n.filtered.count === 0) ? y.createElement(hi.div, { ref: t, ...e, "cmdk-empty": "", role: "presentation" }) : null), n4 = y.forwardRef((e, t) => {
  let { progress: n, children: r, label: a = "Loading...", ...i } = e;
  return y.createElement(hi.div, { ref: t, ...i, "cmdk-loading": "", role: "progressbar", "aria-valuenow": n, "aria-valuemin": 0, "aria-valuemax": 100, "aria-label": a }, vh(e, (o) => y.createElement("div", { "aria-hidden": !0 }, o)));
}), r4 = Object.assign(p_, { List: Jq, Item: m_, Input: Zq, Group: g_, Separator: Wq, Dialog: e4, Empty: t4, Loading: n4 });
function a4(e, t) {
  let n = e.nextElementSibling;
  for (; n; ) {
    if (n.matches(t)) return n;
    n = n.nextElementSibling;
  }
}
function i4(e, t) {
  let n = e.previousElementSibling;
  for (; n; ) {
    if (n.matches(t)) return n;
    n = n.previousElementSibling;
  }
}
function v_(e) {
  let t = y.useRef(e);
  return no(() => {
    t.current = e;
  }), t;
}
var no = typeof window > "u" ? y.useEffect : y.useLayoutEffect;
function No(e) {
  let t = y.useRef();
  return t.current === void 0 && (t.current = e()), t;
}
function si(e) {
  let t = wb(), n = () => e(t.snapshot());
  return y.useSyncExternalStore(t.subscribe, n, n);
}
function y_(e, t, n, r = []) {
  let a = y.useRef(), i = gu();
  return no(() => {
    var o;
    let s = (() => {
      var c;
      for (let u of n) {
        if (typeof u == "string") return u.trim();
        if (typeof u == "object" && "current" in u) return u.current ? (c = u.current.textContent) == null ? void 0 : c.trim() : a.current;
      }
    })(), l = r.map((c) => c.trim());
    i.value(e, s, l), (o = t.current) == null || o.setAttribute(Do, s), a.current = s;
  }), a;
}
var o4 = () => {
  let [e, t] = y.useState(), n = No(() => /* @__PURE__ */ new Map());
  return no(() => {
    n.current.forEach((r) => r()), n.current = /* @__PURE__ */ new Map();
  }, [e]), (r, a) => {
    n.current.set(r, a), t({});
  };
};
function s4(e) {
  let t = e.type;
  return typeof t == "function" ? t(e.props) : "render" in t ? t.render(e.props) : e;
}
function vh({ asChild: e, children: t }, n) {
  return e && y.isValidElement(t) ? y.cloneElement(s4(t), { ref: t.ref }, n(t.props.children)) : n(t);
}
var l4 = { position: "absolute", width: "1px", height: "1px", padding: "0", margin: "-1px", overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", borderWidth: "0" }, Di = /* @__PURE__ */ ((e) => (e.Top = "top", e.Bottom = "bottom", e.Left = "left", e.Right = "right", e))(Di || {}), xb = /* @__PURE__ */ ((e) => (e.Start = "start", e.Center = "center", e.End = "end", e))(xb || {}), yh = /* @__PURE__ */ ((e) => (e.List = "list", e.Content = "content", e))(yh || {}), b_ = /* @__PURE__ */ ((e) => (e.Default = "default", e.BottomEnd = "bottom-end", e.TopEnd = "top-end", e))(b_ || {});
const w_ = 8, c4 = Di.Bottom, u4 = xb.End, f4 = yh.List;
b_.Default;
const x_ = du({
  slots: {
    title: "text-sm text-white",
    groupContent: "flex flex-col gap-1.25",
    container: "bg-drawer rounded-lg px-2.5 py-5",
    item: "h-10 w-full p-2.5 hover:bg-list-active cursor-pointer flex items-center rounded-lg gap-2.5 active:scale-95 transition-all duration-300 ease-in-out",
    popoverContent: at(
      "z-[400] outline-0 rounded-xl bg-drawer",
      "data-[state=open]:animate-in data-[state=open]:fade-in-0 data-[state=open]:zoom-in-95",
      "data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95",
      "shadow-lg drawer-shadow",
      "min-w-[11.25rem]"
    ),
    command: "",
    endAdornmentWrapper: "ml-auto",
    disabledItem: "opacity-50 cursor-not-allowed",
    iconBase: "text-white"
  },
  variants: {
    side: {
      [Di.Top]: {
        popoverContent: "data-[side=top]:slide-in-from-bottom-2"
      },
      [Di.Bottom]: {
        popoverContent: "data-[side=bottom]:slide-in-from-top-2"
      },
      [Di.Left]: {
        popoverContent: "data-[side=left]:slide-in-from-right-2"
      },
      [Di.Right]: {
        popoverContent: "data-[side=right]:slide-in-from-left-2"
      }
    }
  }
});
function d4(e, t, n) {
  const [r, a] = y.useState(!1), i = t ? e ?? !1 : r, o = y.useCallback(
    (s) => {
      t || a(s), n == null || n(s);
    },
    [t, n]
  );
  return {
    open: i,
    handleOpenChange: o
  };
}
const E_ = y.forwardRef(
  ({
    className: e,
    children: t,
    sideOffset: n,
    container: r,
    contentStyle: a,
    ...i
  }, o) => {
    const { popoverContent: s } = x_({});
    return /* @__PURE__ */ N.jsx(mq, { container: r, children: /* @__PURE__ */ N.jsx(
      gq,
      {
        ...i,
        ref: o,
        className: at(s(), e),
        style: a,
        sideOffset: n ?? w_,
        children: t
      }
    ) });
  }
);
E_.displayName = "DropdownMenuPopoverContent";
const S_ = ({
  side: e = c4,
  align: t = u4,
  open: n,
  options: r,
  content: a,
  children: i,
  className: o,
  sideOffset: s = w_,
  type: l = f4,
  contentClassName: c,
  contentStyle: u,
  handleOpenChange: f,
  controlled: d = !1,
  container: h,
  ...g
}) => {
  const {
    container: v,
    groupContent: b,
    item: p,
    title: m,
    command: w,
    popoverContent: x,
    endAdornmentWrapper: S,
    disabledItem: T,
    iconBase: E
  } = x_({ side: e }), { open: O, handleOpenChange: D } = d4(
    n,
    d,
    f
  ), A = (R) => R.loading ? /* @__PURE__ */ N.jsx(
    ab,
    {
      isLoading: !0,
      variant: Qt.Spinner,
      size: tn.Small
    }
  ) : R.hideIcon ? null : /* @__PURE__ */ N.jsx(
    Fs,
    {
      name: R.icon,
      className: at(E(), R.iconClassName)
    }
  ), U = l === yh.List ? /* @__PURE__ */ N.jsx(g_, { className: at(b()), children: r == null ? void 0 : r.map((R) => /* @__PURE__ */ N.jsxs(
    m_,
    {
      onSelect: () => R.onClick(),
      className: at(
        p(),
        R.className,
        R.loading && T()
      ),
      disabled: R.loading,
      children: [
        A(R),
        /* @__PURE__ */ N.jsx("div", { className: at(m(), R.titleClassName), children: R.title }),
        R.endAdornment && /* @__PURE__ */ N.jsx("div", { className: S(), children: R.endAdornment })
      ]
    },
    R.id
  )) }) : a;
  return /* @__PURE__ */ N.jsxs(hq, { open: O, onOpenChange: D, ...g, children: [
    /* @__PURE__ */ N.jsx(pq, { asChild: !0, children: i }),
    /* @__PURE__ */ N.jsx(
      E_,
      {
        side: e,
        align: t,
        sideOffset: s,
        className: at(x(), c),
        contentStyle: u,
        container: h,
        children: /* @__PURE__ */ N.jsx(r4, { className: at(w(), v(), o), children: U })
      }
    )
  ] });
};
S_.displayName = "DropdownMenu";
function h4(e) {
  const t = e + "CollectionProvider", [n, r] = hu(t), [a, i] = n(
    t,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  ), o = (v) => {
    const { scope: b, children: p } = v, m = cn.useRef(null), w = cn.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ N.jsx(a, { scope: b, itemMap: w, collectionRef: m, children: p });
  };
  o.displayName = t;
  const s = e + "CollectionSlot", l = /* @__PURE__ */ jc(s), c = cn.forwardRef(
    (v, b) => {
      const { scope: p, children: m } = v, w = i(s, p), x = Yt(b, w.collectionRef);
      return /* @__PURE__ */ N.jsx(l, { ref: x, children: m });
    }
  );
  c.displayName = s;
  const u = e + "CollectionItemSlot", f = "data-radix-collection-item", d = /* @__PURE__ */ jc(u), h = cn.forwardRef(
    (v, b) => {
      const { scope: p, children: m, ...w } = v, x = cn.useRef(null), S = Yt(b, x), T = i(u, p);
      return cn.useEffect(() => (T.itemMap.set(x, { ref: x, ...w }), () => void T.itemMap.delete(x))), /* @__PURE__ */ N.jsx(d, { [f]: "", ref: S, children: m });
    }
  );
  h.displayName = u;
  function g(v) {
    const b = i(e + "CollectionConsumer", v);
    return cn.useCallback(() => {
      const m = b.collectionRef.current;
      if (!m) return [];
      const w = Array.from(m.querySelectorAll(`[${f}]`));
      return Array.from(b.itemMap.values()).sort(
        (T, E) => w.indexOf(T.ref.current) - w.indexOf(E.ref.current)
      );
    }, [b.collectionRef, b.itemMap]);
  }
  return [
    { Provider: o, Slot: c, ItemSlot: h },
    g,
    r
  ];
}
var p4 = Object.freeze({
  // See: https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss
  position: "absolute",
  border: 0,
  width: 1,
  height: 1,
  padding: 0,
  margin: -1,
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  wordWrap: "normal"
}), m4 = "VisuallyHidden", Eb = y.forwardRef(
  (e, t) => /* @__PURE__ */ N.jsx(
    ut.span,
    {
      ...e,
      ref: t,
      style: { ...p4, ...e.style }
    }
  )
);
Eb.displayName = m4;
var Sb = "ToastProvider", [Tb, g4, v4] = h4("Toast"), [T_] = hu("Toast", [v4]), [y4, bh] = T_(Sb), C_ = (e) => {
  const {
    __scopeToast: t,
    label: n = "Notification",
    duration: r = 5e3,
    swipeDirection: a = "right",
    swipeThreshold: i = 50,
    children: o
  } = e, [s, l] = y.useState(null), [c, u] = y.useState(0), f = y.useRef(!1), d = y.useRef(!1);
  return n.trim() || console.error(
    `Invalid prop \`label\` supplied to \`${Sb}\`. Expected non-empty \`string\`.`
  ), /* @__PURE__ */ N.jsx(Tb.Provider, { scope: t, children: /* @__PURE__ */ N.jsx(
    y4,
    {
      scope: t,
      label: n,
      duration: r,
      swipeDirection: a,
      swipeThreshold: i,
      toastCount: c,
      viewport: s,
      onViewportChange: l,
      onToastAdd: y.useCallback(() => u((h) => h + 1), []),
      onToastRemove: y.useCallback(() => u((h) => h - 1), []),
      isFocusedToastEscapeKeyDownRef: f,
      isClosePausedRef: d,
      children: o
    }
  ) });
};
C_.displayName = Sb;
var O_ = "ToastViewport", b4 = ["F8"], nv = "toast.viewportPause", rv = "toast.viewportResume", A_ = y.forwardRef(
  (e, t) => {
    const {
      __scopeToast: n,
      hotkey: r = b4,
      label: a = "Notifications ({hotkey})",
      ...i
    } = e, o = bh(O_, n), s = g4(n), l = y.useRef(null), c = y.useRef(null), u = y.useRef(null), f = y.useRef(null), d = Yt(t, f, o.onViewportChange), h = r.join("+").replace(/Key/g, "").replace(/Digit/g, ""), g = o.toastCount > 0;
    y.useEffect(() => {
      const b = (p) => {
        var w;
        r.length !== 0 && r.every((x) => p[x] || p.code === x) && ((w = f.current) == null || w.focus());
      };
      return document.addEventListener("keydown", b), () => document.removeEventListener("keydown", b);
    }, [r]), y.useEffect(() => {
      const b = l.current, p = f.current;
      if (g && b && p) {
        const m = () => {
          if (!o.isClosePausedRef.current) {
            const T = new CustomEvent(nv);
            p.dispatchEvent(T), o.isClosePausedRef.current = !0;
          }
        }, w = () => {
          if (o.isClosePausedRef.current) {
            const T = new CustomEvent(rv);
            p.dispatchEvent(T), o.isClosePausedRef.current = !1;
          }
        }, x = (T) => {
          !b.contains(T.relatedTarget) && w();
        }, S = () => {
          b.contains(document.activeElement) || w();
        };
        return b.addEventListener("focusin", m), b.addEventListener("focusout", x), b.addEventListener("pointermove", m), b.addEventListener("pointerleave", S), window.addEventListener("blur", m), window.addEventListener("focus", w), () => {
          b.removeEventListener("focusin", m), b.removeEventListener("focusout", x), b.removeEventListener("pointermove", m), b.removeEventListener("pointerleave", S), window.removeEventListener("blur", m), window.removeEventListener("focus", w);
        };
      }
    }, [g, o.isClosePausedRef]);
    const v = y.useCallback(
      ({ tabbingDirection: b }) => {
        const m = s().map((w) => {
          const x = w.ref.current, S = [x, ...M4(x)];
          return b === "forwards" ? S : S.reverse();
        });
        return (b === "forwards" ? m.reverse() : m).flat();
      },
      [s]
    );
    return y.useEffect(() => {
      const b = f.current;
      if (b) {
        const p = (m) => {
          var S, T, E;
          const w = m.altKey || m.ctrlKey || m.metaKey;
          if (m.key === "Tab" && !w) {
            const O = document.activeElement, D = m.shiftKey;
            if (m.target === b && D) {
              (S = c.current) == null || S.focus();
              return;
            }
            const R = v({ tabbingDirection: D ? "backwards" : "forwards" }), q = R.findIndex((z) => z === O);
            Yp(R.slice(q + 1)) ? m.preventDefault() : D ? (T = c.current) == null || T.focus() : (E = u.current) == null || E.focus();
          }
        };
        return b.addEventListener("keydown", p), () => b.removeEventListener("keydown", p);
      }
    }, [s, v]), /* @__PURE__ */ N.jsxs(
      z5,
      {
        ref: l,
        role: "region",
        "aria-label": a.replace("{hotkey}", h),
        tabIndex: -1,
        style: { pointerEvents: g ? void 0 : "none" },
        children: [
          g && /* @__PURE__ */ N.jsx(
            av,
            {
              ref: c,
              onFocusFromOutsideViewport: () => {
                const b = v({
                  tabbingDirection: "forwards"
                });
                Yp(b);
              }
            }
          ),
          /* @__PURE__ */ N.jsx(Tb.Slot, { scope: n, children: /* @__PURE__ */ N.jsx(ut.ol, { tabIndex: -1, ...i, ref: d }) }),
          g && /* @__PURE__ */ N.jsx(
            av,
            {
              ref: u,
              onFocusFromOutsideViewport: () => {
                const b = v({
                  tabbingDirection: "backwards"
                });
                Yp(b);
              }
            }
          )
        ]
      }
    );
  }
);
A_.displayName = O_;
var R_ = "ToastFocusProxy", av = y.forwardRef(
  (e, t) => {
    const { __scopeToast: n, onFocusFromOutsideViewport: r, ...a } = e, i = bh(R_, n);
    return /* @__PURE__ */ N.jsx(
      Eb,
      {
        tabIndex: 0,
        ...a,
        ref: t,
        style: { position: "fixed" },
        onFocus: (o) => {
          var c;
          const s = o.relatedTarget;
          !((c = i.viewport) != null && c.contains(s)) && r();
        }
      }
    );
  }
);
av.displayName = R_;
var vu = "Toast", w4 = "toast.swipeStart", x4 = "toast.swipeMove", E4 = "toast.swipeCancel", S4 = "toast.swipeEnd", __ = y.forwardRef(
  (e, t) => {
    const { forceMount: n, open: r, defaultOpen: a, onOpenChange: i, ...o } = e, [s, l] = pb({
      prop: r,
      defaultProp: a ?? !0,
      onChange: i,
      caller: vu
    });
    return /* @__PURE__ */ N.jsx(fo, { present: n || s, children: /* @__PURE__ */ N.jsx(
      O4,
      {
        open: s,
        ...o,
        ref: t,
        onClose: () => l(!1),
        onPause: fr(e.onPause),
        onResume: fr(e.onResume),
        onSwipeStart: Ze(e.onSwipeStart, (c) => {
          c.currentTarget.setAttribute("data-swipe", "start");
        }),
        onSwipeMove: Ze(e.onSwipeMove, (c) => {
          const { x: u, y: f } = c.detail.delta;
          c.currentTarget.setAttribute("data-swipe", "move"), c.currentTarget.style.setProperty("--radix-toast-swipe-move-x", `${u}px`), c.currentTarget.style.setProperty("--radix-toast-swipe-move-y", `${f}px`);
        }),
        onSwipeCancel: Ze(e.onSwipeCancel, (c) => {
          c.currentTarget.setAttribute("data-swipe", "cancel"), c.currentTarget.style.removeProperty("--radix-toast-swipe-move-x"), c.currentTarget.style.removeProperty("--radix-toast-swipe-move-y"), c.currentTarget.style.removeProperty("--radix-toast-swipe-end-x"), c.currentTarget.style.removeProperty("--radix-toast-swipe-end-y");
        }),
        onSwipeEnd: Ze(e.onSwipeEnd, (c) => {
          const { x: u, y: f } = c.detail.delta;
          c.currentTarget.setAttribute("data-swipe", "end"), c.currentTarget.style.removeProperty("--radix-toast-swipe-move-x"), c.currentTarget.style.removeProperty("--radix-toast-swipe-move-y"), c.currentTarget.style.setProperty("--radix-toast-swipe-end-x", `${u}px`), c.currentTarget.style.setProperty("--radix-toast-swipe-end-y", `${f}px`), l(!1);
        })
      }
    ) });
  }
);
__.displayName = vu;
var [T4, C4] = T_(vu, {
  onClose() {
  }
}), O4 = y.forwardRef(
  (e, t) => {
    const {
      __scopeToast: n,
      type: r = "foreground",
      duration: a,
      open: i,
      onClose: o,
      onEscapeKeyDown: s,
      onPause: l,
      onResume: c,
      onSwipeStart: u,
      onSwipeMove: f,
      onSwipeCancel: d,
      onSwipeEnd: h,
      ...g
    } = e, v = bh(vu, n), [b, p] = y.useState(null), m = Yt(t, (z) => p(z)), w = y.useRef(null), x = y.useRef(null), S = a || v.duration, T = y.useRef(0), E = y.useRef(S), O = y.useRef(0), { onToastAdd: D, onToastRemove: A } = v, U = fr(() => {
      var Q;
      (b == null ? void 0 : b.contains(document.activeElement)) && ((Q = v.viewport) == null || Q.focus()), o();
    }), R = y.useCallback(
      (z) => {
        !z || z === 1 / 0 || (window.clearTimeout(O.current), T.current = (/* @__PURE__ */ new Date()).getTime(), O.current = window.setTimeout(U, z));
      },
      [U]
    );
    y.useEffect(() => {
      const z = v.viewport;
      if (z) {
        const Q = () => {
          R(E.current), c == null || c();
        }, k = () => {
          const P = (/* @__PURE__ */ new Date()).getTime() - T.current;
          E.current = E.current - P, window.clearTimeout(O.current), l == null || l();
        };
        return z.addEventListener(nv, k), z.addEventListener(rv, Q), () => {
          z.removeEventListener(nv, k), z.removeEventListener(rv, Q);
        };
      }
    }, [v.viewport, S, l, c, R]), y.useEffect(() => {
      i && !v.isClosePausedRef.current && R(S);
    }, [i, S, v.isClosePausedRef, R]), y.useEffect(() => (D(), () => A()), [D, A]);
    const q = y.useMemo(() => b ? z_(b) : null, [b]);
    return v.viewport ? /* @__PURE__ */ N.jsxs(N.Fragment, { children: [
      q && /* @__PURE__ */ N.jsx(
        A4,
        {
          __scopeToast: n,
          role: "status",
          "aria-live": r === "foreground" ? "assertive" : "polite",
          children: q
        }
      ),
      /* @__PURE__ */ N.jsx(T4, { scope: n, onClose: U, children: Gc.createPortal(
        /* @__PURE__ */ N.jsx(Tb.ItemSlot, { scope: n, children: /* @__PURE__ */ N.jsx(
          L5,
          {
            asChild: !0,
            onEscapeKeyDown: Ze(s, () => {
              v.isFocusedToastEscapeKeyDownRef.current || U(), v.isFocusedToastEscapeKeyDownRef.current = !1;
            }),
            children: /* @__PURE__ */ N.jsx(
              ut.li,
              {
                tabIndex: 0,
                "data-state": i ? "open" : "closed",
                "data-swipe-direction": v.swipeDirection,
                ...g,
                ref: m,
                style: { userSelect: "none", touchAction: "none", ...e.style },
                onKeyDown: Ze(e.onKeyDown, (z) => {
                  z.key === "Escape" && (s == null || s(z.nativeEvent), z.nativeEvent.defaultPrevented || (v.isFocusedToastEscapeKeyDownRef.current = !0, U()));
                }),
                onPointerDown: Ze(e.onPointerDown, (z) => {
                  z.button === 0 && (w.current = { x: z.clientX, y: z.clientY });
                }),
                onPointerMove: Ze(e.onPointerMove, (z) => {
                  if (!w.current) return;
                  const Q = z.clientX - w.current.x, k = z.clientY - w.current.y, P = !!x.current, F = ["left", "right"].includes(v.swipeDirection), H = ["left", "up"].includes(v.swipeDirection) ? Math.min : Math.max, K = F ? H(0, Q) : 0, Z = F ? 0 : H(0, k), I = z.pointerType === "touch" ? 10 : 2, G = { x: K, y: Z }, ee = { originalEvent: z, delta: G };
                  P ? (x.current = G, rf(x4, f, ee, {
                    discrete: !1
                  })) : _E(G, v.swipeDirection, I) ? (x.current = G, rf(w4, u, ee, {
                    discrete: !1
                  }), z.target.setPointerCapture(z.pointerId)) : (Math.abs(Q) > I || Math.abs(k) > I) && (w.current = null);
                }),
                onPointerUp: Ze(e.onPointerUp, (z) => {
                  const Q = x.current, k = z.target;
                  if (k.hasPointerCapture(z.pointerId) && k.releasePointerCapture(z.pointerId), x.current = null, w.current = null, Q) {
                    const P = z.currentTarget, F = { originalEvent: z, delta: Q };
                    _E(Q, v.swipeDirection, v.swipeThreshold) ? rf(S4, h, F, {
                      discrete: !0
                    }) : rf(
                      E4,
                      d,
                      F,
                      {
                        discrete: !0
                      }
                    ), P.addEventListener("click", (H) => H.preventDefault(), {
                      once: !0
                    });
                  }
                })
              }
            )
          }
        ) }),
        v.viewport
      ) })
    ] }) : null;
  }
), A4 = (e) => {
  const { __scopeToast: t, children: n, ...r } = e, a = bh(vu, t), [i, o] = y.useState(!1), [s, l] = y.useState(!1);
  return N4(() => o(!0)), y.useEffect(() => {
    const c = window.setTimeout(() => l(!0), 1e3);
    return () => window.clearTimeout(c);
  }, []), s ? null : /* @__PURE__ */ N.jsx(hh, { asChild: !0, children: /* @__PURE__ */ N.jsx(Eb, { ...r, children: i && /* @__PURE__ */ N.jsxs(N.Fragment, { children: [
    a.label,
    " ",
    n
  ] }) }) });
}, R4 = "ToastTitle", D_ = y.forwardRef(
  (e, t) => {
    const { __scopeToast: n, ...r } = e;
    return /* @__PURE__ */ N.jsx(ut.div, { ...r, ref: t });
  }
);
D_.displayName = R4;
var _4 = "ToastDescription", N_ = y.forwardRef(
  (e, t) => {
    const { __scopeToast: n, ...r } = e;
    return /* @__PURE__ */ N.jsx(ut.div, { ...r, ref: t });
  }
);
N_.displayName = _4;
var k_ = "ToastAction", D4 = y.forwardRef(
  (e, t) => {
    const { altText: n, ...r } = e;
    return n.trim() ? /* @__PURE__ */ N.jsx(L_, { altText: n, asChild: !0, children: /* @__PURE__ */ N.jsx(Cb, { ...r, ref: t }) }) : (console.error(
      `Invalid prop \`altText\` supplied to \`${k_}\`. Expected non-empty \`string\`.`
    ), null);
  }
);
D4.displayName = k_;
var M_ = "ToastClose", Cb = y.forwardRef(
  (e, t) => {
    const { __scopeToast: n, ...r } = e, a = C4(M_, n);
    return /* @__PURE__ */ N.jsx(L_, { asChild: !0, children: /* @__PURE__ */ N.jsx(
      ut.button,
      {
        type: "button",
        ...r,
        ref: t,
        onClick: Ze(e.onClick, a.onClose)
      }
    ) });
  }
);
Cb.displayName = M_;
var L_ = y.forwardRef((e, t) => {
  const { __scopeToast: n, altText: r, ...a } = e;
  return /* @__PURE__ */ N.jsx(
    ut.div,
    {
      "data-radix-toast-announce-exclude": "",
      "data-radix-toast-announce-alt": r || void 0,
      ...a,
      ref: t
    }
  );
});
function z_(e) {
  const t = [];
  return Array.from(e.childNodes).forEach((r) => {
    if (r.nodeType === r.TEXT_NODE && r.textContent && t.push(r.textContent), k4(r)) {
      const a = r.ariaHidden || r.hidden || r.style.display === "none", i = r.dataset.radixToastAnnounceExclude === "";
      if (!a)
        if (i) {
          const o = r.dataset.radixToastAnnounceAlt;
          o && t.push(o);
        } else
          t.push(...z_(r));
    }
  }), t;
}
function rf(e, t, n, { discrete: r }) {
  const a = n.originalEvent.currentTarget, i = new CustomEvent(e, { bubbles: !0, cancelable: !0, detail: n });
  t && a.addEventListener(e, t, { once: !0 }), r ? JA(a, i) : a.dispatchEvent(i);
}
var _E = (e, t, n = 0) => {
  const r = Math.abs(e.x), a = Math.abs(e.y), i = r > a;
  return t === "left" || t === "right" ? i && r > n : !i && a > n;
};
function N4(e = () => {
}) {
  const t = fr(e);
  Wr(() => {
    let n = 0, r = 0;
    return n = window.requestAnimationFrame(() => r = window.requestAnimationFrame(t)), () => {
      window.cancelAnimationFrame(n), window.cancelAnimationFrame(r);
    };
  }, [t]);
}
function k4(e) {
  return e.nodeType === e.ELEMENT_NODE;
}
function M4(e) {
  const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (r) => {
      const a = r.tagName === "INPUT" && r.type === "hidden";
      return r.disabled || r.hidden || a ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n.nextNode(); ) t.push(n.currentNode);
  return t;
}
function Yp(e) {
  const t = document.activeElement;
  return e.some((n) => n === t ? !0 : (n.focus(), document.activeElement !== t));
}
var L4 = C_, z4 = A_, j_ = __, P_ = D_, I_ = N_, F_ = Cb;
const iv = du({
  slots: {
    base: `
      border-none group relative flex items-center justify-center gap-4 overflow-hidden rounded-lg p-4 h-[3.75rem]
      shadow-toast transition-all min-w-[18.75rem] max-w-[37.5rem] pointer-events-auto
      data-[swipe=cancel]:translate-x-0
      data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)]
      data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)]
      data-[swipe=move]:transition-none
      data-[state=open]:animate-slide-in-from-top-full
      data-[state=closed]:animate-slide-out-to-top-full
    `,
    iconWrapper: "flex items-center justify-center rounded-full w-7.5 h-7.5 border-2 border-white/20",
    icon: "bg-white rounded-full w-6 h-6 p-0.5 shadow-lg",
    content: "flex-1 flex flex-col justify-center text-sm font-normal text-white",
    title: "font-semibold",
    description: "text-white/90",
    divider: "border-l border-white/50 h-full",
    closeButton: "flex items-center justify-center w-7 h-7 text-white",
    viewport: `
      pointer-events-none
    `
  },
  variants: {
    variant: {
      success: {
        base: "bg-green-4 text-white border border-green-6",
        iconWrapper: "bg-green-5/20",
        icon: "text-green-4"
      },
      error: {
        base: "bg-red-9 text-white border border-red-10",
        iconWrapper: "bg-red-500/20",
        icon: "text-red-9"
      },
      warning: {
        base: "bg-yellow-400 text-white border border-yellow-300",
        iconWrapper: "bg-yellow-500/20",
        icon: "text-yellow-500"
      },
      info: {
        base: "bg-blue-500 text-white border border-blue-200",
        iconWrapper: "bg-blue-600/20",
        icon: "text-blue-500"
      }
    }
  },
  defaultVariants: {
    variant: "info"
  }
}), j4 = L4, U_ = y.forwardRef(({ className: e, ...t }, n) => /* @__PURE__ */ N.jsx(
  z4,
  {
    ref: n,
    className: at(
      "fixed z-[800] pointer-events-none flex flex-col gap-3",
      e
    ),
    ...t
  }
));
U_.displayName = "ToastViewport";
const q_ = y.forwardRef(({ className: e, variant: t, children: n, ...r }, a) => /* @__PURE__ */ N.jsx(
  j_,
  {
    ref: a,
    className: at(iv({ variant: t }), e),
    ...r,
    children: n
  }
));
q_.displayName = j_.displayName;
const B_ = y.forwardRef(({ className: e, ...t }, n) => /* @__PURE__ */ N.jsx(
  F_,
  {
    ref: n,
    ...t,
    className: at("rounded-md flex items-center justify-center", e),
    children: /* @__PURE__ */ N.jsx(lc, { name: "close", size: "sm" })
  }
));
B_.displayName = F_.displayName;
const V_ = y.forwardRef(({ className: e, ...t }, n) => /* @__PURE__ */ N.jsx(
  P_,
  {
    ref: n,
    className: at("text-sm font-semibold", e),
    ...t
  }
));
V_.displayName = P_.displayName;
const Q_ = y.forwardRef(({ className: e, ...t }, n) => /* @__PURE__ */ N.jsx(
  I_,
  {
    ref: n,
    ...t,
    className: at("flex-1 text-sm font-medium", e)
  }
));
Q_.displayName = I_.displayName;
const P4 = {
  success: "check",
  error: "close",
  warning: "alert-line",
  info: "information-line"
};
function I4({
  toasts: e,
  viewportClassName: t,
  viewportStyle: n
}) {
  const { removeToast: r } = U4(), [a, i] = y.useState(null), o = y.useMemo(() => [...e].sort((l, c) => c.createdAt - l.createdAt), [e]), { viewport: s } = iv();
  return /* @__PURE__ */ N.jsxs(j4, { children: [
    o.map((l) => {
      const c = iv({ variant: l.type });
      return /* @__PURE__ */ N.jsxs(
        q_,
        {
          variant: l.type,
          className: c.base(),
          onOpenChange: (u) => {
            u || r(l.id);
          },
          duration: (
            // Pauses the dismiss timer when the mouse is over the toast.
            a === l.id ? Number.POSITIVE_INFINITY : l.duration || 3e3
          ),
          onMouseEnter: () => i(l.id),
          onMouseLeave: () => i(null),
          children: [
            /* @__PURE__ */ N.jsx("div", { className: c.iconWrapper(), children: /* @__PURE__ */ N.jsx(
              Fs,
              {
                name: P4[l.type] || "information-line",
                className: c.icon()
              }
            ) }),
            /* @__PURE__ */ N.jsxs("div", { className: c.content(), children: [
              l.title && /* @__PURE__ */ N.jsx(V_, { className: c.title(), children: l.title }),
              /* @__PURE__ */ N.jsx(Q_, { className: c.description(), children: l.description })
            ] }),
            /* @__PURE__ */ N.jsx("div", { className: c.divider() }),
            /* @__PURE__ */ N.jsx(
              B_,
              {
                onClick: () => r(l.id),
                className: c.closeButton()
              }
            )
          ]
        },
        l.id
      );
    }),
    /* @__PURE__ */ N.jsx(
      U_,
      {
        className: at(s(), t),
        style: n
      }
    )
  ] });
}
const H_ = y.createContext(void 0);
function F4({
  children: e,
  viewportClassName: t,
  viewportStyle: n
}) {
  const [r, a] = y.useState([]), i = y.useCallback((l) => {
    const c = {
      ...l,
      id: _F(),
      createdAt: Date.now()
    };
    a((u) => [...u, c]);
  }, []), o = y.useCallback((l) => {
    a((c) => c.filter((u) => u.id !== l));
  }, []), s = y.useMemo(
    () => ({ showToast: i, removeToast: o }),
    [i, o]
  );
  return /* @__PURE__ */ N.jsxs(H_.Provider, { value: s, children: [
    e,
    /* @__PURE__ */ N.jsx(
      I4,
      {
        toasts: r,
        viewportClassName: t,
        viewportStyle: n
      }
    )
  ] });
}
const U4 = () => {
  const e = y.useContext(H_);
  if (!e)
    throw new Error("useToast must be used within a ToastProvider");
  return e;
}, $_ = y.createContext(null), q4 = ({
  value: e,
  children: t
}) => /* @__PURE__ */ N.jsx($_.Provider, { value: e, children: t }), q8 = () => {
  var e;
  return ((e = y.useContext($_)) == null ? void 0 : e.current) ?? null;
}, B4 = y.createContext({
  triggerRefetch: () => Promise.resolve(),
  triggerApplyFilters: () => {
  },
  registerRefetch: () => {
  },
  unregisterRefetch: () => {
  },
  registerApplyFilters: () => {
  },
  unregisterApplyFilters: () => {
  }
}), V4 = ({
  children: e
}) => {
  const [t, n] = y.useState(/* @__PURE__ */ new Map()), [r, a] = y.useState(/* @__PURE__ */ new Map()), i = y.useCallback(
    async (f) => {
      const d = t.get(f);
      d && await d();
    },
    [t]
  ), o = y.useCallback(
    (f, d) => {
      const h = r.get(f);
      h && h(d);
    },
    [r]
  ), s = y.useCallback(
    (f, d) => {
      n((h) => new Map(h).set(f, d));
    },
    []
  ), l = y.useCallback((f) => {
    n((d) => {
      const h = new Map(d);
      return h.delete(f), h;
    });
  }, []), c = y.useCallback(
    (f, d) => {
      a(
        (h) => new Map(h).set(
          f,
          d
        )
      );
    },
    []
  ), u = y.useCallback((f) => {
    a((d) => {
      const h = new Map(d);
      return h.delete(f), h;
    });
  }, []);
  return /* @__PURE__ */ N.jsx(
    B4.Provider,
    {
      value: {
        triggerRefetch: i,
        triggerApplyFilters: o,
        registerRefetch: s,
        unregisterRefetch: l,
        registerApplyFilters: c,
        unregisterApplyFilters: u
      },
      children: e
    }
  );
}, G_ = y.createContext(null), Q4 = G_.Provider, B8 = () => y.useContext(G_);
function H4(e) {
  return new gr(function(t, n) {
    var r = Ln(t, []);
    return new ke(function(a) {
      var i, o = !1;
      return Promise.resolve(r).then(function(s) {
        return e(s, t.getContext());
      }).then(t.setContext).then(function() {
        o || (i = n(t).subscribe({
          next: a.next.bind(a),
          error: a.error.bind(a),
          complete: a.complete.bind(a)
        }));
      }).catch(a.error.bind(a)), function() {
        o = !0, i && i.unsubscribe();
      };
    });
  });
}
function Y_(e) {
  return new gr(function(t, n) {
    return new ke(function(r) {
      var a, i, o;
      try {
        a = n(t).subscribe({
          next: function(s) {
            if (s.errors ? o = e({
              graphQLErrors: s.errors,
              response: s,
              operation: t,
              forward: n
            }) : eA(s) && (o = e({
              protocolErrors: s.extensions[sh],
              response: s,
              operation: t,
              forward: n
            })), o) {
              i = o.subscribe({
                next: r.next.bind(r),
                error: r.error.bind(r),
                complete: r.complete.bind(r)
              });
              return;
            }
            r.next(s);
          },
          error: function(s) {
            if (o = e({
              operation: t,
              networkError: s,
              //Network errors can return GraphQL errors on for example a 403
              graphQLErrors: s && s.result && s.result.errors || void 0,
              forward: n
            }), o) {
              i = o.subscribe({
                next: r.next.bind(r),
                error: r.error.bind(r),
                complete: r.complete.bind(r)
              });
              return;
            }
            r.error(s);
          },
          complete: function() {
            o || r.complete.bind(r)();
          }
        });
      } catch (s) {
        e({ networkError: s, operation: t, forward: n }), r.error(s);
      }
      return function() {
        a && a.unsubscribe(), i && a.unsubscribe();
      };
    });
  });
}
(function(e) {
  Yn(t, e);
  function t(n) {
    var r = e.call(this) || this;
    return r.link = Y_(n), r;
  }
  return t.prototype.request = function(n, r) {
    return this.link.request(n, r);
  }, t;
})(gr);
function $4(e) {
  if (typeof e != "object" || e === null)
    return !1;
  const t = Object.getPrototypeOf(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}
function G4(e, t, n = "") {
  if (!arguments.length) throw new TypeError("Argument 1 `value` is required.");
  if (typeof t != "function")
    throw new TypeError("Argument 2 `isExtractable` must be a function.");
  if (typeof n != "string")
    throw new TypeError("Argument 3 `path` must be a string.");
  const r = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map();
  function i(o, s, l) {
    if (t(o)) {
      const f = a.get(o);
      return f ? f.push(s) : a.set(o, [s]), null;
    }
    const c = Array.isArray(o) || typeof FileList < "u" && o instanceof FileList, u = $4(o);
    if (c || u) {
      let f = r.get(o);
      const d = !f;
      if (d && (f = c ? [] : (
        // Replicate if the plain object is an `Object` instance.
        o instanceof /** @type {any} */
        Object ? {} : /* @__PURE__ */ Object.create(null)
      ), r.set(
        o,
        /** @type {Clone} */
        f
      )), !l.has(o)) {
        const h = s ? `${s}.` : "", g = new Set(l).add(o);
        if (c) {
          let v = 0;
          for (const b of o) {
            const p = i(
              b,
              h + v++,
              g
            );
            d && f.push(p);
          }
        } else
          for (const v in o) {
            const b = i(
              o[v],
              h + v,
              g
            );
            d && (f[v] = b);
          }
      }
      return f;
    }
    return o;
  }
  return {
    clone: i(e, n, /* @__PURE__ */ new Set()),
    files: a
  };
}
function Y4(e, t, n) {
  "name" in n ? e.append(t, n, n.name) : e.append(t, n);
}
function K4(e) {
  return typeof File < "u" && e instanceof File || typeof Blob < "u" && e instanceof Blob;
}
function X4({
  uri: e = "/graphql",
  useGETForQueries: t,
  isExtractableFile: n = K4,
  FormData: r,
  formDataAppendFile: a = Y4,
  print: i = iA,
  fetch: o,
  fetchOptions: s,
  credentials: l,
  headers: c,
  includeExtensions: u
} = {}) {
  const f = {
    http: { includeExtensions: u },
    options: s,
    credentials: l,
    headers: c
  };
  return new gr((d) => {
    const h = (
      /**
       * @type {import("@apollo/client/core/types.js").DefaultContext & {
       *   clientAwareness?: {
       *     name?: string,
       *     version?: string,
       *   },
       * }}
       */
      d.getContext()
    ), {
      // Apollo Studio client awareness `name` and `version` can be configured
      // via `ApolloClient` constructor options:
      // https://www.apollographql.com/docs/graphos/metrics/client-awareness/#setup
      clientAwareness: { name: g, version: v } = {},
      headers: b
    } = h, p = {
      http: h.http,
      options: h.fetchOptions,
      credentials: h.credentials,
      headers: {
        // Client awareness headers can be overridden by context `headers`.
        ...g && { "apollographql-client-name": g },
        ...v && { "apollographql-client-version": v },
        ...b
      }
    }, { options: m, body: w } = oA(
      d,
      i,
      aA,
      f,
      p
    ), { clone: x, files: S } = G4(w, n, "");
    let T = sA(d, e);
    if (S.size) {
      m.headers && delete m.headers["content-type"];
      const D = r || FormData, A = new D();
      A.append("operations", Mc(x, "Payload"));
      const U = {};
      let R = 0;
      S.forEach((q) => {
        U[++R] = q;
      }), A.append("map", JSON.stringify(U)), R = 0, S.forEach((q, z) => {
        a(A, String(++R), z);
      }), m.body = A;
    } else if (t && // If the operation contains some mutations GET shouldnt be used.
    !d.query.definitions.some(
      (D) => D.kind === "OperationDefinition" && D.operation === "mutation"
    ) && (m.method = "GET"), m.method === "GET") {
      const { newURI: D, parseError: A } = lA(T, w);
      if (A)
        return new ke((U) => {
          U.error(A);
        });
      T = D;
    } else m.body = Mc(x, "Payload");
    const { controller: E } = ZP();
    typeof E != "boolean" && (m.signal && (m.signal.aborted ? (
      // Signal already aborted, so immediately abort.
      E.abort()
    ) : (
      // Signal not already aborted, so setup a listener to abort when it
      // does.
      m.signal.addEventListener(
        "abort",
        () => {
          E.abort();
        },
        {
          // Prevent a memory leak if the user configured abort controller
          // is long lasting, or controls multiple things.
          once: !0
        }
      )
    )), m.signal = E.signal);
    const O = o || fetch;
    return new ke((D) => {
      let A;
      return O(T, m).then((U) => (d.setContext({ response: U }), U)).then(rA(d)).then((U) => {
        D.next(U), D.complete();
      }).catch((U) => {
        A || (U.result && U.result.errors && U.result.data && D.next(U.result), D.error(U));
      }), () => {
        A = !0, typeof E != "boolean" && E.abort();
      };
    });
  });
}
let ov = {};
const W4 = () => {
  if (typeof window < "u")
    return window.location.hostname;
}, K_ = (e) => {
  const t = {
    ...ov,
    ...e.apiKey !== void 0 ? { apiKey: e.apiKey } : {},
    ...e.hostname !== void 0 ? { hostname: e.hostname } : {},
    ...e.token !== void 0 ? { token: e.token } : {},
    ...e.userId !== void 0 ? { userId: e.userId } : {}
  };
  e.auth !== void 0 && (t.token = e.auth), t.hostname || (t.hostname = W4()), ov = t;
}, ol = () => ov, de = (e) => typeof e == "string", Nl = () => {
  let e, t;
  const n = new Promise((r, a) => {
    e = r, t = a;
  });
  return n.resolve = e, n.reject = t, n;
}, DE = (e) => e == null ? "" : "" + e, Z4 = (e, t, n) => {
  e.forEach((r) => {
    t[r] && (n[r] = t[r]);
  });
}, J4 = /###/g, NE = (e) => e && e.indexOf("###") > -1 ? e.replace(J4, ".") : e, kE = (e) => !e || de(e), cc = (e, t, n) => {
  const r = de(t) ? t.split(".") : t;
  let a = 0;
  for (; a < r.length - 1; ) {
    if (kE(e)) return {};
    const i = NE(r[a]);
    !e[i] && n && (e[i] = new n()), Object.prototype.hasOwnProperty.call(e, i) ? e = e[i] : e = {}, ++a;
  }
  return kE(e) ? {} : {
    obj: e,
    k: NE(r[a])
  };
}, ME = (e, t, n) => {
  const {
    obj: r,
    k: a
  } = cc(e, t, Object);
  if (r !== void 0 || t.length === 1) {
    r[a] = n;
    return;
  }
  let i = t[t.length - 1], o = t.slice(0, t.length - 1), s = cc(e, o, Object);
  for (; s.obj === void 0 && o.length; )
    i = `${o[o.length - 1]}.${i}`, o = o.slice(0, o.length - 1), s = cc(e, o, Object), s != null && s.obj && typeof s.obj[`${s.k}.${i}`] < "u" && (s.obj = void 0);
  s.obj[`${s.k}.${i}`] = n;
}, eB = (e, t, n, r) => {
  const {
    obj: a,
    k: i
  } = cc(e, t, Object);
  a[i] = a[i] || [], a[i].push(n);
}, Td = (e, t) => {
  const {
    obj: n,
    k: r
  } = cc(e, t);
  if (n && Object.prototype.hasOwnProperty.call(n, r))
    return n[r];
}, tB = (e, t, n) => {
  const r = Td(e, n);
  return r !== void 0 ? r : Td(t, n);
}, X_ = (e, t, n) => {
  for (const r in t)
    r !== "__proto__" && r !== "constructor" && (r in e ? de(e[r]) || e[r] instanceof String || de(t[r]) || t[r] instanceof String ? n && (e[r] = t[r]) : X_(e[r], t[r], n) : e[r] = t[r]);
  return e;
}, wo = (e) => e.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
var nB = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
const rB = (e) => de(e) ? e.replace(/[&<>"'\/]/g, (t) => nB[t]) : e;
class aB {
  constructor(t) {
    this.capacity = t, this.regExpMap = /* @__PURE__ */ new Map(), this.regExpQueue = [];
  }
  getRegExp(t) {
    const n = this.regExpMap.get(t);
    if (n !== void 0)
      return n;
    const r = new RegExp(t);
    return this.regExpQueue.length === this.capacity && this.regExpMap.delete(this.regExpQueue.shift()), this.regExpMap.set(t, r), this.regExpQueue.push(t), r;
  }
}
const iB = [" ", ",", "?", "!", ";"], oB = new aB(20), sB = (e, t, n) => {
  t = t || "", n = n || "";
  const r = iB.filter((o) => t.indexOf(o) < 0 && n.indexOf(o) < 0);
  if (r.length === 0) return !0;
  const a = oB.getRegExp(`(${r.map((o) => o === "?" ? "\\?" : o).join("|")})`);
  let i = !a.test(e);
  if (!i) {
    const o = e.indexOf(n);
    o > 0 && !a.test(e.substring(0, o)) && (i = !0);
  }
  return i;
}, sv = (e, t, n = ".") => {
  if (!e) return;
  if (e[t])
    return Object.prototype.hasOwnProperty.call(e, t) ? e[t] : void 0;
  const r = t.split(n);
  let a = e;
  for (let i = 0; i < r.length; ) {
    if (!a || typeof a != "object")
      return;
    let o, s = "";
    for (let l = i; l < r.length; ++l)
      if (l !== i && (s += n), s += r[l], o = a[s], o !== void 0) {
        if (["string", "number", "boolean"].indexOf(typeof o) > -1 && l < r.length - 1)
          continue;
        i += l - i + 1;
        break;
      }
    a = o;
  }
  return a;
}, Fc = (e) => e == null ? void 0 : e.replace("_", "-"), lB = {
  type: "logger",
  log(e) {
    this.output("log", e);
  },
  warn(e) {
    this.output("warn", e);
  },
  error(e) {
    this.output("error", e);
  },
  output(e, t) {
    var n, r;
    (r = (n = console == null ? void 0 : console[e]) == null ? void 0 : n.apply) == null || r.call(n, console, t);
  }
};
class Cd {
  constructor(t, n = {}) {
    this.init(t, n);
  }
  init(t, n = {}) {
    this.prefix = n.prefix || "i18next:", this.logger = t || lB, this.options = n, this.debug = n.debug;
  }
  log(...t) {
    return this.forward(t, "log", "", !0);
  }
  warn(...t) {
    return this.forward(t, "warn", "", !0);
  }
  error(...t) {
    return this.forward(t, "error", "");
  }
  deprecate(...t) {
    return this.forward(t, "warn", "WARNING DEPRECATED: ", !0);
  }
  forward(t, n, r, a) {
    return a && !this.debug ? null : (de(t[0]) && (t[0] = `${r}${this.prefix} ${t[0]}`), this.logger[n](t));
  }
  create(t) {
    return new Cd(this.logger, {
      prefix: `${this.prefix}:${t}:`,
      ...this.options
    });
  }
  clone(t) {
    return t = t || this.options, t.prefix = t.prefix || this.prefix, new Cd(this.logger, t);
  }
}
var ar = new Cd();
class wh {
  constructor() {
    this.observers = {};
  }
  on(t, n) {
    return t.split(" ").forEach((r) => {
      this.observers[r] || (this.observers[r] = /* @__PURE__ */ new Map());
      const a = this.observers[r].get(n) || 0;
      this.observers[r].set(n, a + 1);
    }), this;
  }
  off(t, n) {
    if (this.observers[t]) {
      if (!n) {
        delete this.observers[t];
        return;
      }
      this.observers[t].delete(n);
    }
  }
  emit(t, ...n) {
    this.observers[t] && Array.from(this.observers[t].entries()).forEach(([a, i]) => {
      for (let o = 0; o < i; o++)
        a(...n);
    }), this.observers["*"] && Array.from(this.observers["*"].entries()).forEach(([a, i]) => {
      for (let o = 0; o < i; o++)
        a.apply(a, [t, ...n]);
    });
  }
}
class LE extends wh {
  constructor(t, n = {
    ns: ["translation"],
    defaultNS: "translation"
  }) {
    super(), this.data = t || {}, this.options = n, this.options.keySeparator === void 0 && (this.options.keySeparator = "."), this.options.ignoreJSONStructure === void 0 && (this.options.ignoreJSONStructure = !0);
  }
  addNamespaces(t) {
    this.options.ns.indexOf(t) < 0 && this.options.ns.push(t);
  }
  removeNamespaces(t) {
    const n = this.options.ns.indexOf(t);
    n > -1 && this.options.ns.splice(n, 1);
  }
  getResource(t, n, r, a = {}) {
    var c, u;
    const i = a.keySeparator !== void 0 ? a.keySeparator : this.options.keySeparator, o = a.ignoreJSONStructure !== void 0 ? a.ignoreJSONStructure : this.options.ignoreJSONStructure;
    let s;
    t.indexOf(".") > -1 ? s = t.split(".") : (s = [t, n], r && (Array.isArray(r) ? s.push(...r) : de(r) && i ? s.push(...r.split(i)) : s.push(r)));
    const l = Td(this.data, s);
    return !l && !n && !r && t.indexOf(".") > -1 && (t = s[0], n = s[1], r = s.slice(2).join(".")), l || !o || !de(r) ? l : sv((u = (c = this.data) == null ? void 0 : c[t]) == null ? void 0 : u[n], r, i);
  }
  addResource(t, n, r, a, i = {
    silent: !1
  }) {
    const o = i.keySeparator !== void 0 ? i.keySeparator : this.options.keySeparator;
    let s = [t, n];
    r && (s = s.concat(o ? r.split(o) : r)), t.indexOf(".") > -1 && (s = t.split("."), a = n, n = s[1]), this.addNamespaces(n), ME(this.data, s, a), i.silent || this.emit("added", t, n, r, a);
  }
  addResources(t, n, r, a = {
    silent: !1
  }) {
    for (const i in r)
      (de(r[i]) || Array.isArray(r[i])) && this.addResource(t, n, i, r[i], {
        silent: !0
      });
    a.silent || this.emit("added", t, n, r);
  }
  addResourceBundle(t, n, r, a, i, o = {
    silent: !1,
    skipCopy: !1
  }) {
    let s = [t, n];
    t.indexOf(".") > -1 && (s = t.split("."), a = r, r = n, n = s[1]), this.addNamespaces(n);
    let l = Td(this.data, s) || {};
    o.skipCopy || (r = JSON.parse(JSON.stringify(r))), a ? X_(l, r, i) : l = {
      ...l,
      ...r
    }, ME(this.data, s, l), o.silent || this.emit("added", t, n, r);
  }
  removeResourceBundle(t, n) {
    this.hasResourceBundle(t, n) && delete this.data[t][n], this.removeNamespaces(n), this.emit("removed", t, n);
  }
  hasResourceBundle(t, n) {
    return this.getResource(t, n) !== void 0;
  }
  getResourceBundle(t, n) {
    return n || (n = this.options.defaultNS), this.getResource(t, n);
  }
  getDataByLanguage(t) {
    return this.data[t];
  }
  hasLanguageSomeTranslations(t) {
    const n = this.getDataByLanguage(t);
    return !!(n && Object.keys(n) || []).find((a) => n[a] && Object.keys(n[a]).length > 0);
  }
  toJSON() {
    return this.data;
  }
}
var W_ = {
  processors: {},
  addPostProcessor(e) {
    this.processors[e.name] = e;
  },
  handle(e, t, n, r, a) {
    return e.forEach((i) => {
      var o;
      t = ((o = this.processors[i]) == null ? void 0 : o.process(t, n, r, a)) ?? t;
    }), t;
  }
};
const Z_ = Symbol("i18next/PATH_KEY");
function cB() {
  const e = [], t = /* @__PURE__ */ Object.create(null);
  let n;
  return t.get = (r, a) => {
    var i;
    return (i = n == null ? void 0 : n.revoke) == null || i.call(n), a === Z_ ? e : (e.push(a), n = Proxy.revocable(r, t), n.proxy);
  }, Proxy.revocable(/* @__PURE__ */ Object.create(null), t).proxy;
}
function lv(e, t) {
  const {
    [Z_]: n
  } = e(cB());
  return n.join((t == null ? void 0 : t.keySeparator) ?? ".");
}
const zE = {}, Kp = (e) => !de(e) && typeof e != "boolean" && typeof e != "number";
class Od extends wh {
  constructor(t, n = {}) {
    super(), Z4(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], t, this), this.options = n, this.options.keySeparator === void 0 && (this.options.keySeparator = "."), this.logger = ar.create("translator");
  }
  changeLanguage(t) {
    t && (this.language = t);
  }
  exists(t, n = {
    interpolation: {}
  }) {
    const r = {
      ...n
    };
    if (t == null) return !1;
    const a = this.resolve(t, r);
    if ((a == null ? void 0 : a.res) === void 0) return !1;
    const i = Kp(a.res);
    return !(r.returnObjects === !1 && i);
  }
  extractFromKey(t, n) {
    let r = n.nsSeparator !== void 0 ? n.nsSeparator : this.options.nsSeparator;
    r === void 0 && (r = ":");
    const a = n.keySeparator !== void 0 ? n.keySeparator : this.options.keySeparator;
    let i = n.ns || this.options.defaultNS || [];
    const o = r && t.indexOf(r) > -1, s = !this.options.userDefinedKeySeparator && !n.keySeparator && !this.options.userDefinedNsSeparator && !n.nsSeparator && !sB(t, r, a);
    if (o && !s) {
      const l = t.match(this.interpolator.nestingRegexp);
      if (l && l.length > 0)
        return {
          key: t,
          namespaces: de(i) ? [i] : i
        };
      const c = t.split(r);
      (r !== a || r === a && this.options.ns.indexOf(c[0]) > -1) && (i = c.shift()), t = c.join(a);
    }
    return {
      key: t,
      namespaces: de(i) ? [i] : i
    };
  }
  translate(t, n, r) {
    let a = typeof n == "object" ? {
      ...n
    } : n;
    if (typeof a != "object" && this.options.overloadTranslationOptionHandler && (a = this.options.overloadTranslationOptionHandler(arguments)), typeof a == "object" && (a = {
      ...a
    }), a || (a = {}), t == null) return "";
    typeof t == "function" && (t = lv(t, {
      ...this.options,
      ...a
    })), Array.isArray(t) || (t = [String(t)]);
    const i = a.returnDetails !== void 0 ? a.returnDetails : this.options.returnDetails, o = a.keySeparator !== void 0 ? a.keySeparator : this.options.keySeparator, {
      key: s,
      namespaces: l
    } = this.extractFromKey(t[t.length - 1], a), c = l[l.length - 1];
    let u = a.nsSeparator !== void 0 ? a.nsSeparator : this.options.nsSeparator;
    u === void 0 && (u = ":");
    const f = a.lng || this.language, d = a.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
    if ((f == null ? void 0 : f.toLowerCase()) === "cimode")
      return d ? i ? {
        res: `${c}${u}${s}`,
        usedKey: s,
        exactUsedKey: s,
        usedLng: f,
        usedNS: c,
        usedParams: this.getUsedParamsDetails(a)
      } : `${c}${u}${s}` : i ? {
        res: s,
        usedKey: s,
        exactUsedKey: s,
        usedLng: f,
        usedNS: c,
        usedParams: this.getUsedParamsDetails(a)
      } : s;
    const h = this.resolve(t, a);
    let g = h == null ? void 0 : h.res;
    const v = (h == null ? void 0 : h.usedKey) || s, b = (h == null ? void 0 : h.exactUsedKey) || s, p = ["[object Number]", "[object Function]", "[object RegExp]"], m = a.joinArrays !== void 0 ? a.joinArrays : this.options.joinArrays, w = !this.i18nFormat || this.i18nFormat.handleAsObject, x = a.count !== void 0 && !de(a.count), S = Od.hasDefaultValue(a), T = x ? this.pluralResolver.getSuffix(f, a.count, a) : "", E = a.ordinal && x ? this.pluralResolver.getSuffix(f, a.count, {
      ordinal: !1
    }) : "", O = x && !a.ordinal && a.count === 0, D = O && a[`defaultValue${this.options.pluralSeparator}zero`] || a[`defaultValue${T}`] || a[`defaultValue${E}`] || a.defaultValue;
    let A = g;
    w && !g && S && (A = D);
    const U = Kp(A), R = Object.prototype.toString.apply(A);
    if (w && A && U && p.indexOf(R) < 0 && !(de(m) && Array.isArray(A))) {
      if (!a.returnObjects && !this.options.returnObjects) {
        this.options.returnedObjectHandler || this.logger.warn("accessing an object - but returnObjects options is not enabled!");
        const q = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(v, A, {
          ...a,
          ns: l
        }) : `key '${s} (${this.language})' returned an object instead of string.`;
        return i ? (h.res = q, h.usedParams = this.getUsedParamsDetails(a), h) : q;
      }
      if (o) {
        const q = Array.isArray(A), z = q ? [] : {}, Q = q ? b : v;
        for (const k in A)
          if (Object.prototype.hasOwnProperty.call(A, k)) {
            const P = `${Q}${o}${k}`;
            S && !g ? z[k] = this.translate(P, {
              ...a,
              defaultValue: Kp(D) ? D[k] : void 0,
              joinArrays: !1,
              ns: l
            }) : z[k] = this.translate(P, {
              ...a,
              joinArrays: !1,
              ns: l
            }), z[k] === P && (z[k] = A[k]);
          }
        g = z;
      }
    } else if (w && de(m) && Array.isArray(g))
      g = g.join(m), g && (g = this.extendTranslation(g, t, a, r));
    else {
      let q = !1, z = !1;
      !this.isValidLookup(g) && S && (q = !0, g = D), this.isValidLookup(g) || (z = !0, g = s);
      const k = (a.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey) && z ? void 0 : g, P = S && D !== g && this.options.updateMissing;
      if (z || q || P) {
        if (this.logger.log(P ? "updateKey" : "missingKey", f, c, s, P ? D : g), o) {
          const Z = this.resolve(s, {
            ...a,
            keySeparator: !1
          });
          Z && Z.res && this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
        }
        let F = [];
        const H = this.languageUtils.getFallbackCodes(this.options.fallbackLng, a.lng || this.language);
        if (this.options.saveMissingTo === "fallback" && H && H[0])
          for (let Z = 0; Z < H.length; Z++)
            F.push(H[Z]);
        else this.options.saveMissingTo === "all" ? F = this.languageUtils.toResolveHierarchy(a.lng || this.language) : F.push(a.lng || this.language);
        const K = (Z, I, G) => {
          var J;
          const ee = S && G !== g ? G : k;
          this.options.missingKeyHandler ? this.options.missingKeyHandler(Z, c, I, ee, P, a) : (J = this.backendConnector) != null && J.saveMissing && this.backendConnector.saveMissing(Z, c, I, ee, P, a), this.emit("missingKey", Z, c, I, g);
        };
        this.options.saveMissing && (this.options.saveMissingPlurals && x ? F.forEach((Z) => {
          const I = this.pluralResolver.getSuffixes(Z, a);
          O && a[`defaultValue${this.options.pluralSeparator}zero`] && I.indexOf(`${this.options.pluralSeparator}zero`) < 0 && I.push(`${this.options.pluralSeparator}zero`), I.forEach((G) => {
            K([Z], s + G, a[`defaultValue${G}`] || D);
          });
        }) : K(F, s, D));
      }
      g = this.extendTranslation(g, t, a, h, r), z && g === s && this.options.appendNamespaceToMissingKey && (g = `${c}${u}${s}`), (z || q) && this.options.parseMissingKeyHandler && (g = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${c}${u}${s}` : s, q ? g : void 0, a));
    }
    return i ? (h.res = g, h.usedParams = this.getUsedParamsDetails(a), h) : g;
  }
  extendTranslation(t, n, r, a, i) {
    var l, c;
    if ((l = this.i18nFormat) != null && l.parse)
      t = this.i18nFormat.parse(t, {
        ...this.options.interpolation.defaultVariables,
        ...r
      }, r.lng || this.language || a.usedLng, a.usedNS, a.usedKey, {
        resolved: a
      });
    else if (!r.skipInterpolation) {
      r.interpolation && this.interpolator.init({
        ...r,
        interpolation: {
          ...this.options.interpolation,
          ...r.interpolation
        }
      });
      const u = de(t) && (((c = r == null ? void 0 : r.interpolation) == null ? void 0 : c.skipOnVariables) !== void 0 ? r.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
      let f;
      if (u) {
        const h = t.match(this.interpolator.nestingRegexp);
        f = h && h.length;
      }
      let d = r.replace && !de(r.replace) ? r.replace : r;
      if (this.options.interpolation.defaultVariables && (d = {
        ...this.options.interpolation.defaultVariables,
        ...d
      }), t = this.interpolator.interpolate(t, d, r.lng || this.language || a.usedLng, r), u) {
        const h = t.match(this.interpolator.nestingRegexp), g = h && h.length;
        f < g && (r.nest = !1);
      }
      !r.lng && a && a.res && (r.lng = this.language || a.usedLng), r.nest !== !1 && (t = this.interpolator.nest(t, (...h) => (i == null ? void 0 : i[0]) === h[0] && !r.context ? (this.logger.warn(`It seems you are nesting recursively key: ${h[0]} in key: ${n[0]}`), null) : this.translate(...h, n), r)), r.interpolation && this.interpolator.reset();
    }
    const o = r.postProcess || this.options.postProcess, s = de(o) ? [o] : o;
    return t != null && (s != null && s.length) && r.applyPostProcessor !== !1 && (t = W_.handle(s, t, n, this.options && this.options.postProcessPassResolved ? {
      i18nResolved: {
        ...a,
        usedParams: this.getUsedParamsDetails(r)
      },
      ...r
    } : r, this)), t;
  }
  resolve(t, n = {}) {
    let r, a, i, o, s;
    return de(t) && (t = [t]), t.forEach((l) => {
      if (this.isValidLookup(r)) return;
      const c = this.extractFromKey(l, n), u = c.key;
      a = u;
      let f = c.namespaces;
      this.options.fallbackNS && (f = f.concat(this.options.fallbackNS));
      const d = n.count !== void 0 && !de(n.count), h = d && !n.ordinal && n.count === 0, g = n.context !== void 0 && (de(n.context) || typeof n.context == "number") && n.context !== "", v = n.lngs ? n.lngs : this.languageUtils.toResolveHierarchy(n.lng || this.language, n.fallbackLng);
      f.forEach((b) => {
        var p, m;
        this.isValidLookup(r) || (s = b, !zE[`${v[0]}-${b}`] && ((p = this.utils) != null && p.hasLoadedNamespace) && !((m = this.utils) != null && m.hasLoadedNamespace(s)) && (zE[`${v[0]}-${b}`] = !0, this.logger.warn(`key "${a}" for languages "${v.join(", ")}" won't get resolved as namespace "${s}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")), v.forEach((w) => {
          var T;
          if (this.isValidLookup(r)) return;
          o = w;
          const x = [u];
          if ((T = this.i18nFormat) != null && T.addLookupKeys)
            this.i18nFormat.addLookupKeys(x, u, w, b, n);
          else {
            let E;
            d && (E = this.pluralResolver.getSuffix(w, n.count, n));
            const O = `${this.options.pluralSeparator}zero`, D = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
            if (d && (n.ordinal && E.indexOf(D) === 0 && x.push(u + E.replace(D, this.options.pluralSeparator)), x.push(u + E), h && x.push(u + O)), g) {
              const A = `${u}${this.options.contextSeparator || "_"}${n.context}`;
              x.push(A), d && (n.ordinal && E.indexOf(D) === 0 && x.push(A + E.replace(D, this.options.pluralSeparator)), x.push(A + E), h && x.push(A + O));
            }
          }
          let S;
          for (; S = x.pop(); )
            this.isValidLookup(r) || (i = S, r = this.getResource(w, b, S, n));
        }));
      });
    }), {
      res: r,
      usedKey: a,
      exactUsedKey: i,
      usedLng: o,
      usedNS: s
    };
  }
  isValidLookup(t) {
    return t !== void 0 && !(!this.options.returnNull && t === null) && !(!this.options.returnEmptyString && t === "");
  }
  getResource(t, n, r, a = {}) {
    var i;
    return (i = this.i18nFormat) != null && i.getResource ? this.i18nFormat.getResource(t, n, r, a) : this.resourceStore.getResource(t, n, r, a);
  }
  getUsedParamsDetails(t = {}) {
    const n = ["defaultValue", "ordinal", "context", "replace", "lng", "lngs", "fallbackLng", "ns", "keySeparator", "nsSeparator", "returnObjects", "returnDetails", "joinArrays", "postProcess", "interpolation"], r = t.replace && !de(t.replace);
    let a = r ? t.replace : t;
    if (r && typeof t.count < "u" && (a.count = t.count), this.options.interpolation.defaultVariables && (a = {
      ...this.options.interpolation.defaultVariables,
      ...a
    }), !r) {
      a = {
        ...a
      };
      for (const i of n)
        delete a[i];
    }
    return a;
  }
  static hasDefaultValue(t) {
    const n = "defaultValue";
    for (const r in t)
      if (Object.prototype.hasOwnProperty.call(t, r) && n === r.substring(0, n.length) && t[r] !== void 0)
        return !0;
    return !1;
  }
}
class jE {
  constructor(t) {
    this.options = t, this.supportedLngs = this.options.supportedLngs || !1, this.logger = ar.create("languageUtils");
  }
  getScriptPartFromCode(t) {
    if (t = Fc(t), !t || t.indexOf("-") < 0) return null;
    const n = t.split("-");
    return n.length === 2 || (n.pop(), n[n.length - 1].toLowerCase() === "x") ? null : this.formatLanguageCode(n.join("-"));
  }
  getLanguagePartFromCode(t) {
    if (t = Fc(t), !t || t.indexOf("-") < 0) return t;
    const n = t.split("-");
    return this.formatLanguageCode(n[0]);
  }
  formatLanguageCode(t) {
    if (de(t) && t.indexOf("-") > -1) {
      let n;
      try {
        n = Intl.getCanonicalLocales(t)[0];
      } catch {
      }
      return n && this.options.lowerCaseLng && (n = n.toLowerCase()), n || (this.options.lowerCaseLng ? t.toLowerCase() : t);
    }
    return this.options.cleanCode || this.options.lowerCaseLng ? t.toLowerCase() : t;
  }
  isSupportedCode(t) {
    return (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) && (t = this.getLanguagePartFromCode(t)), !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(t) > -1;
  }
  getBestMatchFromCodes(t) {
    if (!t) return null;
    let n;
    return t.forEach((r) => {
      if (n) return;
      const a = this.formatLanguageCode(r);
      (!this.options.supportedLngs || this.isSupportedCode(a)) && (n = a);
    }), !n && this.options.supportedLngs && t.forEach((r) => {
      if (n) return;
      const a = this.getScriptPartFromCode(r);
      if (this.isSupportedCode(a)) return n = a;
      const i = this.getLanguagePartFromCode(r);
      if (this.isSupportedCode(i)) return n = i;
      n = this.options.supportedLngs.find((o) => {
        if (o === i) return o;
        if (!(o.indexOf("-") < 0 && i.indexOf("-") < 0) && (o.indexOf("-") > 0 && i.indexOf("-") < 0 && o.substring(0, o.indexOf("-")) === i || o.indexOf(i) === 0 && i.length > 1))
          return o;
      });
    }), n || (n = this.getFallbackCodes(this.options.fallbackLng)[0]), n;
  }
  getFallbackCodes(t, n) {
    if (!t) return [];
    if (typeof t == "function" && (t = t(n)), de(t) && (t = [t]), Array.isArray(t)) return t;
    if (!n) return t.default || [];
    let r = t[n];
    return r || (r = t[this.getScriptPartFromCode(n)]), r || (r = t[this.formatLanguageCode(n)]), r || (r = t[this.getLanguagePartFromCode(n)]), r || (r = t.default), r || [];
  }
  toResolveHierarchy(t, n) {
    const r = this.getFallbackCodes((n === !1 ? [] : n) || this.options.fallbackLng || [], t), a = [], i = (o) => {
      o && (this.isSupportedCode(o) ? a.push(o) : this.logger.warn(`rejecting language code not found in supportedLngs: ${o}`));
    };
    return de(t) && (t.indexOf("-") > -1 || t.indexOf("_") > -1) ? (this.options.load !== "languageOnly" && i(this.formatLanguageCode(t)), this.options.load !== "languageOnly" && this.options.load !== "currentOnly" && i(this.getScriptPartFromCode(t)), this.options.load !== "currentOnly" && i(this.getLanguagePartFromCode(t))) : de(t) && i(this.formatLanguageCode(t)), r.forEach((o) => {
      a.indexOf(o) < 0 && i(this.formatLanguageCode(o));
    }), a;
  }
}
const PE = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
}, IE = {
  select: (e) => e === 1 ? "one" : "other",
  resolvedOptions: () => ({
    pluralCategories: ["one", "other"]
  })
};
class uB {
  constructor(t, n = {}) {
    this.languageUtils = t, this.options = n, this.logger = ar.create("pluralResolver"), this.pluralRulesCache = {};
  }
  addRule(t, n) {
    this.rules[t] = n;
  }
  clearCache() {
    this.pluralRulesCache = {};
  }
  getRule(t, n = {}) {
    const r = Fc(t === "dev" ? "en" : t), a = n.ordinal ? "ordinal" : "cardinal", i = JSON.stringify({
      cleanedCode: r,
      type: a
    });
    if (i in this.pluralRulesCache)
      return this.pluralRulesCache[i];
    let o;
    try {
      o = new Intl.PluralRules(r, {
        type: a
      });
    } catch {
      if (!Intl)
        return this.logger.error("No Intl support, please use an Intl polyfill!"), IE;
      if (!t.match(/-|_/)) return IE;
      const l = this.languageUtils.getLanguagePartFromCode(t);
      o = this.getRule(l, n);
    }
    return this.pluralRulesCache[i] = o, o;
  }
  needsPlural(t, n = {}) {
    let r = this.getRule(t, n);
    return r || (r = this.getRule("dev", n)), (r == null ? void 0 : r.resolvedOptions().pluralCategories.length) > 1;
  }
  getPluralFormsOfKey(t, n, r = {}) {
    return this.getSuffixes(t, r).map((a) => `${n}${a}`);
  }
  getSuffixes(t, n = {}) {
    let r = this.getRule(t, n);
    return r || (r = this.getRule("dev", n)), r ? r.resolvedOptions().pluralCategories.sort((a, i) => PE[a] - PE[i]).map((a) => `${this.options.prepend}${n.ordinal ? `ordinal${this.options.prepend}` : ""}${a}`) : [];
  }
  getSuffix(t, n, r = {}) {
    const a = this.getRule(t, r);
    return a ? `${this.options.prepend}${r.ordinal ? `ordinal${this.options.prepend}` : ""}${a.select(n)}` : (this.logger.warn(`no plural rule found for: ${t}`), this.getSuffix("dev", n, r));
  }
}
const FE = (e, t, n, r = ".", a = !0) => {
  let i = tB(e, t, n);
  return !i && a && de(n) && (i = sv(e, n, r), i === void 0 && (i = sv(t, n, r))), i;
}, Xp = (e) => e.replace(/\$/g, "$$$$");
class fB {
  constructor(t = {}) {
    var n;
    this.logger = ar.create("interpolator"), this.options = t, this.format = ((n = t == null ? void 0 : t.interpolation) == null ? void 0 : n.format) || ((r) => r), this.init(t);
  }
  init(t = {}) {
    t.interpolation || (t.interpolation = {
      escapeValue: !0
    });
    const {
      escape: n,
      escapeValue: r,
      useRawValueToEscape: a,
      prefix: i,
      prefixEscaped: o,
      suffix: s,
      suffixEscaped: l,
      formatSeparator: c,
      unescapeSuffix: u,
      unescapePrefix: f,
      nestingPrefix: d,
      nestingPrefixEscaped: h,
      nestingSuffix: g,
      nestingSuffixEscaped: v,
      nestingOptionsSeparator: b,
      maxReplaces: p,
      alwaysFormat: m
    } = t.interpolation;
    this.escape = n !== void 0 ? n : rB, this.escapeValue = r !== void 0 ? r : !0, this.useRawValueToEscape = a !== void 0 ? a : !1, this.prefix = i ? wo(i) : o || "{{", this.suffix = s ? wo(s) : l || "}}", this.formatSeparator = c || ",", this.unescapePrefix = u ? "" : f || "-", this.unescapeSuffix = this.unescapePrefix ? "" : u || "", this.nestingPrefix = d ? wo(d) : h || wo("$t("), this.nestingSuffix = g ? wo(g) : v || wo(")"), this.nestingOptionsSeparator = b || ",", this.maxReplaces = p || 1e3, this.alwaysFormat = m !== void 0 ? m : !1, this.resetRegExp();
  }
  reset() {
    this.options && this.init(this.options);
  }
  resetRegExp() {
    const t = (n, r) => (n == null ? void 0 : n.source) === r ? (n.lastIndex = 0, n) : new RegExp(r, "g");
    this.regexp = t(this.regexp, `${this.prefix}(.+?)${this.suffix}`), this.regexpUnescape = t(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`), this.nestingRegexp = t(this.nestingRegexp, `${this.nestingPrefix}((?:[^()"']+|"[^"]*"|'[^']*'|\\((?:[^()]|"[^"]*"|'[^']*')*\\))*?)${this.nestingSuffix}`);
  }
  interpolate(t, n, r, a) {
    var h;
    let i, o, s;
    const l = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {}, c = (g) => {
      if (g.indexOf(this.formatSeparator) < 0) {
        const m = FE(n, l, g, this.options.keySeparator, this.options.ignoreJSONStructure);
        return this.alwaysFormat ? this.format(m, void 0, r, {
          ...a,
          ...n,
          interpolationkey: g
        }) : m;
      }
      const v = g.split(this.formatSeparator), b = v.shift().trim(), p = v.join(this.formatSeparator).trim();
      return this.format(FE(n, l, b, this.options.keySeparator, this.options.ignoreJSONStructure), p, r, {
        ...a,
        ...n,
        interpolationkey: b
      });
    };
    this.resetRegExp();
    const u = (a == null ? void 0 : a.missingInterpolationHandler) || this.options.missingInterpolationHandler, f = ((h = a == null ? void 0 : a.interpolation) == null ? void 0 : h.skipOnVariables) !== void 0 ? a.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
    return [{
      regex: this.regexpUnescape,
      safeValue: (g) => Xp(g)
    }, {
      regex: this.regexp,
      safeValue: (g) => this.escapeValue ? Xp(this.escape(g)) : Xp(g)
    }].forEach((g) => {
      for (s = 0; i = g.regex.exec(t); ) {
        const v = i[1].trim();
        if (o = c(v), o === void 0)
          if (typeof u == "function") {
            const p = u(t, i, a);
            o = de(p) ? p : "";
          } else if (a && Object.prototype.hasOwnProperty.call(a, v))
            o = "";
          else if (f) {
            o = i[0];
            continue;
          } else
            this.logger.warn(`missed to pass in variable ${v} for interpolating ${t}`), o = "";
        else !de(o) && !this.useRawValueToEscape && (o = DE(o));
        const b = g.safeValue(o);
        if (t = t.replace(i[0], b), f ? (g.regex.lastIndex += o.length, g.regex.lastIndex -= i[0].length) : g.regex.lastIndex = 0, s++, s >= this.maxReplaces)
          break;
      }
    }), t;
  }
  nest(t, n, r = {}) {
    let a, i, o;
    const s = (l, c) => {
      const u = this.nestingOptionsSeparator;
      if (l.indexOf(u) < 0) return l;
      const f = l.split(new RegExp(`${u}[ ]*{`));
      let d = `{${f[1]}`;
      l = f[0], d = this.interpolate(d, o);
      const h = d.match(/'/g), g = d.match(/"/g);
      (((h == null ? void 0 : h.length) ?? 0) % 2 === 0 && !g || g.length % 2 !== 0) && (d = d.replace(/'/g, '"'));
      try {
        o = JSON.parse(d), c && (o = {
          ...c,
          ...o
        });
      } catch (v) {
        return this.logger.warn(`failed parsing options string in nesting for key ${l}`, v), `${l}${u}${d}`;
      }
      return o.defaultValue && o.defaultValue.indexOf(this.prefix) > -1 && delete o.defaultValue, l;
    };
    for (; a = this.nestingRegexp.exec(t); ) {
      let l = [];
      o = {
        ...r
      }, o = o.replace && !de(o.replace) ? o.replace : o, o.applyPostProcessor = !1, delete o.defaultValue;
      const c = /{.*}/.test(a[1]) ? a[1].lastIndexOf("}") + 1 : a[1].indexOf(this.formatSeparator);
      if (c !== -1 && (l = a[1].slice(c).split(this.formatSeparator).map((u) => u.trim()).filter(Boolean), a[1] = a[1].slice(0, c)), i = n(s.call(this, a[1].trim(), o), o), i && a[0] === t && !de(i)) return i;
      de(i) || (i = DE(i)), i || (this.logger.warn(`missed to resolve ${a[1]} for nesting ${t}`), i = ""), l.length && (i = l.reduce((u, f) => this.format(u, f, r.lng, {
        ...r,
        interpolationkey: a[1].trim()
      }), i.trim())), t = t.replace(a[0], i), this.regexp.lastIndex = 0;
    }
    return t;
  }
}
const dB = (e) => {
  let t = e.toLowerCase().trim();
  const n = {};
  if (e.indexOf("(") > -1) {
    const r = e.split("(");
    t = r[0].toLowerCase().trim();
    const a = r[1].substring(0, r[1].length - 1);
    t === "currency" && a.indexOf(":") < 0 ? n.currency || (n.currency = a.trim()) : t === "relativetime" && a.indexOf(":") < 0 ? n.range || (n.range = a.trim()) : a.split(";").forEach((o) => {
      if (o) {
        const [s, ...l] = o.split(":"), c = l.join(":").trim().replace(/^'+|'+$/g, ""), u = s.trim();
        n[u] || (n[u] = c), c === "false" && (n[u] = !1), c === "true" && (n[u] = !0), isNaN(c) || (n[u] = parseInt(c, 10));
      }
    });
  }
  return {
    formatName: t,
    formatOptions: n
  };
}, UE = (e) => {
  const t = {};
  return (n, r, a) => {
    let i = a;
    a && a.interpolationkey && a.formatParams && a.formatParams[a.interpolationkey] && a[a.interpolationkey] && (i = {
      ...i,
      [a.interpolationkey]: void 0
    });
    const o = r + JSON.stringify(i);
    let s = t[o];
    return s || (s = e(Fc(r), a), t[o] = s), s(n);
  };
}, hB = (e) => (t, n, r) => e(Fc(n), r)(t);
class pB {
  constructor(t = {}) {
    this.logger = ar.create("formatter"), this.options = t, this.init(t);
  }
  init(t, n = {
    interpolation: {}
  }) {
    this.formatSeparator = n.interpolation.formatSeparator || ",";
    const r = n.cacheInBuiltFormats ? UE : hB;
    this.formats = {
      number: r((a, i) => {
        const o = new Intl.NumberFormat(a, {
          ...i
        });
        return (s) => o.format(s);
      }),
      currency: r((a, i) => {
        const o = new Intl.NumberFormat(a, {
          ...i,
          style: "currency"
        });
        return (s) => o.format(s);
      }),
      datetime: r((a, i) => {
        const o = new Intl.DateTimeFormat(a, {
          ...i
        });
        return (s) => o.format(s);
      }),
      relativetime: r((a, i) => {
        const o = new Intl.RelativeTimeFormat(a, {
          ...i
        });
        return (s) => o.format(s, i.range || "day");
      }),
      list: r((a, i) => {
        const o = new Intl.ListFormat(a, {
          ...i
        });
        return (s) => o.format(s);
      })
    };
  }
  add(t, n) {
    this.formats[t.toLowerCase().trim()] = n;
  }
  addCached(t, n) {
    this.formats[t.toLowerCase().trim()] = UE(n);
  }
  format(t, n, r, a = {}) {
    const i = n.split(this.formatSeparator);
    if (i.length > 1 && i[0].indexOf("(") > 1 && i[0].indexOf(")") < 0 && i.find((s) => s.indexOf(")") > -1)) {
      const s = i.findIndex((l) => l.indexOf(")") > -1);
      i[0] = [i[0], ...i.splice(1, s)].join(this.formatSeparator);
    }
    return i.reduce((s, l) => {
      var f;
      const {
        formatName: c,
        formatOptions: u
      } = dB(l);
      if (this.formats[c]) {
        let d = s;
        try {
          const h = ((f = a == null ? void 0 : a.formatParams) == null ? void 0 : f[a.interpolationkey]) || {}, g = h.locale || h.lng || a.locale || a.lng || r;
          d = this.formats[c](s, g, {
            ...u,
            ...a,
            ...h
          });
        } catch (h) {
          this.logger.warn(h);
        }
        return d;
      } else
        this.logger.warn(`there was no format function for ${c}`);
      return s;
    }, t);
  }
}
const mB = (e, t) => {
  e.pending[t] !== void 0 && (delete e.pending[t], e.pendingCount--);
};
class gB extends wh {
  constructor(t, n, r, a = {}) {
    var i, o;
    super(), this.backend = t, this.store = n, this.services = r, this.languageUtils = r.languageUtils, this.options = a, this.logger = ar.create("backendConnector"), this.waitingReads = [], this.maxParallelReads = a.maxParallelReads || 10, this.readingCalls = 0, this.maxRetries = a.maxRetries >= 0 ? a.maxRetries : 5, this.retryTimeout = a.retryTimeout >= 1 ? a.retryTimeout : 350, this.state = {}, this.queue = [], (o = (i = this.backend) == null ? void 0 : i.init) == null || o.call(i, r, a.backend, a);
  }
  queueLoad(t, n, r, a) {
    const i = {}, o = {}, s = {}, l = {};
    return t.forEach((c) => {
      let u = !0;
      n.forEach((f) => {
        const d = `${c}|${f}`;
        !r.reload && this.store.hasResourceBundle(c, f) ? this.state[d] = 2 : this.state[d] < 0 || (this.state[d] === 1 ? o[d] === void 0 && (o[d] = !0) : (this.state[d] = 1, u = !1, o[d] === void 0 && (o[d] = !0), i[d] === void 0 && (i[d] = !0), l[f] === void 0 && (l[f] = !0)));
      }), u || (s[c] = !0);
    }), (Object.keys(i).length || Object.keys(o).length) && this.queue.push({
      pending: o,
      pendingCount: Object.keys(o).length,
      loaded: {},
      errors: [],
      callback: a
    }), {
      toLoad: Object.keys(i),
      pending: Object.keys(o),
      toLoadLanguages: Object.keys(s),
      toLoadNamespaces: Object.keys(l)
    };
  }
  loaded(t, n, r) {
    const a = t.split("|"), i = a[0], o = a[1];
    n && this.emit("failedLoading", i, o, n), !n && r && this.store.addResourceBundle(i, o, r, void 0, void 0, {
      skipCopy: !0
    }), this.state[t] = n ? -1 : 2, n && r && (this.state[t] = 0);
    const s = {};
    this.queue.forEach((l) => {
      eB(l.loaded, [i], o), mB(l, t), n && l.errors.push(n), l.pendingCount === 0 && !l.done && (Object.keys(l.loaded).forEach((c) => {
        s[c] || (s[c] = {});
        const u = l.loaded[c];
        u.length && u.forEach((f) => {
          s[c][f] === void 0 && (s[c][f] = !0);
        });
      }), l.done = !0, l.errors.length ? l.callback(l.errors) : l.callback());
    }), this.emit("loaded", s), this.queue = this.queue.filter((l) => !l.done);
  }
  read(t, n, r, a = 0, i = this.retryTimeout, o) {
    if (!t.length) return o(null, {});
    if (this.readingCalls >= this.maxParallelReads) {
      this.waitingReads.push({
        lng: t,
        ns: n,
        fcName: r,
        tried: a,
        wait: i,
        callback: o
      });
      return;
    }
    this.readingCalls++;
    const s = (c, u) => {
      if (this.readingCalls--, this.waitingReads.length > 0) {
        const f = this.waitingReads.shift();
        this.read(f.lng, f.ns, f.fcName, f.tried, f.wait, f.callback);
      }
      if (c && u && a < this.maxRetries) {
        setTimeout(() => {
          this.read.call(this, t, n, r, a + 1, i * 2, o);
        }, i);
        return;
      }
      o(c, u);
    }, l = this.backend[r].bind(this.backend);
    if (l.length === 2) {
      try {
        const c = l(t, n);
        c && typeof c.then == "function" ? c.then((u) => s(null, u)).catch(s) : s(null, c);
      } catch (c) {
        s(c);
      }
      return;
    }
    return l(t, n, s);
  }
  prepareLoading(t, n, r = {}, a) {
    if (!this.backend)
      return this.logger.warn("No backend was added via i18next.use. Will not load resources."), a && a();
    de(t) && (t = this.languageUtils.toResolveHierarchy(t)), de(n) && (n = [n]);
    const i = this.queueLoad(t, n, r, a);
    if (!i.toLoad.length)
      return i.pending.length || a(), null;
    i.toLoad.forEach((o) => {
      this.loadOne(o);
    });
  }
  load(t, n, r) {
    this.prepareLoading(t, n, {}, r);
  }
  reload(t, n, r) {
    this.prepareLoading(t, n, {
      reload: !0
    }, r);
  }
  loadOne(t, n = "") {
    const r = t.split("|"), a = r[0], i = r[1];
    this.read(a, i, "read", void 0, void 0, (o, s) => {
      o && this.logger.warn(`${n}loading namespace ${i} for language ${a} failed`, o), !o && s && this.logger.log(`${n}loaded namespace ${i} for language ${a}`, s), this.loaded(t, o, s);
    });
  }
  saveMissing(t, n, r, a, i, o = {}, s = () => {
  }) {
    var l, c, u, f, d;
    if ((c = (l = this.services) == null ? void 0 : l.utils) != null && c.hasLoadedNamespace && !((f = (u = this.services) == null ? void 0 : u.utils) != null && f.hasLoadedNamespace(n))) {
      this.logger.warn(`did not save key "${r}" as the namespace "${n}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
      return;
    }
    if (!(r == null || r === "")) {
      if ((d = this.backend) != null && d.create) {
        const h = {
          ...o,
          isUpdate: i
        }, g = this.backend.create.bind(this.backend);
        if (g.length < 6)
          try {
            let v;
            g.length === 5 ? v = g(t, n, r, a, h) : v = g(t, n, r, a), v && typeof v.then == "function" ? v.then((b) => s(null, b)).catch(s) : s(null, v);
          } catch (v) {
            s(v);
          }
        else
          g(t, n, r, a, s, h);
      }
      !t || !t[0] || this.store.addResource(t[0], n, r, a);
    }
  }
}
const qE = () => ({
  debug: !1,
  initAsync: !0,
  ns: ["translation"],
  defaultNS: ["translation"],
  fallbackLng: ["dev"],
  fallbackNS: !1,
  supportedLngs: !1,
  nonExplicitSupportedLngs: !1,
  load: "all",
  preload: !1,
  simplifyPluralSuffix: !0,
  keySeparator: ".",
  nsSeparator: ":",
  pluralSeparator: "_",
  contextSeparator: "_",
  partialBundledLanguages: !1,
  saveMissing: !1,
  updateMissing: !1,
  saveMissingTo: "fallback",
  saveMissingPlurals: !0,
  missingKeyHandler: !1,
  missingInterpolationHandler: !1,
  postProcess: !1,
  postProcessPassResolved: !1,
  returnNull: !1,
  returnEmptyString: !0,
  returnObjects: !1,
  joinArrays: !1,
  returnedObjectHandler: !1,
  parseMissingKeyHandler: !1,
  appendNamespaceToMissingKey: !1,
  appendNamespaceToCIMode: !1,
  overloadTranslationOptionHandler: (e) => {
    let t = {};
    if (typeof e[1] == "object" && (t = e[1]), de(e[1]) && (t.defaultValue = e[1]), de(e[2]) && (t.tDescription = e[2]), typeof e[2] == "object" || typeof e[3] == "object") {
      const n = e[3] || e[2];
      Object.keys(n).forEach((r) => {
        t[r] = n[r];
      });
    }
    return t;
  },
  interpolation: {
    escapeValue: !0,
    format: (e) => e,
    prefix: "{{",
    suffix: "}}",
    formatSeparator: ",",
    unescapePrefix: "-",
    nestingPrefix: "$t(",
    nestingSuffix: ")",
    nestingOptionsSeparator: ",",
    maxReplaces: 1e3,
    skipOnVariables: !0
  },
  cacheInBuiltFormats: !0
}), BE = (e) => {
  var t, n;
  return de(e.ns) && (e.ns = [e.ns]), de(e.fallbackLng) && (e.fallbackLng = [e.fallbackLng]), de(e.fallbackNS) && (e.fallbackNS = [e.fallbackNS]), ((n = (t = e.supportedLngs) == null ? void 0 : t.indexOf) == null ? void 0 : n.call(t, "cimode")) < 0 && (e.supportedLngs = e.supportedLngs.concat(["cimode"])), typeof e.initImmediate == "boolean" && (e.initAsync = e.initImmediate), e;
}, af = () => {
}, vB = (e) => {
  Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((n) => {
    typeof e[n] == "function" && (e[n] = e[n].bind(e));
  });
};
class uc extends wh {
  constructor(t = {}, n) {
    if (super(), this.options = BE(t), this.services = {}, this.logger = ar, this.modules = {
      external: []
    }, vB(this), n && !this.isInitialized && !t.isClone) {
      if (!this.options.initAsync)
        return this.init(t, n), this;
      setTimeout(() => {
        this.init(t, n);
      }, 0);
    }
  }
  init(t = {}, n) {
    this.isInitializing = !0, typeof t == "function" && (n = t, t = {}), t.defaultNS == null && t.ns && (de(t.ns) ? t.defaultNS = t.ns : t.ns.indexOf("translation") < 0 && (t.defaultNS = t.ns[0]));
    const r = qE();
    this.options = {
      ...r,
      ...this.options,
      ...BE(t)
    }, this.options.interpolation = {
      ...r.interpolation,
      ...this.options.interpolation
    }, t.keySeparator !== void 0 && (this.options.userDefinedKeySeparator = t.keySeparator), t.nsSeparator !== void 0 && (this.options.userDefinedNsSeparator = t.nsSeparator);
    const a = (c) => c ? typeof c == "function" ? new c() : c : null;
    if (!this.options.isClone) {
      this.modules.logger ? ar.init(a(this.modules.logger), this.options) : ar.init(null, this.options);
      let c;
      this.modules.formatter ? c = this.modules.formatter : c = pB;
      const u = new jE(this.options);
      this.store = new LE(this.options.resources, this.options);
      const f = this.services;
      f.logger = ar, f.resourceStore = this.store, f.languageUtils = u, f.pluralResolver = new uB(u, {
        prepend: this.options.pluralSeparator,
        simplifyPluralSuffix: this.options.simplifyPluralSuffix
      }), this.options.interpolation.format && this.options.interpolation.format !== r.interpolation.format && this.logger.deprecate("init: you are still using the legacy format function, please use the new approach: https://www.i18next.com/translation-function/formatting"), c && (!this.options.interpolation.format || this.options.interpolation.format === r.interpolation.format) && (f.formatter = a(c), f.formatter.init && f.formatter.init(f, this.options), this.options.interpolation.format = f.formatter.format.bind(f.formatter)), f.interpolator = new fB(this.options), f.utils = {
        hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
      }, f.backendConnector = new gB(a(this.modules.backend), f.resourceStore, f, this.options), f.backendConnector.on("*", (h, ...g) => {
        this.emit(h, ...g);
      }), this.modules.languageDetector && (f.languageDetector = a(this.modules.languageDetector), f.languageDetector.init && f.languageDetector.init(f, this.options.detection, this.options)), this.modules.i18nFormat && (f.i18nFormat = a(this.modules.i18nFormat), f.i18nFormat.init && f.i18nFormat.init(this)), this.translator = new Od(this.services, this.options), this.translator.on("*", (h, ...g) => {
        this.emit(h, ...g);
      }), this.modules.external.forEach((h) => {
        h.init && h.init(this);
      });
    }
    if (this.format = this.options.interpolation.format, n || (n = af), this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
      const c = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
      c.length > 0 && c[0] !== "dev" && (this.options.lng = c[0]);
    }
    !this.services.languageDetector && !this.options.lng && this.logger.warn("init: no languageDetector is used and no lng is defined"), ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"].forEach((c) => {
      this[c] = (...u) => this.store[c](...u);
    }), ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"].forEach((c) => {
      this[c] = (...u) => (this.store[c](...u), this);
    });
    const s = Nl(), l = () => {
      const c = (u, f) => {
        this.isInitializing = !1, this.isInitialized && !this.initializedStoreOnce && this.logger.warn("init: i18next is already initialized. You should call init just once!"), this.isInitialized = !0, this.options.isClone || this.logger.log("initialized", this.options), this.emit("initialized", this.options), s.resolve(f), n(u, f);
      };
      if (this.languages && !this.isInitialized) return c(null, this.t.bind(this));
      this.changeLanguage(this.options.lng, c);
    };
    return this.options.resources || !this.options.initAsync ? l() : setTimeout(l, 0), s;
  }
  loadResources(t, n = af) {
    var i, o;
    let r = n;
    const a = de(t) ? t : this.language;
    if (typeof t == "function" && (r = t), !this.options.resources || this.options.partialBundledLanguages) {
      if ((a == null ? void 0 : a.toLowerCase()) === "cimode" && (!this.options.preload || this.options.preload.length === 0)) return r();
      const s = [], l = (c) => {
        if (!c || c === "cimode") return;
        this.services.languageUtils.toResolveHierarchy(c).forEach((f) => {
          f !== "cimode" && s.indexOf(f) < 0 && s.push(f);
        });
      };
      a ? l(a) : this.services.languageUtils.getFallbackCodes(this.options.fallbackLng).forEach((u) => l(u)), (o = (i = this.options.preload) == null ? void 0 : i.forEach) == null || o.call(i, (c) => l(c)), this.services.backendConnector.load(s, this.options.ns, (c) => {
        !c && !this.resolvedLanguage && this.language && this.setResolvedLanguage(this.language), r(c);
      });
    } else
      r(null);
  }
  reloadResources(t, n, r) {
    const a = Nl();
    return typeof t == "function" && (r = t, t = void 0), typeof n == "function" && (r = n, n = void 0), t || (t = this.languages), n || (n = this.options.ns), r || (r = af), this.services.backendConnector.reload(t, n, (i) => {
      a.resolve(), r(i);
    }), a;
  }
  use(t) {
    if (!t) throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
    if (!t.type) throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
    return t.type === "backend" && (this.modules.backend = t), (t.type === "logger" || t.log && t.warn && t.error) && (this.modules.logger = t), t.type === "languageDetector" && (this.modules.languageDetector = t), t.type === "i18nFormat" && (this.modules.i18nFormat = t), t.type === "postProcessor" && W_.addPostProcessor(t), t.type === "formatter" && (this.modules.formatter = t), t.type === "3rdParty" && this.modules.external.push(t), this;
  }
  setResolvedLanguage(t) {
    if (!(!t || !this.languages) && !(["cimode", "dev"].indexOf(t) > -1)) {
      for (let n = 0; n < this.languages.length; n++) {
        const r = this.languages[n];
        if (!(["cimode", "dev"].indexOf(r) > -1) && this.store.hasLanguageSomeTranslations(r)) {
          this.resolvedLanguage = r;
          break;
        }
      }
      !this.resolvedLanguage && this.languages.indexOf(t) < 0 && this.store.hasLanguageSomeTranslations(t) && (this.resolvedLanguage = t, this.languages.unshift(t));
    }
  }
  changeLanguage(t, n) {
    this.isLanguageChangingTo = t;
    const r = Nl();
    this.emit("languageChanging", t);
    const a = (s) => {
      this.language = s, this.languages = this.services.languageUtils.toResolveHierarchy(s), this.resolvedLanguage = void 0, this.setResolvedLanguage(s);
    }, i = (s, l) => {
      l ? this.isLanguageChangingTo === t && (a(l), this.translator.changeLanguage(l), this.isLanguageChangingTo = void 0, this.emit("languageChanged", l), this.logger.log("languageChanged", l)) : this.isLanguageChangingTo = void 0, r.resolve((...c) => this.t(...c)), n && n(s, (...c) => this.t(...c));
    }, o = (s) => {
      var u, f;
      !t && !s && this.services.languageDetector && (s = []);
      const l = de(s) ? s : s && s[0], c = this.store.hasLanguageSomeTranslations(l) ? l : this.services.languageUtils.getBestMatchFromCodes(de(s) ? [s] : s);
      c && (this.language || a(c), this.translator.language || this.translator.changeLanguage(c), (f = (u = this.services.languageDetector) == null ? void 0 : u.cacheUserLanguage) == null || f.call(u, c)), this.loadResources(c, (d) => {
        i(d, c);
      });
    };
    return !t && this.services.languageDetector && !this.services.languageDetector.async ? o(this.services.languageDetector.detect()) : !t && this.services.languageDetector && this.services.languageDetector.async ? this.services.languageDetector.detect.length === 0 ? this.services.languageDetector.detect().then(o) : this.services.languageDetector.detect(o) : o(t), r;
  }
  getFixedT(t, n, r) {
    const a = (i, o, ...s) => {
      let l;
      typeof o != "object" ? l = this.options.overloadTranslationOptionHandler([i, o].concat(s)) : l = {
        ...o
      }, l.lng = l.lng || a.lng, l.lngs = l.lngs || a.lngs, l.ns = l.ns || a.ns, l.keyPrefix !== "" && (l.keyPrefix = l.keyPrefix || r || a.keyPrefix);
      const c = this.options.keySeparator || ".";
      let u;
      return l.keyPrefix && Array.isArray(i) ? u = i.map((f) => (typeof f == "function" && (f = lv(f, {
        ...this.options,
        ...o
      })), `${l.keyPrefix}${c}${f}`)) : (typeof i == "function" && (i = lv(i, {
        ...this.options,
        ...o
      })), u = l.keyPrefix ? `${l.keyPrefix}${c}${i}` : i), this.t(u, l);
    };
    return de(t) ? a.lng = t : a.lngs = t, a.ns = n, a.keyPrefix = r, a;
  }
  t(...t) {
    var n;
    return (n = this.translator) == null ? void 0 : n.translate(...t);
  }
  exists(...t) {
    var n;
    return (n = this.translator) == null ? void 0 : n.exists(...t);
  }
  setDefaultNamespace(t) {
    this.options.defaultNS = t;
  }
  hasLoadedNamespace(t, n = {}) {
    if (!this.isInitialized)
      return this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages), !1;
    if (!this.languages || !this.languages.length)
      return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages), !1;
    const r = n.lng || this.resolvedLanguage || this.languages[0], a = this.options ? this.options.fallbackLng : !1, i = this.languages[this.languages.length - 1];
    if (r.toLowerCase() === "cimode") return !0;
    const o = (s, l) => {
      const c = this.services.backendConnector.state[`${s}|${l}`];
      return c === -1 || c === 0 || c === 2;
    };
    if (n.precheck) {
      const s = n.precheck(this, o);
      if (s !== void 0) return s;
    }
    return !!(this.hasResourceBundle(r, t) || !this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages || o(r, t) && (!a || o(i, t)));
  }
  loadNamespaces(t, n) {
    const r = Nl();
    return this.options.ns ? (de(t) && (t = [t]), t.forEach((a) => {
      this.options.ns.indexOf(a) < 0 && this.options.ns.push(a);
    }), this.loadResources((a) => {
      r.resolve(), n && n(a);
    }), r) : (n && n(), Promise.resolve());
  }
  loadLanguages(t, n) {
    const r = Nl();
    de(t) && (t = [t]);
    const a = this.options.preload || [], i = t.filter((o) => a.indexOf(o) < 0 && this.services.languageUtils.isSupportedCode(o));
    return i.length ? (this.options.preload = a.concat(i), this.loadResources((o) => {
      r.resolve(), n && n(o);
    }), r) : (n && n(), Promise.resolve());
  }
  dir(t) {
    var a, i;
    if (t || (t = this.resolvedLanguage || (((a = this.languages) == null ? void 0 : a.length) > 0 ? this.languages[0] : this.language)), !t) return "rtl";
    try {
      const o = new Intl.Locale(t);
      if (o && o.getTextInfo) {
        const s = o.getTextInfo();
        if (s && s.direction) return s.direction;
      }
    } catch {
    }
    const n = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"], r = ((i = this.services) == null ? void 0 : i.languageUtils) || new jE(qE());
    return t.toLowerCase().indexOf("-latn") > 1 ? "ltr" : n.indexOf(r.getLanguagePartFromCode(t)) > -1 || t.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
  }
  static createInstance(t = {}, n) {
    const r = new uc(t, n);
    return r.createInstance = uc.createInstance, r;
  }
  cloneInstance(t = {}, n = af) {
    const r = t.forkResourceStore;
    r && delete t.forkResourceStore;
    const a = {
      ...this.options,
      ...t,
      isClone: !0
    }, i = new uc(a);
    if ((t.debug !== void 0 || t.prefix !== void 0) && (i.logger = i.logger.clone(t)), ["store", "services", "language"].forEach((s) => {
      i[s] = this[s];
    }), i.services = {
      ...this.services
    }, i.services.utils = {
      hasLoadedNamespace: i.hasLoadedNamespace.bind(i)
    }, r) {
      const s = Object.keys(this.store.data).reduce((l, c) => (l[c] = {
        ...this.store.data[c]
      }, l[c] = Object.keys(l[c]).reduce((u, f) => (u[f] = {
        ...l[c][f]
      }, u), l[c]), l), {});
      i.store = new LE(s, a), i.services.resourceStore = i.store;
    }
    return i.translator = new Od(i.services, a), i.translator.on("*", (s, ...l) => {
      i.emit(s, ...l);
    }), i.init(a, n), i.translator.options = a, i.translator.backendConnector.services.utils = {
      hasLoadedNamespace: i.hasLoadedNamespace.bind(i)
    }, i;
  }
  toJSON() {
    return {
      options: this.options,
      store: this.store,
      language: this.language,
      languages: this.languages,
      resolvedLanguage: this.resolvedLanguage
    };
  }
}
const vt = uc.createInstance();
vt.createInstance;
vt.dir;
vt.init;
vt.loadResources;
vt.reloadResources;
vt.use;
vt.changeLanguage;
vt.getFixedT;
const yB = vt.t;
vt.exists;
vt.setDefaultNamespace;
vt.hasLoadedNamespace;
vt.loadNamespaces;
vt.loadLanguages;
const {
  slice: bB,
  forEach: wB
} = [];
function xB(e) {
  return wB.call(bB.call(arguments, 1), (t) => {
    if (t)
      for (const n in t)
        e[n] === void 0 && (e[n] = t[n]);
  }), e;
}
function EB(e) {
  return typeof e != "string" ? !1 : [/<\s*script.*?>/i, /<\s*\/\s*script\s*>/i, /<\s*img.*?on\w+\s*=/i, /<\s*\w+\s*on\w+\s*=.*?>/i, /javascript\s*:/i, /vbscript\s*:/i, /expression\s*\(/i, /eval\s*\(/i, /alert\s*\(/i, /document\.cookie/i, /document\.write\s*\(/i, /window\.location/i, /innerHTML/i].some((n) => n.test(e));
}
const VE = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/, SB = function(e, t) {
  const r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
    path: "/"
  }, a = encodeURIComponent(t);
  let i = `${e}=${a}`;
  if (r.maxAge > 0) {
    const o = r.maxAge - 0;
    if (Number.isNaN(o)) throw new Error("maxAge should be a Number");
    i += `; Max-Age=${Math.floor(o)}`;
  }
  if (r.domain) {
    if (!VE.test(r.domain))
      throw new TypeError("option domain is invalid");
    i += `; Domain=${r.domain}`;
  }
  if (r.path) {
    if (!VE.test(r.path))
      throw new TypeError("option path is invalid");
    i += `; Path=${r.path}`;
  }
  if (r.expires) {
    if (typeof r.expires.toUTCString != "function")
      throw new TypeError("option expires is invalid");
    i += `; Expires=${r.expires.toUTCString()}`;
  }
  if (r.httpOnly && (i += "; HttpOnly"), r.secure && (i += "; Secure"), r.sameSite)
    switch (typeof r.sameSite == "string" ? r.sameSite.toLowerCase() : r.sameSite) {
      case !0:
        i += "; SameSite=Strict";
        break;
      case "lax":
        i += "; SameSite=Lax";
        break;
      case "strict":
        i += "; SameSite=Strict";
        break;
      case "none":
        i += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  return r.partitioned && (i += "; Partitioned"), i;
}, QE = {
  create(e, t, n, r) {
    let a = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
      path: "/",
      sameSite: "strict"
    };
    n && (a.expires = /* @__PURE__ */ new Date(), a.expires.setTime(a.expires.getTime() + n * 60 * 1e3)), r && (a.domain = r), document.cookie = SB(e, t, a);
  },
  read(e) {
    const t = `${e}=`, n = document.cookie.split(";");
    for (let r = 0; r < n.length; r++) {
      let a = n[r];
      for (; a.charAt(0) === " "; ) a = a.substring(1, a.length);
      if (a.indexOf(t) === 0) return a.substring(t.length, a.length);
    }
    return null;
  },
  remove(e, t) {
    this.create(e, "", -1, t);
  }
};
var TB = {
  name: "cookie",
  // Deconstruct the options object and extract the lookupCookie property
  lookup(e) {
    let {
      lookupCookie: t
    } = e;
    if (t && typeof document < "u")
      return QE.read(t) || void 0;
  },
  // Deconstruct the options object and extract the lookupCookie, cookieMinutes, cookieDomain, and cookieOptions properties
  cacheUserLanguage(e, t) {
    let {
      lookupCookie: n,
      cookieMinutes: r,
      cookieDomain: a,
      cookieOptions: i
    } = t;
    n && typeof document < "u" && QE.create(n, e, r, a, i);
  }
}, CB = {
  name: "querystring",
  // Deconstruct the options object and extract the lookupQuerystring property
  lookup(e) {
    var r;
    let {
      lookupQuerystring: t
    } = e, n;
    if (typeof window < "u") {
      let {
        search: a
      } = window.location;
      !window.location.search && ((r = window.location.hash) == null ? void 0 : r.indexOf("?")) > -1 && (a = window.location.hash.substring(window.location.hash.indexOf("?")));
      const o = a.substring(1).split("&");
      for (let s = 0; s < o.length; s++) {
        const l = o[s].indexOf("=");
        l > 0 && o[s].substring(0, l) === t && (n = o[s].substring(l + 1));
      }
    }
    return n;
  }
}, OB = {
  name: "hash",
  // Deconstruct the options object and extract the lookupHash property and the lookupFromHashIndex property
  lookup(e) {
    var a;
    let {
      lookupHash: t,
      lookupFromHashIndex: n
    } = e, r;
    if (typeof window < "u") {
      const {
        hash: i
      } = window.location;
      if (i && i.length > 2) {
        const o = i.substring(1);
        if (t) {
          const s = o.split("&");
          for (let l = 0; l < s.length; l++) {
            const c = s[l].indexOf("=");
            c > 0 && s[l].substring(0, c) === t && (r = s[l].substring(c + 1));
          }
        }
        if (r) return r;
        if (!r && n > -1) {
          const s = i.match(/\/([a-zA-Z-]*)/g);
          return Array.isArray(s) ? (a = s[typeof n == "number" ? n : 0]) == null ? void 0 : a.replace("/", "") : void 0;
        }
      }
    }
    return r;
  }
};
let xo = null;
const HE = () => {
  if (xo !== null) return xo;
  try {
    if (xo = typeof window < "u" && window.localStorage !== null, !xo)
      return !1;
    const e = "i18next.translate.boo";
    window.localStorage.setItem(e, "foo"), window.localStorage.removeItem(e);
  } catch {
    xo = !1;
  }
  return xo;
};
var AB = {
  name: "localStorage",
  // Deconstruct the options object and extract the lookupLocalStorage property
  lookup(e) {
    let {
      lookupLocalStorage: t
    } = e;
    if (t && HE())
      return window.localStorage.getItem(t) || void 0;
  },
  // Deconstruct the options object and extract the lookupLocalStorage property
  cacheUserLanguage(e, t) {
    let {
      lookupLocalStorage: n
    } = t;
    n && HE() && window.localStorage.setItem(n, e);
  }
};
let Eo = null;
const $E = () => {
  if (Eo !== null) return Eo;
  try {
    if (Eo = typeof window < "u" && window.sessionStorage !== null, !Eo)
      return !1;
    const e = "i18next.translate.boo";
    window.sessionStorage.setItem(e, "foo"), window.sessionStorage.removeItem(e);
  } catch {
    Eo = !1;
  }
  return Eo;
};
var RB = {
  name: "sessionStorage",
  lookup(e) {
    let {
      lookupSessionStorage: t
    } = e;
    if (t && $E())
      return window.sessionStorage.getItem(t) || void 0;
  },
  cacheUserLanguage(e, t) {
    let {
      lookupSessionStorage: n
    } = t;
    n && $E() && window.sessionStorage.setItem(n, e);
  }
}, _B = {
  name: "navigator",
  lookup(e) {
    const t = [];
    if (typeof navigator < "u") {
      const {
        languages: n,
        userLanguage: r,
        language: a
      } = navigator;
      if (n)
        for (let i = 0; i < n.length; i++)
          t.push(n[i]);
      r && t.push(r), a && t.push(a);
    }
    return t.length > 0 ? t : void 0;
  }
}, DB = {
  name: "htmlTag",
  // Deconstruct the options object and extract the htmlTag property
  lookup(e) {
    let {
      htmlTag: t
    } = e, n;
    const r = t || (typeof document < "u" ? document.documentElement : null);
    return r && typeof r.getAttribute == "function" && (n = r.getAttribute("lang")), n;
  }
}, NB = {
  name: "path",
  // Deconstruct the options object and extract the lookupFromPathIndex property
  lookup(e) {
    var a;
    let {
      lookupFromPathIndex: t
    } = e;
    if (typeof window > "u") return;
    const n = window.location.pathname.match(/\/([a-zA-Z-]*)/g);
    return Array.isArray(n) ? (a = n[typeof t == "number" ? t : 0]) == null ? void 0 : a.replace("/", "") : void 0;
  }
}, kB = {
  name: "subdomain",
  lookup(e) {
    var a, i;
    let {
      lookupFromSubdomainIndex: t
    } = e;
    const n = typeof t == "number" ? t + 1 : 1, r = typeof window < "u" && ((i = (a = window.location) == null ? void 0 : a.hostname) == null ? void 0 : i.match(/^(\w{2,5})\.(([a-z0-9-]{1,63}\.[a-z]{2,6})|localhost)/i));
    if (r)
      return r[n];
  }
};
let J_ = !1;
try {
  document.cookie, J_ = !0;
} catch {
}
const eD = ["querystring", "cookie", "localStorage", "sessionStorage", "navigator", "htmlTag"];
J_ || eD.splice(1, 1);
const MB = () => ({
  order: eD,
  lookupQuerystring: "lng",
  lookupCookie: "i18next",
  lookupLocalStorage: "i18nextLng",
  lookupSessionStorage: "i18nextLng",
  // cache user language
  caches: ["localStorage"],
  excludeCacheFor: ["cimode"],
  // cookieMinutes: 10,
  // cookieDomain: 'myDomain'
  convertDetectedLanguage: (e) => e
});
class tD {
  constructor(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.type = "languageDetector", this.detectors = {}, this.init(t, n);
  }
  init() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      languageUtils: {}
    }, n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    this.services = t, this.options = xB(n, this.options || {}, MB()), typeof this.options.convertDetectedLanguage == "string" && this.options.convertDetectedLanguage.indexOf("15897") > -1 && (this.options.convertDetectedLanguage = (a) => a.replace("-", "_")), this.options.lookupFromUrlIndex && (this.options.lookupFromPathIndex = this.options.lookupFromUrlIndex), this.i18nOptions = r, this.addDetector(TB), this.addDetector(CB), this.addDetector(AB), this.addDetector(RB), this.addDetector(_B), this.addDetector(DB), this.addDetector(NB), this.addDetector(kB), this.addDetector(OB);
  }
  addDetector(t) {
    return this.detectors[t.name] = t, this;
  }
  detect() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.options.order, n = [];
    return t.forEach((r) => {
      if (this.detectors[r]) {
        let a = this.detectors[r].lookup(this.options);
        a && typeof a == "string" && (a = [a]), a && (n = n.concat(a));
      }
    }), n = n.filter((r) => r != null && !EB(r)).map((r) => this.options.convertDetectedLanguage(r)), this.services && this.services.languageUtils && this.services.languageUtils.getBestMatchFromCodes ? n : n.length > 0 ? n[0] : null;
  }
  cacheUserLanguage(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.options.caches;
    n && (this.options.excludeCacheFor && this.options.excludeCacheFor.indexOf(t) > -1 || n.forEach((r) => {
      this.detectors[r] && this.detectors[r].cacheUserLanguage(t, this.options);
    }));
  }
}
tD.type = "languageDetector";
function cv(e) {
  "@babel/helpers - typeof";
  return cv = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, cv(e);
}
function nD() {
  return typeof XMLHttpRequest == "function" || (typeof XMLHttpRequest > "u" ? "undefined" : cv(XMLHttpRequest)) === "object";
}
function LB(e) {
  return !!e && typeof e.then == "function";
}
function zB(e) {
  return LB(e) ? e : Promise.resolve(e);
}
function GE(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(a) {
      return Object.getOwnPropertyDescriptor(e, a).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function YE(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? GE(Object(n), !0).forEach(function(r) {
      jB(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : GE(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function jB(e, t, n) {
  return (t = PB(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function PB(e) {
  var t = IB(e, "string");
  return ro(t) == "symbol" ? t : t + "";
}
function IB(e, t) {
  if (ro(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (ro(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function ro(e) {
  "@babel/helpers - typeof";
  return ro = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, ro(e);
}
var li = typeof fetch == "function" ? fetch : void 0;
typeof global < "u" && global.fetch ? li = global.fetch : typeof window < "u" && window.fetch && (li = window.fetch);
var Uc;
nD() && (typeof global < "u" && global.XMLHttpRequest ? Uc = global.XMLHttpRequest : typeof window < "u" && window.XMLHttpRequest && (Uc = window.XMLHttpRequest));
var Ad;
typeof ActiveXObject == "function" && (typeof global < "u" && global.ActiveXObject ? Ad = global.ActiveXObject : typeof window < "u" && window.ActiveXObject && (Ad = window.ActiveXObject));
typeof li != "function" && (li = void 0);
if (!li && !Uc && !Ad)
  try {
    import("./browser-ponyfill-B9MAqrSY.js").then((e) => e.b).then(function(e) {
      li = e.default;
    }).catch(function() {
    });
  } catch {
  }
var uv = function(t, n) {
  if (n && ro(n) === "object") {
    var r = "";
    for (var a in n)
      r += "&" + encodeURIComponent(a) + "=" + encodeURIComponent(n[a]);
    if (!r) return t;
    t = t + (t.indexOf("?") !== -1 ? "&" : "?") + r.slice(1);
  }
  return t;
}, KE = function(t, n, r, a) {
  var i = function(l) {
    if (!l.ok) return r(l.statusText || "Error", {
      status: l.status
    });
    l.text().then(function(c) {
      r(null, {
        status: l.status,
        data: c
      });
    }).catch(r);
  };
  if (a) {
    var o = a(t, n);
    if (o instanceof Promise) {
      o.then(i).catch(r);
      return;
    }
  }
  typeof fetch == "function" ? fetch(t, n).then(i).catch(r) : li(t, n).then(i).catch(r);
}, XE = !1, FB = function(t, n, r, a) {
  t.queryStringParams && (n = uv(n, t.queryStringParams));
  var i = YE({}, typeof t.customHeaders == "function" ? t.customHeaders() : t.customHeaders);
  typeof window > "u" && typeof global < "u" && typeof global.process < "u" && global.process.versions && global.process.versions.node && (i["User-Agent"] = "i18next-http-backend (node/".concat(global.process.version, "; ").concat(global.process.platform, " ").concat(global.process.arch, ")")), r && (i["Content-Type"] = "application/json");
  var o = typeof t.requestOptions == "function" ? t.requestOptions(r) : t.requestOptions, s = YE({
    method: r ? "POST" : "GET",
    body: r ? t.stringify(r) : void 0,
    headers: i
  }, XE ? {} : o), l = typeof t.alternateFetch == "function" && t.alternateFetch.length >= 1 ? t.alternateFetch : void 0;
  try {
    KE(n, s, a, l);
  } catch (c) {
    if (!o || Object.keys(o).length === 0 || !c.message || c.message.indexOf("not implemented") < 0)
      return a(c);
    try {
      Object.keys(o).forEach(function(u) {
        delete s[u];
      }), KE(n, s, a, l), XE = !0;
    } catch (u) {
      a(u);
    }
  }
}, UB = function(t, n, r, a) {
  r && ro(r) === "object" && (r = uv("", r).slice(1)), t.queryStringParams && (n = uv(n, t.queryStringParams));
  try {
    var i = Uc ? new Uc() : new Ad("MSXML2.XMLHTTP.3.0");
    i.open(r ? "POST" : "GET", n, 1), t.crossDomain || i.setRequestHeader("X-Requested-With", "XMLHttpRequest"), i.withCredentials = !!t.withCredentials, r && i.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"), i.overrideMimeType && i.overrideMimeType("application/json");
    var o = t.customHeaders;
    if (o = typeof o == "function" ? o() : o, o)
      for (var s in o)
        i.setRequestHeader(s, o[s]);
    i.onreadystatechange = function() {
      i.readyState > 3 && a(i.status >= 400 ? i.statusText : null, {
        status: i.status,
        data: i.responseText
      });
    }, i.send(r);
  } catch (l) {
    console && console.log(l);
  }
}, qB = function(t, n, r, a) {
  if (typeof r == "function" && (a = r, r = void 0), a = a || function() {
  }, li && n.indexOf("file:") !== 0)
    return FB(t, n, r, a);
  if (nD() || typeof ActiveXObject == "function")
    return UB(t, n, r, a);
  a(new Error("No fetch and no xhr implementation found!"));
};
function Bs(e) {
  "@babel/helpers - typeof";
  return Bs = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Bs(e);
}
function WE(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(a) {
      return Object.getOwnPropertyDescriptor(e, a).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Wp(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? WE(Object(n), !0).forEach(function(r) {
      rD(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : WE(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function BB(e, t) {
  if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
}
function VB(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n];
    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, aD(r.key), r);
  }
}
function QB(e, t, n) {
  return t && VB(e.prototype, t), Object.defineProperty(e, "prototype", { writable: !1 }), e;
}
function rD(e, t, n) {
  return (t = aD(t)) in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function aD(e) {
  var t = HB(e, "string");
  return Bs(t) == "symbol" ? t : t + "";
}
function HB(e, t) {
  if (Bs(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Bs(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(e);
}
var $B = function() {
  return {
    loadPath: "/locales/{{lng}}/{{ns}}.json",
    addPath: "/locales/add/{{lng}}/{{ns}}",
    parse: function(n) {
      return JSON.parse(n);
    },
    stringify: JSON.stringify,
    parsePayload: function(n, r, a) {
      return rD({}, r, a || "");
    },
    parseLoadPayload: function(n, r) {
    },
    request: qB,
    reloadInterval: typeof window < "u" ? !1 : 60 * 60 * 1e3,
    customHeaders: {},
    queryStringParams: {},
    crossDomain: !1,
    withCredentials: !1,
    overrideMimeType: !1,
    requestOptions: {
      mode: "cors",
      credentials: "same-origin",
      cache: "default"
    }
  };
}, iD = function() {
  function e(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    BB(this, e), this.services = t, this.options = n, this.allOptions = r, this.type = "backend", this.init(t, n, r);
  }
  return QB(e, [{
    key: "init",
    value: function(n) {
      var r = this, a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      if (this.services = n, this.options = Wp(Wp(Wp({}, $B()), this.options || {}), a), this.allOptions = i, this.services && this.options.reloadInterval) {
        var o = setInterval(function() {
          return r.reload();
        }, this.options.reloadInterval);
        Bs(o) === "object" && typeof o.unref == "function" && o.unref();
      }
    }
  }, {
    key: "readMulti",
    value: function(n, r, a) {
      this._readAny(n, n, r, r, a);
    }
  }, {
    key: "read",
    value: function(n, r, a) {
      this._readAny([n], n, [r], r, a);
    }
  }, {
    key: "_readAny",
    value: function(n, r, a, i, o) {
      var s = this, l = this.options.loadPath;
      typeof this.options.loadPath == "function" && (l = this.options.loadPath(n, a)), l = zB(l), l.then(function(c) {
        if (!c) return o(null, {});
        var u = s.services.interpolator.interpolate(c, {
          lng: n.join("+"),
          ns: a.join("+")
        });
        s.loadUrl(u, o, r, i);
      });
    }
  }, {
    key: "loadUrl",
    value: function(n, r, a, i) {
      var o = this, s = typeof a == "string" ? [a] : a, l = typeof i == "string" ? [i] : i, c = this.options.parseLoadPayload(s, l);
      this.options.request(this.options, n, c, function(u, f) {
        if (f && (f.status >= 500 && f.status < 600 || !f.status)) return r("failed loading " + n + "; status code: " + f.status, !0);
        if (f && f.status >= 400 && f.status < 500) return r("failed loading " + n + "; status code: " + f.status, !1);
        if (!f && u && u.message) {
          var d = u.message.toLowerCase(), h = ["failed", "fetch", "network", "load"].find(function(b) {
            return d.indexOf(b) > -1;
          });
          if (h)
            return r("failed loading " + n + ": " + u.message, !0);
        }
        if (u) return r(u, !1);
        var g, v;
        try {
          typeof f.data == "string" ? g = o.options.parse(f.data, a, i) : g = f.data;
        } catch {
          v = "failed parsing " + n + " to json";
        }
        if (v) return r(v, !1);
        r(null, g);
      });
    }
  }, {
    key: "create",
    value: function(n, r, a, i, o) {
      var s = this;
      if (this.options.addPath) {
        typeof n == "string" && (n = [n]);
        var l = this.options.parsePayload(r, a, i), c = 0, u = [], f = [];
        n.forEach(function(d) {
          var h = s.options.addPath;
          typeof s.options.addPath == "function" && (h = s.options.addPath(d, r));
          var g = s.services.interpolator.interpolate(h, {
            lng: d,
            ns: r
          });
          s.options.request(s.options, g, l, function(v, b) {
            c += 1, u.push(v), f.push(b), c === n.length && typeof o == "function" && o(u, f);
          });
        });
      }
    }
  }, {
    key: "reload",
    value: function() {
      var n = this, r = this.services, a = r.backendConnector, i = r.languageUtils, o = r.logger, s = a.language;
      if (!(s && s.toLowerCase() === "cimode")) {
        var l = [], c = function(f) {
          var d = i.toResolveHierarchy(f);
          d.forEach(function(h) {
            l.indexOf(h) < 0 && l.push(h);
          });
        };
        c(s), this.allOptions.preload && this.allOptions.preload.forEach(function(u) {
          return c(u);
        }), l.forEach(function(u) {
          n.allOptions.ns.forEach(function(f) {
            a.read(u, f, "read", null, null, function(d, h) {
              d && o.warn("loading namespace ".concat(f, " for language ").concat(u, " failed"), d), !d && h && o.log("loaded namespace ".concat(f, " for language ").concat(u), h), a.loaded("".concat(u, "|").concat(f), d, h);
            });
          });
        });
      }
    }
  }]);
}();
iD.type = "backend";
const GB = {
  button: {
    add: "Add",
    delete: "Delete",
    deleting: "Deleting...",
    save: "Save",
    saving: "Saving...",
    cancel: "Cancel",
    close: "Close",
    backToChat: "Back to chat",
    expand: "Expand",
    retry: "Try again"
  },
  fallback: {
    noRecords: "No records available for display",
    noItemsSelected: "No items selected",
    noSuggestions: "No suggestions",
    error: "Error",
    loginError: "Login error",
    assistantsNotFound: "Error searching for assistants",
    noName: "No name",
    noTitle: "No title",
    noAssistantSelected: "No assistant selected"
  },
  validation: {
    required: "{{field}} is required",
    minLength: "{{field}} must have at least {{MIN_LENGTH}} characters",
    maxLength: "{{field}} must have a maximum of {{MAX_LENGTH}} characters",
    email: "Invalid email",
    url: "Please enter a valid URL (e.g.: https://example.com)",
    unsupportedImageFormat: "Unsupported image format.",
    maxSizeExeeded: "Maximum allowed size: 1MB.",
    resolutionInvalid: "Required resolution: minimum 96 pixels, maximum 1024 pixels in width or height.",
    failedImageUpload: "Failed to upload the image.",
    missingParameters: "Missing parameters to fetch data",
    invalidRequestParams: "Invalid or missing parameters."
  },
  paginator: {
    showInfo: "Showing {{startItem}}-{{endItem}} of {{totalRows}} items",
    paginator: "Page {{currentPage}} of {{totalPages}}"
  },
  processingStatus: {
    pending: "Pending",
    inProgress: "Processing",
    completed: "Completed",
    error: "Failed",
    active: "Active",
    inactive: "Inactive",
    unknown: "Unknown"
  },
  uploadingStatus: {
    pending: "Waiting for upload...",
    success: "Upload completed",
    error: "Upload failed"
  },
  toast: {
    invalidAuthentication: "Invalid authentication"
  },
  ariaLabels: {
    hidePassword: "Hide password",
    showPassword: "Show password"
  }
}, YB = {
  welcome: "Welcome to {{solutionName}}",
  form: {
    label: {
      email: "Email",
      password: "Password"
    },
    placeholder: {
      email: "Email",
      password: "Password"
    },
    button: {
      submit: "Log in",
      submitting: "Logging in..."
    }
  },
  toast: {
    error: {
      invalidCredentials: "Could not log in with this username and password"
    }
  }
}, KB = {
  titles: {
    actions: "Actions"
  },
  newConversation: "New conversation",
  emptyAssistant: "Start a new conversation with the assistant {{assistantName}}",
  assistantSelect: {
    buttonSelectAriaLabel: "Select assistant {{assistantName}}",
    selectAssistant: "Select assistant"
  },
  prompt: {
    placeholder: "Ask {{assistantName}}...",
    defaultAssistantName: "Assistant",
    scrollToBottom: "Scroll to bottom",
    listening: "Listening...",
    transcriptionError: "Could not transcribe, please try again.",
    privacyNotice: "Conversations in this assistant are not used to train models. The assistant may make mistakes."
  },
  assistantThinking: "Just a second...",
  messageList: {
    sentBy: "Sent by {{role}}"
  },
  messageDialog: {
    copyButton: {
      copy: "Copy",
      copied: "Copied!"
    }
  },
  thread: {
    button: {
      pin: "Pin",
      unpin: "Unpin",
      rename: "Rename"
    },
    dialog: {
      delete: {
        title: "Do you want to delete this conversation?",
        description: "This action is irreversible. Deleting the conversation will permanently remove all messages and they cannot be recovered."
      }
    }
  },
  userMenu: {
    button: {
      profile: "Profile",
      language: "App language",
      deleteAllThreads: "Delete all conversations",
      aiCustomization: "AI Customization",
      knowledgeBase: "Knowledge Base",
      logout: "Log out"
    }
  },
  form: {
    validation: {
      content: {
        minLength: "Enter something to send"
      }
    }
  },
  chatWindow: {
    fullscreen: "Fullscreen",
    fixRight: "Fix to Right"
  },
  error: {
    chatLoading: "Chat Loading Error. Send again!",
    responseLoading: "Could not load the response. Try again."
  },
  toast: {
    error: {
      create: "Could not create the conversation",
      delete: "Could not delete the conversation",
      deleteAll: "Could not delete the conversations",
      rename: "Could not rename the conversation",
      pin: "Could not pin the conversation",
      sendMessage: "Could not send the message"
    },
    success: {
      deleteAll: "All conversations deleted successfully"
    }
  }
}, XB = {
  dialog: {
    title: "Profile"
  },
  form: {
    label: {
      avatar: "Upload a new photo",
      name: "Name",
      email: "Email"
    },
    placeholder: {
      name: "Enter the user's name",
      email: "Enter the user's email"
    }
  },
  toast: {
    error: {
      update: "Could not update the user profile",
      details: "Could not load the user profile"
    }
  }
}, WB = {
  dialog: {
    title: "Are you sure you want to delete the conversation history?",
    description: "This action is irreversible. Deleting the conversation will permanently remove all messages and they cannot be recovered."
  }
}, ZB = {
  sideMenu: {
    button: {
      persona: "Persona",
      restrictions: "Restrictions"
    }
  },
  persona: {
    title: "Persona",
    subtitle: "Assistant's avatar",
    form: {
      title: "Assistant data",
      label: {
        avatar: "Upload a new avatar",
        name: "Assistant Name",
        description: "Persona Description",
        hallucinationLevel: "Creativity Control",
        shortPresentation: "Brief Presentation",
        videoPresentation: "Video Presentation Link"
      },
      description: {
        hallucinationLevel: "Define the level of creativity the assistant should adopt."
      },
      placeholder: {
        name: "Enter the name that will identify the assistant.",
        description: "Describe the assistant's personality and purpose.",
        shortPresentation: "Enter a brief summary of the assistant's presentation.",
        videoPresentation: "Paste the link to the assistant's presentation video here."
      },
      validation: {
        videoPresentation: {
          url: "The video must have a valid URL (ex: https://example.com)"
        },
        avatarId: {
          format: "The avatarId must have an allowed format: jpeg, jpg, png, or be a valid URL."
        }
      }
    },
    tip: {
      title: "Tip",
      description: "Describe the virtual assistant's persona, including personality, tone of voice, communication style, and purpose. This will ensure a natural experience aligned with user expectations."
    },
    toast: {
      success: {
        update: "Assistant updated successfully"
      },
      error: {
        update: "Could not update the assistant",
        details: "Could not load the assistant's data",
        updateWithoutCredentials: "Missing authentication or assistant data"
      }
    }
  },
  restriction: {
    title: "Restrictions",
    subtitle: "AI restriction settings",
    grid: {
      column: {
        title: "Restriction title",
        instruction: "Restriction instructions",
        instructionAnswer: "Example response"
      }
    },
    button: {
      add: "New Restriction"
    },
    form: {
      editTitle: "Edit Restriction",
      label: {
        title: "Restriction title",
        instruction: "Restriction instructions",
        instructionAnswer: "Example response",
        restrictedWords: "Restricted words"
      },
      placeholder: {
        title: "Enter the title that identifies this restriction",
        instruction: "Describe the instructions the assistant must follow when dealing with this restriction",
        instructionAnswer: "Provide an example of the response the assistant should give, adhering to the defined restriction.",
        restrictedWords: "Add forbidden words, press Enter to add"
      },
      validation: {
        restrictedWords: {
          minLength: "Words must have at least {{MIN_LENGTH}} characters",
          maxLength: "Words must have a maximum of {{MAX_WORD_LENGTH}} characters"
        }
      },
      dialog: {
        title: "Confirm deletion of restriction?",
        description: "This action is irreversible. Deleting the restriction will permanently remove all data."
      }
    },
    toast: {
      success: {
        create: "Restriction created successfully",
        update: "Restriction updated successfully",
        delete: "Restriction deleted successfully"
      },
      error: {
        create: "Could not create the restriction",
        update: "Could not update the restriction",
        delete: "Could not delete the restriction",
        details: "Could not load the restriction",
        list: "Could not list the restrictions"
      }
    }
  }
}, JB = {
  faq: {
    title: "FAQ",
    subtitle: "Questions and answers for AI",
    grid: {
      column: {
        title: "Title of the FAQ",
        question: "Question",
        answer: "Answer",
        amountFiles: "Files",
        amountLinks: "Links",
        tags: "Classification tags",
        showMoreTags: "{{hiddenTagsCount}} More",
        status: "Status"
      }
    },
    button: {
      add: "New FAQ"
    },
    form: {
      title: "FAQ",
      editTitle: "Edit FAQ",
      tab: {
        informations: "Information",
        files: "Files"
      },
      label: {
        title: "Title of the FAQ",
        question: "Question",
        answer: "Answer",
        tags: "Classification tags",
        files: "Files",
        links: "External links"
      },
      placeholder: {
        title: "Enter the title that summarizes the FAQ.",
        question: "Enter the question that represents this FAQ.",
        answer: "Enter the answer that will be used as a basis by the assistant.",
        tags: "Add tags to classify this FAQ (press Enter to add)",
        files: {
          title: "Add files",
          subtitle: "Click here or drag files to this area",
          description: "Allowed files: PDF, DOC, DOCX, TXT, JSON, HTML and Markdown."
        },
        links: {
          title: "Add external links",
          subtitle: "Enter a URL, press 'Enter' to add to the list, and click 'Save'.",
          description: "https://example.com"
        }
      },
      fallback: {
        links: {
          list: "Empty link list."
        }
      },
      dialog: {
        title: "Remove FAQ?",
        description: "Do you really want to remove this FAQ? This action is irreversible.",
        tags: {
          title: "Confirm deletion of classification tag?",
          description: "This action is irreversible. Deleting the tag will permanently remove it."
        },
        files: {
          title: "Remove file?",
          description: "Do you really want to remove this file? This action is irreversible."
        },
        links: {
          title: "Remove link?",
          description: "Do you really want to remove this link? This action is irreversible."
        }
      },
      validation: {
        tags: {
          minLength: "Tag cannot be empty"
        },
        files: {
          minLength: "The file name is required"
        }
      }
    },
    toast: {
      success: {
        create: "FAQ created successfully",
        update: "FAQ updated successfully",
        delete: "FAQ deleted successfully",
        links: {
          create: "Links added successfully",
          delete: "FAQ link deleted successfully"
        },
        tags: {
          create: "Classification tags added successfully",
          delete: "FAQ tag deleted successfully"
        },
        files: {
          delete: "FAQ file deleted successfully"
        }
      },
      error: {
        create: "Could not create the FAQ",
        update: "Could not update the FAQ",
        delete: "Could not delete the FAQ",
        details: "Could not load the FAQ",
        list: "Could not list the FAQs",
        links: {
          create: "Could not add links",
          delete: "Could not delete the FAQ link"
        },
        tags: {
          create: "Could not add classification tags",
          delete: "Could not delete the FAQ tag"
        },
        files: {
          delete: "Could not delete the FAQ file"
        }
      }
    }
  },
  prompt: {
    title: "Business Scenario",
    subtitle: "Customized business scenarios for AI",
    grid: {
      column: {
        title: "Title",
        question: "Scenario Instruction",
        answer: "Example Response",
        amountFiles: "Files",
        amountLinks: "Links",
        tags: "Classification tags",
        showMoreTags: "{{hiddenTagsCount}} More",
        status: "Status"
      }
    },
    button: {
      add: "New Business Scenario"
    },
    form: {
      title: "Business Scenario",
      editTitle: "Edit Business Scenario",
      subTitleDefault: "Business Scenario details",
      tab: {
        informations: "Information",
        files: "Files"
      },
      label: {
        title: "Title",
        question: "Business Scenario Instruction",
        answer: "Example Response",
        tags: "Classification tags",
        files: "Files",
        links: "External links"
      },
      placeholder: {
        title: "Enter a title that identifies this Business Scenario.",
        question: "Describe the context or situation where the assistant will be used.",
        answer: "Describe an example of the response the assistant should give in this Business Scenario.",
        tags: "Add tags to classify this Business Scenario (press Enter to add)",
        files: {
          title: "Add files",
          subtitle: "Click here or drag files to this area",
          description: "Allowed files: PDF, DOC, DOCX, TXT, JSON, HTML and Markdown."
        },
        links: {
          title: "Add external links",
          subtitle: "Enter a URL, press 'Enter' to add to the list, and click 'Save'.",
          description: "https://example.com"
        }
      },
      fallback: {
        links: {
          list: "Empty link list."
        }
      },
      dialog: {
        title: "Remove Business Scenario?",
        description: "Do you really want to remove this Business Scenario? This action is irreversible.",
        tags: {
          title: "Confirm deletion of classification tag?",
          description: "This action is irreversible. Deleting the tag will permanently remove it."
        },
        files: {
          title: "Remove file?",
          description: "Do you really want to remove this file? This action is irreversible."
        },
        links: {
          title: "Remove link?",
          description: "Do you really want to remove this link? This action is irreversible."
        }
      },
      validation: {
        tags: {
          minLength: "Tag cannot be empty"
        },
        files: {
          minLength: "The file name is required"
        }
      }
    },
    toast: {
      success: {
        create: "Business Scenario created successfully",
        update: "Business Scenario updated successfully",
        delete: "Business Scenario deleted successfully",
        links: {
          create: "Links added successfully",
          delete: "Business Scenario link deleted successfully"
        },
        tags: {
          create: "Classification tags added successfully",
          delete: "Business Scenario tag deleted successfully"
        },
        files: {
          delete: "Business Scenario file deleted successfully"
        }
      },
      error: {
        create: "Could not create the business scenario",
        update: "Could not update the business scenario",
        delete: "Could not delete the business scenario",
        details: "Could not load the business scenario",
        list: "Could not list the business scenarios",
        links: {
          create: "Could not add links",
          delete: "Could not delete the business scenario link"
        },
        tags: {
          create: "Could not add classification tags",
          delete: "Could not delete the business scenario tag"
        },
        files: {
          delete: "Could not delete the business scenario file"
        }
      }
    }
  }
}, e6 = {
  common: GB,
  login: YB,
  home: KB,
  profile: XB,
  deleteAllThreads: WB,
  aiCustomization: ZB,
  knowledgeBase: JB
}, t6 = {
  button: {
    add: "Agregar",
    delete: "Eliminar",
    deleting: "Eliminando...",
    save: "Guardar",
    saving: "Guardando...",
    cancel: "Cancelar",
    close: "Cerrar",
    backToChat: "Volver al chat",
    expand: "Expandir",
    retry: "Intentar de nuevo"
  },
  fallback: {
    noRecords: "No hay registros disponibles para mostrar",
    noItemsSelected: "No hay elementos seleccionados",
    noSuggestions: "Sin sugerencias",
    error: "Error",
    loginError: "Error al iniciar sesin",
    assistantsNotFound: "Error al buscar asistentes",
    noName: "Sin nombre",
    noTitle: "Sin ttulo",
    noAssistantSelected: "Ningn asistente seleccionado"
  },
  validation: {
    required: "Es necesario proporcionar {{field}}",
    minLength: "{{field}} debe tener al menos {{MIN_LENGTH}} caracteres",
    maxLength: "{{field}} debe tener un mximo de {{MAX_LENGTH}} caracteres",
    email: "Correo electrnico invlido",
    url: "Por favor, ingresa una URL vlida (ej: https://ejemplo.com)",
    unsupportedImageFormat: "Formato de imagen no soportado.",
    maxSizeExeeded: "Tamao mximo permitido: 1MB.",
    resolutionInvalid: "Resolucin permitida: mnimo 96 pxeles, mximo 1024 pxeles de ancho o alto.",
    failedImageUpload: "Error al subir la imagen.",
    missingParameters: "Faltan parmetros requeridos para la solicitud",
    invalidRequestParams: "Parmetros invlidos o faltando."
  },
  paginator: {
    showInfo: "Mostrando {{startItem}}-{{endItem}} de {{totalRows}} elementos",
    paginator: "Pgina {{currentPage}} de {{totalPages}}"
  },
  processingStatus: {
    pending: "Pendiente",
    inProgress: "Procesando",
    completed: "Completado",
    error: "Fall",
    active: "Activo",
    inactive: "Inactivo",
    unknown: "Desconocido"
  },
  uploadingStatus: {
    pending: "Esperando carga...",
    success: "Carga completada",
    error: "Error en la carga"
  },
  toast: {
    invalidAuthentication: "Autenticacin invlida"
  },
  ariaLabels: {
    hidePassword: "Ocultar contrasea",
    showPassword: "Mostrar contrasea"
  }
}, n6 = {
  welcome: "Bienvenido a {{solutionName}}",
  form: {
    label: {
      email: "Correo electrnico",
      password: "Contrasea"
    },
    placeholder: {
      email: "Correo electrnico",
      password: "Contrasea"
    },
    button: {
      submit: "Iniciar sesin",
      submitting: "Iniciando sesin..."
    }
  },
  toast: {
    error: {
      invalidCredentials: "No se pudo iniciar sesin con este usuario y contrasea"
    }
  }
}, r6 = {
  titles: {
    actions: "Acciones"
  },
  newConversation: "Nueva conversacin",
  emptyAssistant: "Inicia una nueva conversacin con el asistente {{assistantName}}",
  assistantSelect: {
    buttonSelectAriaLabel: "Seleccionar asistente {{assistantName}}",
    selectAssistant: "Seleccionar asistente"
  },
  prompt: {
    placeholder: "Pregunta a {{assistantName}}...",
    defaultAssistantName: "Asistente",
    scrollToBottom: "Desplazarse al final",
    listening: "Escuchando...",
    transcriptionError: "NNo se pudo transcribir, grabe nuevamente.",
    privacyNotice: "Las conversaciones en este asistente no se utilizan para entrenar modelos. El asistente puede cometer erros."
  },
  assistantThinking: "Solo un segundo...",
  messageList: {
    sentBy: "Enviado por {{role}}"
  },
  messageDialog: {
    copyButton: {
      copy: "Copiar",
      copied: "Copiado!"
    }
  },
  thread: {
    button: {
      pin: "Anclar",
      unpin: "Desanclar",
      rename: "Renombrar"
    },
    dialog: {
      delete: {
        title: "Quieres eliminar esta conversacin?",
        description: "Esta accin es irreversible. Al eliminar la conversacin, todos los mensajes se eliminarn permanentemente y no podrn recuperarse."
      }
    }
  },
  userMenu: {
    button: {
      profile: "Perfil",
      language: "Idioma de la aplicacin",
      deleteAllThreads: "Eliminar todas las conversaciones",
      aiCustomization: "Personalizacin de IA",
      knowledgeBase: "Base de conocimiento",
      logout: "Cerrar sesin"
    }
  },
  form: {
    validation: {
      content: {
        minLength: "Ingresa algo para enviar"
      }
    }
  },
  chatWindow: {
    fullscreen: "Pantalla Completa",
    fixRight: "Fijar a la Derecha"
  },
  error: {
    chatLoading: "Error de Carga de Chat. Enva de nuevo!",
    responseLoading: "No se pudo cargar la respuesta. Intenta de nuevo."
  },
  toast: {
    error: {
      create: "No se pudo crear la conversacin",
      delete: "No se pudo eliminar la conversacin",
      deleteAll: "No se pudieron eliminar las conversaciones",
      rename: "No se pudo renombrar la conversacin",
      pin: "No se pudo anclar la conversacin",
      sendMessage: "No se pudo enviar el mensaje"
    },
    success: {
      deleteAll: "Todas las conversaciones eliminadas con xito"
    }
  }
}, a6 = {
  dialog: {
    title: "Perfil"
  },
  form: {
    label: {
      avatar: "Sube una nueva foto",
      name: "Nombre",
      email: "Correo electrnico"
    },
    placeholder: {
      name: "Ingresa el nombre del usuario",
      email: "Ingresa el correo electrnico del usuario"
    }
  },
  toast: {
    error: {
      update: "No se pudo actualizar el perfil del usuario",
      details: "No se pudo cargar el perfil del usuario"
    }
  }
}, i6 = {
  dialog: {
    title: "Ests seguro de que quieres eliminar el historial de conversaciones?",
    description: "Esta accin es irreversible. Al eliminar la conversacin, todos los mensajes se eliminarn permanentemente y no podrn recuperarse."
  }
}, o6 = {
  sideMenu: {
    button: {
      persona: "Persona",
      restrictions: "Restricciones"
    }
  },
  persona: {
    title: "Persona",
    subtitle: "Avatar del asistente",
    form: {
      title: "Datos del asistente",
      label: {
        avatar: "Subir un nuevo avatar",
        name: "Nombre del Asistente",
        description: "Descripcin de la persona",
        hallucinationLevel: "Control de Creatividad",
        shortPresentation: "Presentacin Resumida",
        videoPresentation: "Enlace de Presentacin en Video"
      },
      description: {
        hallucinationLevel: "Define el nivel de creatividad que el asistente debe adoptar."
      },
      placeholder: {
        name: "Escribe el nombre que identificar al asistente.",
        description: "Describe la personalidad y el propsito del asistente.",
        shortPresentation: "Escribe un breve resumen de la presentacin del asistente.",
        videoPresentation: "Pega aqu el enlace del video de presentacin del asistente."
      },
      validation: {
        videoPresentation: {
          url: "La URL del video debe ser vlida (ej: https://ejemplo.com)"
        },
        avatarId: {
          format: "El avatarId debe tener un formato permitido: jpeg, jpg, png o ser una URL vlida."
        }
      }
    },
    tip: {
      title: "Consejo",
      description: "Describe la persona del asistente virtual, incluyendo personalidad, tono de voz, estilo de comunicacin y propsito. Esto garantizar una experiencia natural alineada con las expectativas de los usuarios."
    },
    toast: {
      success: {
        update: "Asistente actualizado con xito"
      },
      error: {
        update: "No se pudo actualizar el asistente",
        details: "No se pudieron cargar los datos del asistente",
        updateWithoutCredentials: "Datos de autenticacin o asistente ausentes"
      }
    }
  },
  restriction: {
    title: "Restricciones",
    subtitle: "Configuraciones de restricciones para IA",
    grid: {
      column: {
        title: "Ttulo de la restriccin",
        instruction: "Instrucciones de restriccin",
        instructionAnswer: "Ejemplo de respuesta"
      }
    },
    button: {
      add: "Nova restriccin"
    },
    form: {
      editTitle: "Editar Restriccin",
      label: {
        title: "Ttulo de la restriccin",
        instruction: "Instrucciones de restriccin",
        instructionAnswer: "Ejemplo de respuesta",
        restrictedWords: "Palabras restringidas"
      },
      placeholder: {
        title: "Escribe el ttulo que identifica esta restriccin",
        instruction: "Describe las instrucciones que el asistente debe seguir al manejar esta restriccin",
        instructionAnswer: "Ingresa un ejemplo de respuesta que el asistente debe proporcionar, siguiendo la restriccin definida.",
        restrictedWords: "Agrega palabras prohibidas, presiona Enter para aadir"
      },
      validation: {
        restrictedWords: {
          minLength: "La palabra debe tener al menos {{MIN_LENGTH}} caracteres",
          maxLength: "La palabra debe tener un mximo de {{MAX_WORD_LENGTH}} caracteres"
        }
      },
      dialog: {
        title: "Confirmar eliminacin de restriccin?",
        description: "Esta accin es irreversible. Al eliminar la restriccin, se eliminarn permanentemente todos los datos de este elemento."
      }
    },
    toast: {
      success: {
        create: "Restriccin creada con xito",
        update: "Restriccin actualizada con xito",
        delete: "Restriccin eliminada con xito"
      },
      error: {
        create: "No se pudo crear la restriccin",
        update: "No se pudo actualizar la restriccin",
        delete: "No se pudo eliminar la restriccin",
        details: "No se pudo cargar la restriccin",
        list: "No se pudieron listar las restricciones"
      }
    }
  }
}, s6 = {
  faq: {
    title: "Preguntas frecuentes",
    subtitle: "Preguntas y respuestas para IA",
    grid: {
      column: {
        title: "Ttulo de la FAQ",
        question: "Pregunta",
        answer: "Respuesta",
        amountFiles: "Archivos",
        amountLinks: "Enlaces",
        tags: "Etiquetas de clasificacin",
        showMoreTags: "Ms {{hiddenTagsCount}}",
        status: "Estado"
      }
    },
    button: {
      add: "Nueva FAQ"
    },
    form: {
      title: "FAQ",
      editTitle: "Editar FAQ",
      tab: {
        informations: "Informacin",
        files: "Archivos"
      },
      label: {
        title: "Ttulo de la FAQ",
        question: "Pregunta",
        answer: "Respuesta",
        tags: "Etiquetas de clasificacin",
        files: "Archivos",
        links: "Enlaces externos"
      },
      placeholder: {
        title: "Escribe el ttulo que resume la FAQ.",
        question: "Escribe la pregunta que representa esta FAQ.",
        answer: "Escribe la respuesta que ser utilizada como base por el asistente.",
        tags: "Agrega etiquetas para clasificar esta FAQ (presiona Enter para aadir)",
        files: {
          title: "Adjunta archivos",
          subtitle: "Haz clic aqu o arrastra archivos a esta rea",
          description: "Archivos permitidos: PDF, DOC, DOCX, TXT, JSON, HTML e Markdown."
        },
        links: {
          title: "Agregar enlaces externos",
          subtitle: "Ingresa una URL, presiona 'Enter' para aadirla a la lista y haz clic en 'Guardar'.",
          description: "https://ejemplo.com"
        }
      },
      fallback: {
        links: {
          list: "Lista de enlaces vaca."
        }
      },
      dialog: {
        title: "Eliminar FAQ?",
        description: "Realmente quieres eliminar esta FAQ? Esta accin es irreversible.",
        tags: {
          title: "Confirmar eliminacin de la etiqueta de clasificacin?",
          description: "Esta accin es irreversible. Al eliminar la etiqueta, ser eliminada permanentemente."
        },
        files: {
          title: "Eliminar archivo?",
          description: "Realmente quieres eliminar este archivo? Esta accin es irreversible."
        },
        links: {
          title: "Eliminar enlace?",
          description: "Realmente quieres eliminar este enlace? Esta accin es irreversible."
        }
      },
      validation: {
        tags: {
          minLength: "La etiqueta no puede estar vaca"
        },
        files: {
          minLength: "El nombre del archivo es obligatorio"
        }
      }
    },
    toast: {
      success: {
        create: "FAQ creada con xito",
        update: "FAQ actualizada con xito",
        delete: "FAQ eliminada con xito",
        links: {
          create: "Enlaces aadidos con xito",
          delete: "Enlace de FAQ eliminado con xito"
        },
        tags: {
          create: "Etiquetas de clasificacin aadidas con xito",
          delete: "Etiqueta de FAQ eliminada con xito"
        },
        files: {
          delete: "Archivo de FAQ eliminado con xito"
        }
      },
      error: {
        create: "No se pudo crear la FAQ",
        update: "No se pudo actualizar la FAQ",
        delete: "No se pudo eliminar la FAQ",
        details: "No se pudo cargar la FAQ",
        list: "No se pudieron listar las FAQs",
        links: {
          create: "No se pudieron aadir enlaces",
          delete: "No se pudo eliminar el enlace de FAQ"
        },
        tags: {
          create: "No se pudieron aadir etiquetas de clasificacin",
          delete: "No se pudo eliminar la etiqueta de FAQ"
        },
        files: {
          delete: "No se pudo eliminar el archivo de FAQ"
        }
      }
    }
  },
  prompt: {
    title: "Escenario de Negocio",
    subtitle: "Escenarios de Negocio personalizados para IA",
    grid: {
      column: {
        title: "Ttulo",
        question: "Instruccin del Escenario",
        answer: "Ejemplo de Respuesta",
        amountFiles: "Archivos",
        amountLinks: "Enlaces",
        tags: "Etiquetas de clasificacin",
        showMoreTags: "Ms {{hiddenTagsCount}}",
        status: "Estado"
      }
    },
    button: {
      add: "Nuevo Escenario de Negocio"
    },
    form: {
      title: "Escenario de Negocio",
      editTitle: "Editar Escenario de Negocio",
      subTitleDefault: "Detalles del Escenario de Negocio",
      tab: {
        informations: "Informacin",
        files: "Archivos"
      },
      label: {
        title: "Ttulo",
        question: "Instruccin del Escenario de Negocio",
        answer: "Ejemplo de Respuesta",
        tags: "Etiquetas de clasificacin",
        files: "Archivos",
        links: "Enlaces externos"
      },
      placeholder: {
        title: "Escribe un ttulo que identifique este Escenario de Negocio.",
        question: "Describe el contexto o situacin donde el asistente ser utilizado.",
        answer: "Describe un ejemplo de respuesta que el asistente debe dar en este Escenario de Negocio.",
        tags: "Agrega etiquetas para clasificar este Escenario de Negocio (presiona Enter para aadir)",
        files: {
          title: "Adjunta archivos",
          subtitle: "Haz clic aqu o arrastra archivos a esta rea",
          description: "Archivos permitidos: PDF, DOC, DOCX, TXT, JSON, HTML e Markdown."
        },
        links: {
          title: "Agregar enlaces externos",
          subtitle: "Ingresa una URL, presiona 'Enter' para aadirla a la lista y haz clic en 'Guardar'.",
          description: "https://ejemplo.com"
        }
      },
      fallback: {
        links: {
          list: "Lista de enlaces vaca."
        }
      },
      dialog: {
        title: "Eliminar Escenario de Negocio?",
        description: "Realmente quieres eliminar este Escenario de Negocio? Esta accin es irreversible.",
        tags: {
          title: "Confirmar eliminacin de la etiqueta de clasificacin?",
          description: "Esta accin es irreversible. Al eliminar la etiqueta, ser eliminada permanentemente."
        },
        files: {
          title: "Eliminar archivo?",
          description: "Realmente quieres eliminar este archivo? Esta accin es irreversible."
        },
        links: {
          title: "Eliminar enlace?",
          description: "Realmente quieres eliminar este enlace? Esta accin es irreversible."
        }
      },
      validation: {
        tags: {
          minLength: "La etiqueta no puede estar vaca"
        },
        files: {
          minLength: "El nombre del archivo es obligatorio"
        }
      }
    },
    toast: {
      success: {
        create: "Escenario de Negocio creado con xito",
        update: "Escenario de Negocio actualizado con xito",
        delete: "Escenario de Negocio eliminado con xito",
        links: {
          create: "Enlaces aadidos con xito",
          delete: "Enlace de escenario de negocio eliminado con xito"
        },
        tags: {
          create: "Etiquetas de clasificacin aadidas con xito",
          delete: "Etiqueta de escenario de negocio eliminada con xito"
        },
        files: {
          delete: "Archivo de escenario de negocio eliminado con xito"
        }
      },
      error: {
        create: "No se pudo crear el escenario de negocio",
        update: "No se pudo actualizar el escenario de negocio",
        delete: "No se pudo eliminar el escenario de negocio",
        details: "No se pudo cargar el escenario de negocio",
        list: "No se pudieron listar los escenarios de negocio",
        links: {
          create: "No se pudieron aadir enlaces",
          delete: "No se pudo eliminar el enlace de escenario de negocio"
        },
        tags: {
          create: "No se pudieron aadir etiquetas de clasificacin",
          delete: "No se pudo eliminar la etiqueta de escenario de negocio"
        },
        files: {
          delete: "No se pudo eliminar el archivo de escenario de negocio"
        }
      }
    }
  }
}, l6 = {
  common: t6,
  login: n6,
  home: r6,
  profile: a6,
  deleteAllThreads: i6,
  aiCustomization: o6,
  knowledgeBase: s6
}, c6 = {
  button: {
    add: "Adicionar",
    delete: "Excluir",
    deleting: "Excluindo...",
    save: "Salvar",
    saving: "Salvando...",
    cancel: "Cancelar",
    close: "Fechar",
    backToChat: "Voltar para o chat",
    expand: "Expandir",
    retry: "Tentar novamente"
  },
  fallback: {
    noRecords: "Nenhum registro disponvel para exibio",
    noItemsSelected: "Nenhum item selecionado",
    noSuggestions: "Nenhuma sugesto",
    error: "Erro",
    loginError: "Erro ao fazer login",
    assistantsNotFound: "Erro ao buscar assistentes",
    noName: "Sem nome",
    noTitle: "Sem ttulo",
    noAssistantSelected: "Nenhum assistente selecionado"
  },
  validation: {
    minLength: "{{field}} deve ter no mnimo {{MIN_LENGTH}} caracteres",
    maxLength: "{{field}} deve ter no mximo {{MAX_LENGTH}} caracteres",
    required: " necessrio fornecer {{field}}",
    email: "E-mail invlido",
    url: "Por favor, insira uma URL vlida (ex.: https://exemplo.com)",
    unsupportedImageFormat: "Formato de imagem no suportado.",
    maxSizeExeeded: "Tamanho mximo permitido: 1MB.",
    resolutionInvalid: "Resoluo indicada: mnimo 96 pixels, mximo 1024 pixels em largura ou altura.",
    failedImageUpload: "Falha ao enviar a imagem.",
    missingParameters: "Parmetros ausentes ou invlidos.",
    invalidRequestParams: "Parmetros invlidos ou faltando."
  },
  paginator: {
    showInfo: "Mostrando {{startItem}}-{{endItem}} de {{totalRows}} itens",
    paginator: "Pgina {{currentPage}} de {{totalPages}}",
    loading: "Carregando..."
  },
  processingStatus: {
    pending: "Aguardando",
    inProgress: "Processando",
    completed: "Finalizado",
    error: "Falhou",
    active: "Ativo",
    inactive: "Inativo",
    unknown: "Desconhecido"
  },
  uploadingStatus: {
    pending: "Aguardando upload...",
    success: "Upload concludo",
    error: "Erro no upload"
  },
  toast: {
    invalidAuthentication: "Autenticao invlida"
  },
  ariaLabels: {
    hidePassword: "Ocultar senha",
    showPassword: "Exibir senha"
  }
}, u6 = {
  welcome: "Bem-vindo ao {{solutionName}}",
  form: {
    label: {
      email: "E-mail",
      password: "Senha"
    },
    placeholder: {
      email: "E-mail",
      password: "Senha"
    },
    button: {
      submit: "Entrar",
      submitting: "Entrando..."
    }
  },
  toast: {
    error: {
      invalidCredentials: "No foi possvel realizar o login com este usurio e senha"
    }
  }
}, f6 = {
  titles: {
    actions: "Aes"
  },
  newConversation: "Nova conversa",
  emptyAssistant: "Inicie uma nova conversa com o assistente {{assistantName}}",
  assistantSelect: {
    buttonSelectAriaLabel: "Selecionar assistente {{assistantName}}",
    selectAssistant: "Selecionar assistente"
  },
  prompt: {
    placeholder: "Pergunte  {{assistantName}}...",
    defaultAssistantName: "Assistente",
    scrollToBottom: "Rolar para baixo",
    listening: "Ouvindo...",
    transcriptionError: "No foi possvel transcrever, grave novamente.",
    privacyNotice: "As conversas neste assistente no so usadas para treinar modelos. O assistente pode cometer erros."
  },
  assistantThinking: "S um segundo...",
  messageList: {
    sentBy: "Enviado por {{role}}"
  },
  messageDialog: {
    copyButton: {
      copy: "Copiar",
      copied: "Copiado!"
    }
  },
  thread: {
    button: {
      pin: "Fixar",
      unpin: "Desafixar",
      rename: "Renomear"
    },
    dialog: {
      delete: {
        title: "Confirma a excluso desta conversa?",
        description: "Esta ao  irreversvel. Ao excluir a conversa, todos os dados sero permanentemente removidos."
      }
    }
  },
  userMenu: {
    button: {
      profile: "Perfil",
      language: "Idioma do aplicativo",
      deleteAllThreads: "Excluir todas as conversas",
      aiCustomization: "Customizao IA",
      knowledgeBase: "Base de conhecimento",
      logout: "Sair"
    }
  },
  form: {
    validation: {
      content: {
        minLength: "Digite algo para enviar"
      }
    }
  },
  chatWindow: {
    fullscreen: "Tela Cheia",
    fixRight: "Fixar  Direita"
  },
  error: {
    chatLoading: "Erro de Carregamento de Chat. Envie novamente!",
    responseLoading: "No foi possvel carregar a resposta. Tente novamente."
  },
  toast: {
    error: {
      create: "No foi possvel criar a conversa",
      delete: "No foi possvel excluir a conversa",
      deleteAll: "No foi possvel excluir as conversas",
      rename: "No foi possvel renomear a conversa",
      pin: "No foi possvel favoritar a conversa",
      sendMessage: "No foi possvel enviar a mensagem"
    },
    success: {
      deleteAll: "Todas as conversas excludas com sucesso"
    }
  }
}, d6 = {
  dialog: {
    title: "Perfil"
  },
  form: {
    label: {
      avatar: "Insira uma nova foto",
      name: "Nome",
      email: "E-mail"
    },
    placeholder: {
      name: "Digite o nome do usurio",
      email: "Digite o e-mail do usurio"
    }
  },
  toast: {
    error: {
      update: "No foi possvel atualizar o perfil do usurio",
      details: "No foi possvel carregar o perfil do usurio"
    }
  }
}, h6 = {
  dialog: {
    title: "Confirma a excluso de todas as conversas?",
    description: "Esta ao  irreversvel. Ao excluir todas as conversas, todos os dados sero permanentemente removidos."
  }
}, p6 = {
  sideMenu: {
    button: {
      persona: "Persona",
      restrictions: "Restries"
    }
  },
  persona: {
    title: "Persona",
    subtitle: "Avatar do assistente",
    form: {
      title: "Dados do assistente",
      label: {
        avatar: "Insira um novo avatar",
        name: "Nome do Assistente",
        description: "Descrio da persona",
        hallucinationLevel: "Controle de Criatividade",
        shortPresentation: "Apresentao Resumida",
        videoPresentation: "Link de Apresentao em Vdeo"
      },
      description: {
        hallucinationLevel: "Defina o nvel de criatividade que o assistente deve adotar."
      },
      placeholder: {
        name: "Digite o nome que identificar o assistente.",
        description: "Descreva a personalidade e o propsito do assistente.",
        shortPresentation: "Digite um resumo breve da apresentao do assistente.",
        videoPresentation: "Cole aqui o link do vdeo de apresentao do assistente."
      },
      validation: {
        videoPresentation: {
          url: "A URL do vdeo deve ser vlida (ex: https://exemplo.com)"
        },
        avatarId: {
          format: "O avatarId deve ter um formato permitido: jpeg, jpg, png ou ser uma URL vlida."
        }
      }
    },
    tip: {
      title: "Dica",
      description: "Descreva a persona do assistente virtual, incluindo personalidade, tom de voz, estilo de comunicao e propsito. Isso garantir uma experincia natural e alinhada s expectativas dos usurios."
    },
    toast: {
      success: {
        update: "Assistente atualizado com sucesso"
      },
      error: {
        update: "No foi possvel atualizar o assistente",
        details: "No foi possvel carregar os dados do assistente",
        updateWithoutCredentials: "Dados de autenticao ou assistente ausentes"
      }
    }
  },
  restriction: {
    title: "Restries",
    subtitle: "Configuraes de restries para IA",
    grid: {
      column: {
        title: "Ttulo da restrio",
        instruction: "Instrues de restrio",
        instructionAnswer: "Exemplo de resposta"
      }
    },
    button: {
      add: "Nova Restrio"
    },
    form: {
      editTitle: "Editar Restrio",
      label: {
        title: "Ttulo da restrio",
        instruction: "Instrues de restrio",
        instructionAnswer: "Exemplo de resposta",
        restrictedWords: "Palavras restritas"
      },
      placeholder: {
        title: "Digite o ttulo que identifica esta restrio",
        instruction: "Descreva as instrues que o assistente deve seguir ao lidar com esta restrio",
        instructionAnswer: "Insira um exemplo de resposta que o assistente deve fornecer, seguindo a restrio definida.",
        restrictedWords: "Adicione palavras proibidas, pressione Enter para adicionar"
      },
      validation: {
        restrictedWords: {
          minLength: "Palavra deve ter no mnimo {{MIN_LENGTH}} caracteres",
          maxLength: "Palavra deve ter no mximo {{MAX_WORD_LENGTH}} caracteres"
        }
      },
      dialog: {
        title: "Confirma a excluso da restrio?",
        description: "Esta ao  irreversvel. Ao excluir a restrio, todos os dados sero permanentemente removidos."
      }
    },
    toast: {
      success: {
        create: "Restrio criada com sucesso",
        update: "Restrio atualizada com sucesso",
        delete: "Restrio excluda com sucesso"
      },
      error: {
        create: "No foi possvel criar a restrio",
        update: "No foi possvel atualizar a restrio",
        delete: "No foi possvel excluir a restrio",
        details: "No foi possvel carregar a restrio",
        list: "No foi possvel listar as restries"
      }
    }
  }
}, m6 = {
  faq: {
    title: "FAQ",
    subtitle: "Perguntas e respostas para IA",
    grid: {
      column: {
        title: "Ttulo da FAQ",
        question: "Pergunta",
        answer: "Resposta",
        amountFiles: "Arquivos",
        amountLinks: "Links",
        tags: "Etiquetas de classificao",
        showMoreTags: "Mais {{hiddenTagsCount}}",
        status: "Status"
      }
    },
    button: {
      add: "Nova FAQ"
    },
    form: {
      title: "FAQ",
      editTitle: "Editar FAQ",
      tab: {
        informations: "Informaes",
        files: "Arquivos"
      },
      label: {
        title: "Ttulo da FAQ",
        question: "Pergunta",
        answer: "Resposta",
        tags: "Etiquetas de classificao",
        files: "Arquivos",
        links: "Links externos"
      },
      placeholder: {
        title: "Digite o ttulo que resume a FAQ.",
        question: "Digite a pergunta que representa esta FAQ.",
        answer: "Digite a resposta que ser utilizada como base pelo assistente.",
        tags: "Adicione etiquetas para classificar esta FAQ (pressione Enter para adicionar)",
        files: {
          title: "Adicionar arquivos",
          subtitle: "Clique aqui ou arraste os arquivos nesta rea",
          description: "Arquivos permitidos: PDF, DOC, DOCX, TXT, JSON, HTML e Markdown."
        },
        links: {
          title: "Adicionar links externos",
          subtitle: "Digite uma URL, pressione 'Enter' para adicionar a lista e clique em 'Salvar'.",
          description: "https://exemplo.com"
        }
      },
      fallback: {
        links: {
          list: "Lista de links vazia."
        }
      },
      dialog: {
        title: "Confirma a excluso da FAQ?",
        description: "Esta ao  irreversvel. Ao excluir a FAQ, ela ser permanentemente removida.",
        tags: {
          title: "Confirma a excluso da etiqueta de classificao?",
          description: "Esta ao  irreversvel. Ao excluir a etiqueta, ela ser permanentemente removida."
        },
        files: {
          title: "Confirma a excluso do arquivo?",
          description: "Esta ao  irreversvel. Ao excluir o arquivo, ele ser permanentemente removido."
        },
        links: {
          title: "Confirma a excluso do link?",
          description: "Esta ao  irreversvel. Ao excluir o link, ele ser permanentemente removido."
        }
      },
      validation: {
        tags: {
          minLength: "Etiqueta no pode ser vazia"
        },
        files: {
          minLength: "O nome do arquivo  obrigatrio"
        }
      }
    },
    toast: {
      success: {
        create: "FAQ criada com sucesso",
        update: "FAQ atualizada com sucesso",
        delete: "FAQ excluda com sucesso",
        links: {
          create: "Links adicionados com sucesso",
          delete: "Link FAQ excludo com sucesso"
        },
        tags: {
          create: "Etiquetas de classificao adicionadas com sucesso",
          delete: "Etiqueta FAQ excluda com sucesso"
        },
        files: {
          delete: "Arquivo FAQ excludo com sucesso"
        }
      },
      error: {
        create: "No foi possvel criar a FAQ",
        update: "No foi possvel atualizar a FAQ",
        delete: "No foi possvel excluir a FAQ",
        details: "No foi possvel carregar a FAQ",
        list: "No foi possvel listar as FAQs",
        links: {
          create: "No foi possvel adicionar links",
          delete: "No foi possvel excluir o link FAQ"
        },
        tags: {
          create: "No foi possvel adicionar etiquetas de classificao",
          delete: "No foi possvel excluir a etiqueta FAQ"
        },
        files: {
          delete: "No foi possvel excluir o arquivo FAQ"
        }
      }
    }
  },
  prompt: {
    title: "Cenrio de Negcio",
    subtitle: "Cenrios de Negcio personalizados para IA",
    grid: {
      column: {
        title: "Ttulo",
        question: "Instruo de Cenrio",
        answer: "Exemplo de Resposta",
        amountFiles: "Arquivos",
        amountLinks: "Links",
        tags: "Etiquetas de classificao",
        showMoreTags: "Mais {{hiddenTagsCount}}",
        status: "Status"
      }
    },
    button: {
      add: "Novo Cenrio de Negcio"
    },
    form: {
      title: "Cenrio de Negcio",
      editTitle: "Editar Cenrio de Negcio",
      subTitleDefault: "Detalhes do Cenrio de Negcio",
      tab: {
        informations: "Informaes",
        files: "Arquivos"
      },
      label: {
        title: "Ttulo",
        question: "Instruo de Cenrio de Negcio",
        answer: "Exemplo de Resposta",
        tags: "Etiquetas de classificao",
        files: "Arquivos",
        links: "Links externos"
      },
      placeholder: {
        title: "Digite um ttulo que identifique este Cenrio de Negcio.",
        question: "Descreva o contexto ou situao onde o assistente ser utilizado.",
        answer: "Descreva um exemplo de resposta que o assistente deve dar neste Cenrio de Negcio.",
        tags: "Adicione etiquetas para classificar este Cenrio de Negcio (pressione Enter para adicionar)",
        files: {
          title: "Adicionar arquivos",
          subtitle: "Clique aqui ou arraste os arquivos nesta rea",
          description: "Arquivos permitidos: PDF, DOC, DOCX, TXT, JSON, HTML e Markdown."
        },
        links: {
          title: "Adicionar links externos",
          subtitle: "Digite uma URL, pressione 'Enter' para adicionar a lista e clique em 'Salvar'.",
          description: "https://exemplo.com"
        }
      },
      fallback: {
        links: {
          list: "Lista de links vazia."
        }
      },
      dialog: {
        title: "Confirma a excluso do Cenrio de Negcio?",
        description: "Esta ao  irreversvel. Ao excluir o Cenrio de Negcio, ele ser permanentemente removido.",
        tags: {
          title: "Confirma a excluso da etiqueta de classificao?",
          description: "Esta ao  irreversvel. Ao excluir a etiqueta, ela ser permanentemente removida."
        },
        files: {
          title: "Confirma a excluso do arquivo?",
          description: "Esta ao  irreversvel. Ao excluir o arquivo, ele ser permanentemente removido."
        },
        links: {
          title: "Confirma a excluso do link?",
          description: "Esta ao  irreversvel. Ao excluir o link, ele ser permanentemente removido."
        }
      },
      validation: {
        tags: {
          minLength: "Etiqueta no pode ser vazia"
        },
        files: {
          minLength: "O nome do arquivo  obrigatrio"
        }
      }
    },
    toast: {
      success: {
        create: "Cenrio de Negcio criado com sucesso",
        update: "Cenrio de Negcio atualizado com sucesso",
        delete: "Cenrio de Negcio excludo com sucesso",
        links: {
          create: "Links adicionados com sucesso",
          delete: "Link do Cenrio de Negcio excludo com sucesso"
        },
        tags: {
          create: "Etiquetas de classificao adicionadas com sucesso",
          delete: "Etiqueta do Cenrio de Negcio excluda com sucesso"
        },
        files: {
          delete: "Arquivo do Cenrio de Negcio excludo com sucesso"
        }
      },
      error: {
        create: "No foi possvel criar o Cenrio de Negcio",
        update: "No foi possvel atualizar o Cenrio de Negcio",
        delete: "No foi possvel excluir o Cenrio de Negcio",
        details: "No foi possvel carregar o Cenrio de Negcio",
        list: "No foi possvel listar os Cenrios de Negcio",
        links: {
          create: "No foi possvel adicionar links",
          delete: "No foi possvel excluir o link do Cenrio de Negcio"
        },
        tags: {
          create: "No foi possvel adicionar etiquetas de classificao",
          delete: "No foi possvel excluir a etiqueta do Cenrio de Negcio"
        },
        files: {
          delete: "No foi possvel excluir o arquivo do Cenrio de Negcio"
        }
      }
    }
  }
}, g6 = {
  common: c6,
  login: u6,
  home: f6,
  profile: d6,
  deleteAllThreads: h6,
  aiCustomization: p6,
  knowledgeBase: m6
}, oD = typeof window < "u" && typeof document < "u", sD = new tD(), v6 = () => {
  if (!oD)
    return;
  const e = document.querySelector("pas-assistant-embedded");
  if (!e)
    return;
  const t = e.getAttribute("language");
  if (!t || t.trim() === "")
    return;
  const n = t.trim().toLowerCase();
  if (["pt-br", "en-us", "es-es"].includes(n)) {
    const a = n.split("-");
    if (a.length === 2)
      return `${a[0]}-${a[1].toUpperCase()}`;
  }
};
sD.addDetector({
  name: "customDetector",
  lookup() {
    var n;
    if (!oD)
      return "pt-BR";
    if (document.querySelector("pas-assistant-embedded")) {
      const r = v6();
      return r || "pt-BR";
    }
    return localStorage.getItem("i18nextLng") || ((n = document.cookie.split("; ").find((r) => r.startsWith("i18next="))) == null ? void 0 : n.split("=")[1]) || "pt-BR";
  }
});
vt.use(iD).use(sD).use(QI).init({
  fallbackLng: "pt-BR",
  defaultNS: "translation",
  interpolation: {
    escapeValue: !1
  },
  backend: {
    loadPath: "/locales/{{lng}}/{{ns}}.json"
  },
  detection: {
    order: ["customDetector"],
    caches: ["cookie", "localStorage"],
    lookupLocalStorage: "i18nextLng",
    lookupCookie: "i18next",
    cookieMinutes: 60 * 24 * 365
  },
  resources: {
    "pt-BR": { translation: g6 },
    "en-US": { translation: e6 },
    "es-ES": { translation: l6 }
  },
  react: {
    useSuspense: !0
  }
});
function lD({
  uri: e,
  devtools: t,
  hostname: n,
  apiKey: r,
  authToken: a,
  userId: i
}) {
  const o = ol(), s = n ?? o.hostname ?? "embed-host";
  !n && !o.hostname && console.warn(
    ' hostname attribute not provided to <pas-assistant-embedded>. Using fallback "embed-host".'
  );
  const l = r ?? o.apiKey, c = a ?? o.token, u = i ?? o.userId, f = Y_(() => {
  }), d = X4({
    uri: e
  }), h = H4((v, { headers: b }) => {
    const p = {
      ...b,
      "x-hostname": s,
      "accept-language": vt.language
    };
    return l && (p["x-api-key"] = l), u && (p["x-user-id"] = u), c && (p.Authorization = `Bearer ${c}`), {
      headers: p
    };
  });
  return {
    apolloClient: new DA({
      link: gr.from([f, h, d]),
      cache: new RA({ addTypename: !1 }),
      devtools: {
        enabled: t
      }
    })
  };
}
const y6 = y.lazy(() => import("./layout-uxVRDtJc.js")), b6 = y.lazy(() => import("./layout-ChV2USKu.js")), w6 = y.lazy(() => import("./page-B81Ock39.js")), x6 = y.lazy(() => import("./page-CxVhG5Fj.js").then((e) => e.y)), E6 = [
  {
    element: /* @__PURE__ */ N.jsx(y6, {}),
    children: [
      {
        element: /* @__PURE__ */ N.jsx(b6, {}),
        children: [
          {
            index: !0,
            element: /* @__PURE__ */ N.jsx(w6, {})
          },
          {
            path: ":assistantId",
            element: /* @__PURE__ */ N.jsx(x6, {})
          }
        ]
      }
    ]
  }
], S6 = (e, t) => {
  const n = "bg-list-active-side-nav rounded-3xl shadow-xl overflow-hidden flex flex-col transition-all duration-500 ease-out animate-slideIn";
  return e ? `${n} chat-window--fullscreen fixed inset-0 z-[9999] w-screen h-screen rounded-none` : t ? `${n} chat-window--fixed-right fixed top-0 right-0 z-[9999] w-[35.5rem] max-w-[100vw] h-screen rounded-none` : `${n} chat-window--floating relative w-[35.5rem] max-w-[90vw] h-[85vh]`;
}, T6 = ({
  isMobile: e,
  isFullscreen: t,
  isFixedRight: n,
  onToggleFullscreen: r,
  onToggleFixedRight: a
}) => {
  const { t: i } = YI();
  return t || n || e ? null : /* @__PURE__ */ N.jsxs(N.Fragment, { children: [
    /* @__PURE__ */ N.jsxs(
      "button",
      {
        type: "button",
        onClick: r,
        className: "flex items-center gap-2.5 w-full py-2.5 px-2.5 text-sm text-white rounded-lg hover:bg-list-active-side-nav transition-all duration-200 ease-in-out cursor-pointer",
        children: [
          /* @__PURE__ */ N.jsx(
            Fs,
            {
              name: "expand-full",
              className: "w-4 h-4 shrink-0 expand-menu-icon",
              size: "sm",
              colorFill: "fill-none"
            }
          ),
          /* @__PURE__ */ N.jsx("span", { children: i("home.chatWindow.fullscreen") })
        ]
      }
    ),
    /* @__PURE__ */ N.jsxs(
      "button",
      {
        type: "button",
        onClick: a,
        className: "flex items-center gap-2.5 w-full py-2.5 px-2.5 text-sm text-white rounded-lg hover:bg-list-active-side-nav transition-all duration-200 ease-in-out cursor-pointer",
        children: [
          /* @__PURE__ */ N.jsx(
            Fs,
            {
              name: "layout-right",
              className: "w-4 h-4 shrink-0 expand-menu-icon",
              size: "sm",
              colorFill: "fill-none"
            }
          ),
          /* @__PURE__ */ N.jsx("span", { children: i("home.chatWindow.fixRight") })
        ]
      }
    )
  ] });
}, C6 = ({
  onClose: e,
  apiKey: t,
  authToken: n,
  hostname: r,
  userId: a,
  shadowContainer: i,
  assetBaseUrl: o,
  onFullscreenChange: s,
  onFixedRightChange: l,
  isMobile: c = !1,
  isVisible: u = !0,
  sharedQueryClient: f,
  sharedApolloClient: d
}) => {
  const [h, g] = y.useState(!1), [v, b] = y.useState(c), [p, m] = y.useState(!1), w = y.useRef(null), [x, S] = y.useState();
  y.useEffect(() => {
    c && !v && (b(!0), m(!1), s == null || s(!0));
  }, [c, v, s]);
  const { apolloClient: T, queryClient: E, router: O } = y.useMemo(() => {
    const R = d ? { apolloClient: d } : lD({
      uri: "https://api.hml.pas.app.br/",
      devtools: !1,
      hostname: r,
      apiKey: t,
      authToken: n,
      userId: a
    }), q = f || new kO(), z = LL(E6, {
      initialEntries: ["/"]
    });
    return {
      apolloClient: R.apolloClient,
      queryClient: q,
      router: z
    };
  }, [
    t,
    n,
    r,
    a,
    f,
    d
  ]);
  y.useEffect(() => {
    const R = () => {
      const q = w.current;
      if (!q) return;
      const z = q.getBoundingClientRect(), Q = v ? 64 : 24, k = Math.max(
        Math.min(
          z.width - 48,
          v || p ? z.width - 48 : 400
        ),
        240
      ), P = v ? {
        top: `${Math.max(z.top + Q, 24)}px`,
        right: "24px",
        left: "auto",
        transform: "none"
      } : {
        top: `${Math.max(z.top + Q, 24)}px`,
        left: `${z.left + z.width / 2}px`,
        transform: "translateX(-50%)"
      };
      S({
        position: "fixed",
        width: `${k}px`,
        maxWidth: `${k}px`,
        ...P
      });
    };
    return R(), window.addEventListener("resize", R), window.addEventListener("scroll", R, !0), () => {
      window.removeEventListener("resize", R), window.removeEventListener("scroll", R, !0);
    };
  }, [v, p]);
  const D = () => {
    const R = !v;
    b(R), g(!1), s == null || s(R);
  }, A = () => {
    const R = !p;
    m(R), g(!1), l == null || l(R);
  }, U = !u;
  return /* @__PURE__ */ N.jsx(Q4, { value: i ?? null, children: /* @__PURE__ */ N.jsx(q4, { value: w, children: /* @__PURE__ */ N.jsxs(
    "div",
    {
      ref: w,
      className: `${S6(v, p)} ${U ? "hidden" : ""}`,
      "aria-hidden": U,
      children: [
        /* @__PURE__ */ N.jsx(
          "header",
          {
            className: "bg-list-active-side-nav flex justify-end items-start gap-2.5 shrink-0 rounded-t-3xl pt-5 pr-5 pb-2.5 pl-5 overflow-x-hidden",
            style: { borderBottom: "1px solid var(--color-neutral-2)" },
            children: v || p ? /* @__PURE__ */ N.jsx(
              lc,
              {
                iconClassName: "rounded-md transition-all duration-300 ease-in-out text-white hover:bg-neutral-2 focus-visible:bg-neutral-2 focus-visible:ring-1 focus-visible:ring-neutral-2 focus-visible:border-neutral-2",
                size: "sm",
                name: "close",
                onClick: () => {
                  if (c) {
                    e();
                    return;
                  }
                  if (v) {
                    b(!1), s == null || s(!1);
                    return;
                  }
                  p && (m(!1), l == null || l(!1));
                }
              }
            ) : /* @__PURE__ */ N.jsxs(N.Fragment, { children: [
              !c && /* @__PURE__ */ N.jsx(
                S_,
                {
                  controlled: !0,
                  open: h,
                  type: yh.Content,
                  align: xb.End,
                  content: /* @__PURE__ */ N.jsx(
                    T6,
                    {
                      isMobile: c,
                      isFullscreen: v,
                      isFixedRight: p,
                      onToggleFullscreen: D,
                      onToggleFixedRight: A
                    }
                  ),
                  handleOpenChange: g,
                  side: Di.Bottom,
                  className: "bg-transparent",
                  contentClassName: "w-48 rounded-lg !bg-background-dialog drawer-shadow flex flex-col gap-1 p-2",
                  container: i,
                  children: /* @__PURE__ */ N.jsx(
                    lc,
                    {
                      iconClassName: "rounded-md transition-all duration-300 ease-in-out text-white hover:bg-neutral-2 focus-visible:bg-neutral-2 focus-visible:ring-1 focus-visible:ring-neutral-2 focus-visible:border-neutral-2",
                      size: "sm",
                      name: "expand"
                    }
                  )
                }
              ),
              /* @__PURE__ */ N.jsx(
                lc,
                {
                  iconClassName: "rounded-md transition-all duration-300 ease-in-out text-white hover:bg-neutral-2 focus-visible:bg-neutral-2 focus-visible:ring-1 focus-visible:ring-neutral-2 focus-visible:border-neutral-2",
                  size: "sm",
                  name: "close",
                  onClick: e
                }
              )
            ] })
          }
        ),
        /* @__PURE__ */ N.jsx("div", { className: "flex-1 relative bg-list-active-side-nav flex flex-col min-h-0", children: /* @__PURE__ */ N.jsx(KI, { i18n: vt, children: /* @__PURE__ */ N.jsx(kA, { client: T, children: /* @__PURE__ */ N.jsx(Ey, { client: E, children: /* @__PURE__ */ N.jsx(F4, { viewportStyle: x, children: /* @__PURE__ */ N.jsx(V4, { children: /* @__PURE__ */ N.jsx(
          y.Suspense,
          {
            fallback: /* @__PURE__ */ N.jsx("div", { className: "flex-1 flex items-center justify-center", children: /* @__PURE__ */ N.jsx(
              ab,
              {
                isLoading: !0,
                variant: Qt.Dots,
                size: tn.Medium
              }
            ) }),
            children: /* @__PURE__ */ N.jsx(jL, { router: O })
          }
        ) }) }) }) }) }) })
      ]
    }
  ) }) });
}, ZE = (e) => {
  let t;
  const n = /* @__PURE__ */ new Set(), r = (c, u) => {
    const f = typeof c == "function" ? c(t) : c;
    if (!Object.is(f, t)) {
      const d = t;
      t = u ?? (typeof f != "object" || f === null) ? f : Object.assign({}, t, f), n.forEach((h) => h(t, d));
    }
  }, a = () => t, s = { setState: r, getState: a, getInitialState: () => l, subscribe: (c) => (n.add(c), () => n.delete(c)) }, l = t = e(r, a, s);
  return s;
}, O6 = (e) => e ? ZE(e) : ZE, A6 = (e) => e;
function R6(e, t = A6) {
  const n = cn.useSyncExternalStore(
    e.subscribe,
    cn.useCallback(() => t(e.getState()), [e, t]),
    cn.useCallback(() => t(e.getInitialState()), [e, t])
  );
  return cn.useDebugValue(n), n;
}
const JE = (e) => {
  const t = O6(e), n = (r) => R6(t, r);
  return Object.assign(n, t), n;
}, cD = (e) => e ? JE(e) : JE;
var qc = /* @__PURE__ */ ((e) => (e.USER = "user", e.ASSISTANT = "assistant", e))(qc || {}), Rd = /* @__PURE__ */ ((e) => (e.IMAGE = "IMAGE", e.VIDEO = "VIDEO", e.TEXT = "TEXT", e))(Rd || {});
const _6 = (e) => {
  const t = [];
  return e.shortPresentation && t.push({
    id: crypto.randomUUID(),
    isInitial: !0,
    type: Rd.TEXT,
    text: {
      value: e.shortPresentation
    },
    createdAt: (/* @__PURE__ */ new Date()).toISOString(),
    role: qc.ASSISTANT
  }), e.videoPresentationUrl && t.push({
    id: crypto.randomUUID(),
    isInitial: !0,
    type: Rd.VIDEO,
    text: {
      value: e.videoPresentationUrl
    },
    createdAt: (/* @__PURE__ */ new Date()).toISOString(),
    role: qc.ASSISTANT
  }), t;
}, V8 = (e) => ({
  id: e.id || crypto.randomUUID(),
  type: Rd.TEXT,
  createdAt: "",
  text: {
    value: e.content
  },
  role: e.type === "human" || e.role === "human" ? qc.USER : qc.ASSISTANT
}), sl = cD((e, t) => ({
  selectedAssistantId: null,
  currentThreadId: null,
  isAwaitingResponse: !1,
  tempAvatarUri: null,
  newlyCreatedThreadId: null,
  messages: [],
  isTyping: !1,
  actions: {
    initialMessagesFn: (n) => _6(n),
    selectAssistant: (n) => {
      e({
        selectedAssistantId: n,
        currentThreadId: null,
        newlyCreatedThreadId: null,
        messages: []
      });
    },
    selectThread: (n) => {
      const r = t().currentThreadId, a = r == null ? void 0 : r.startsWith("optimistic-");
      r !== n && !a && e({ messages: [] }), t().newlyCreatedThreadId !== n ? e({ currentThreadId: n, newlyCreatedThreadId: null }) : e({ currentThreadId: n });
    },
    setNewlyCreatedThreadId: (n) => e({ newlyCreatedThreadId: n }),
    setIsAwaitingResponse: (n) => e({ isAwaitingResponse: n }),
    setTempAvatarUri: (n) => e({ tempAvatarUri: n }),
    setIsTyping: (n) => e({ isTyping: n }),
    addMessage: (n) => {
      e((r) => ({
        messages: [
          ...r.messages,
          {
            ...n,
            id: n.id ?? `temp-${Date.now()}`,
            dateTime: /* @__PURE__ */ new Date()
          }
        ]
      }));
    },
    updateLastMessage: (n) => {
      e((r) => {
        const a = [...r.messages], i = a[a.length - 1];
        if (!i || i.role !== "assistant") return r;
        const o = typeof n == "function" ? n(i.text.value) : i.text.value + n;
        return a[a.length - 1] = {
          ...i,
          text: { ...i.text, value: o }
        }, { messages: a };
      });
    },
    setMessages: (n) => e({ messages: n }),
    clearMessages: () => e({ messages: [] }),
    initializeAssistantId: (n, r) => {
      if (t().selectedAssistantId || !n || n.length === 0)
        return;
      const i = n.find((o) => o.id === r) || n[0];
      i && e({ selectedAssistantId: i.id });
    }
  }
})), D6 = () => sl((e) => e.selectedAssistantId), Q8 = () => sl((e) => e.currentThreadId), H8 = () => sl((e) => e.isAwaitingResponse), N6 = () => sl((e) => e.tempAvatarUri), $8 = () => sl((e) => e.newlyCreatedThreadId), G8 = () => sl((e) => e.actions), fv = "chat-window-fullscreen-change", k6 = (e) => ({
  isFullscreen: !!(e != null && e.isFullscreen),
  isMobile: !!(e != null && e.isMobile),
  isFixedRight: !!(e != null && e.isFixedRight)
}), M6 = (e) => {
  typeof window > "u" || window.dispatchEvent(
    new CustomEvent(fv, {
      detail: e
    })
  );
}, Y8 = (e) => {
  if (typeof window > "u")
    return () => {
    };
  const t = (n) => {
    e(k6(n.detail));
  };
  return window.addEventListener(fv, t), () => {
    window.removeEventListener(fv, t);
  };
}, L6 = () => {
  const [e, t] = y.useState(!1);
  return y.useEffect(() => {
    const n = () => {
      t(window.innerWidth < 768);
    };
    return n(), window.addEventListener("resize", n), () => window.removeEventListener("resize", n);
  }, []), e;
};
class fs extends Error {
  constructor(n, r) {
    const a = `${fs.extractMessage(n)}: ${JSON.stringify({
      response: n,
      request: r
    })}`;
    super(a);
    wt(this, "response");
    wt(this, "request");
    Object.setPrototypeOf(this, fs.prototype), this.response = n, this.request = r, typeof Error.captureStackTrace == "function" && Error.captureStackTrace(this, fs);
  }
  static extractMessage(n) {
    var r, a;
    return ((a = (r = n.errors) == null ? void 0 : r[0]) == null ? void 0 : a.message) ?? `GraphQL Error (Code: ${String(n.status)})`;
  }
}
const eS = (e) => e.toUpperCase(), Zp = (e) => typeof e == "function" ? e() : e, uD = (e, t) => e.map((n, r) => [n, t[r]]), So = (e) => {
  let t = {};
  return e instanceof Headers ? t = z6(e) : Array.isArray(e) ? e.forEach(([n, r]) => {
    n && r !== void 0 && (t[n] = r);
  }) : e && (t = e), t;
}, z6 = (e) => {
  const t = {};
  return e.forEach((n, r) => {
    t[r] = n;
  }), t;
}, j6 = (e) => {
  try {
    const t = e();
    return P6(t) ? t.catch((n) => tS(n)) : t;
  } catch (t) {
    return tS(t);
  }
}, tS = (e) => e instanceof Error ? e : new Error(String(e)), P6 = (e) => typeof e == "object" && e !== null && "then" in e && typeof e.then == "function" && "catch" in e && typeof e.catch == "function" && "finally" in e && typeof e.finally == "function", Ob = (e) => {
  throw new Error(`Unhandled case: ${String(e)}`);
}, Lf = (e) => typeof e == "object" && e !== null && !Array.isArray(e), I6 = (e, t) => e.documents ? e : {
  documents: e,
  requestHeaders: t,
  signal: void 0
}, F6 = (e, t, n) => e.query ? e : {
  query: e,
  variables: t,
  requestHeaders: n,
  signal: void 0
}, nS = "Accept", dv = "Content-Type", hv = "application/json", fD = "application/graphql-response+json", rS = (e) => e.replace(/([\s,]|#[^\n\r]+)+/g, " ").trim(), U6 = (e) => {
  const t = e.toLowerCase();
  return t.includes(fD) || t.includes(hv);
}, aS = (e) => {
  try {
    if (Array.isArray(e))
      return {
        _tag: "Batch",
        executionResults: e.map(iS)
      };
    if (Lf(e))
      return {
        _tag: "Single",
        executionResult: iS(e)
      };
    throw new Error(`Invalid execution result: result is not object or array. 
Got:
${String(e)}`);
  } catch (t) {
    return t;
  }
}, iS = (e) => {
  if (typeof e != "object" || e === null)
    throw new Error("Invalid execution result: result is not object");
  let t, n, r;
  if ("errors" in e) {
    if (!Lf(e.errors) && !Array.isArray(e.errors))
      throw new Error("Invalid execution result: errors is not plain object OR array");
    t = e.errors;
  }
  if ("data" in e) {
    if (!Lf(e.data) && e.data !== null)
      throw new Error("Invalid execution result: data is not plain object");
    n = e.data;
  }
  if ("extensions" in e) {
    if (!Lf(e.extensions))
      throw new Error("Invalid execution result: extensions is not plain object");
    r = e.extensions;
  }
  return {
    data: n,
    errors: t,
    extensions: r
  };
}, q6 = (e) => e._tag === "Batch" ? e.executionResults.some(oS) : oS(e.executionResult), oS = (e) => Array.isArray(e.errors) ? e.errors.length > 0 : !!e.errors, dD = (e) => typeof e == "object" && e !== null && "kind" in e && e.kind === X.OPERATION_DEFINITION, B6 = (e) => {
  var r;
  let t;
  const n = e.definitions.filter(dD);
  return n.length === 1 && (t = (r = n[0].name) == null ? void 0 : r.value), t;
}, V6 = (e) => {
  let t = !1;
  const n = e.definitions.filter(dD);
  return n.length === 1 && (t = n[0].operation === "mutation"), t;
}, Jp = (e, t) => {
  const n = typeof e == "string" || "kind" in e ? e : String(e), r = typeof n == "string" ? n : E1(n);
  let a = !1, i;
  if (t)
    return { expression: r, isMutation: a, operationName: i };
  const o = j6(() => typeof n == "string" ? Wz(n) : n);
  return o instanceof Error ? { expression: r, isMutation: a, operationName: i } : (i = B6(o), a = V6(o), { expression: r, operationName: i, isMutation: a });
}, Ab = JSON, em = async (e) => {
  const t = {
    ...e,
    method: e.request._tag === "Single" ? e.request.document.isMutation ? "POST" : eS(e.method ?? "post") : e.request.hasMutations ? "POST" : eS(e.method ?? "post"),
    fetchOptions: {
      ...e.fetchOptions,
      errorPolicy: e.fetchOptions.errorPolicy ?? "none"
    }
  }, r = await H6(t.method)(t), a = await Q6(r, e.fetchOptions.jsonSerializer ?? Ab);
  if (a instanceof Error)
    throw a;
  const i = {
    status: r.status,
    headers: r.headers
  };
  if (!r.ok) {
    const o = a._tag === "Batch" ? { ...a.executionResults, ...i } : {
      ...a.executionResult,
      ...i
    };
    return new fs(o, {
      query: e.request._tag === "Single" ? e.request.document.expression : e.request.query,
      variables: e.request.variables
    });
  }
  if (q6(a) && t.fetchOptions.errorPolicy === "none") {
    const o = a._tag === "Batch" ? { ...a.executionResults, ...i } : {
      ...a.executionResult,
      ...i
    };
    return new fs(o, {
      query: e.request._tag === "Single" ? e.request.document.expression : e.request.query,
      variables: e.request.variables
    });
  }
  switch (a._tag) {
    case "Single":
      return {
        ...i,
        ...sS(t)(a.executionResult)
      };
    case "Batch":
      return {
        ...i,
        data: a.executionResults.map(sS(t))
      };
    default:
      Ob(a);
  }
}, sS = (e) => (t) => ({
  extensions: t.extensions,
  data: t.data,
  errors: e.fetchOptions.errorPolicy === "all" ? t.errors : void 0
}), Q6 = async (e, t) => {
  const n = e.headers.get(dv), r = await e.text();
  if (n && U6(n))
    return aS(t.parse(r));
  try {
    const a = t.parse(r);
    return aS(a);
  } catch {
    const a = r.length > 500 ? `${r.slice(0, 500)}...` : r;
    return new Error(`Response has unsupported content-type: ${n || "none"}. Expected 'application/json' or 'application/graphql-response+json'. Response body preview: ${a}`);
  }
}, H6 = (e) => async (t) => {
  const n = new Headers(t.headers);
  let r = null, a;
  n.has(nS) || n.set(nS, [fD, hv].join(", ")), e === "POST" ? (a = (t.fetchOptions.jsonSerializer ?? Ab).stringify($6(t)), typeof a == "string" && !n.has(dv) && n.set(dv, hv)) : r = G6(t);
  const i = { method: e, headers: n, body: a, ...t.fetchOptions };
  let o = new URL(t.url), s = i;
  if (t.middleware) {
    const c = await Promise.resolve(t.middleware({
      ...i,
      url: t.url,
      operationName: t.request._tag === "Single" ? t.request.document.operationName : void 0,
      variables: t.request.variables
    })), { url: u, ...f } = c;
    o = new URL(u), s = f;
  }
  return r && r.forEach((c, u) => {
    o.searchParams.append(u, c);
  }), await (t.fetch ?? fetch)(o, s);
}, $6 = (e) => {
  switch (e.request._tag) {
    case "Single":
      return {
        query: e.request.document.expression,
        variables: e.request.variables,
        operationName: e.request.document.operationName
      };
    case "Batch":
      return uD(e.request.query, e.request.variables ?? []).map(([t, n]) => ({
        query: t,
        variables: n
      }));
    default:
      throw Ob(e.request);
  }
}, G6 = (e) => {
  var r;
  const t = e.fetchOptions.jsonSerializer ?? Ab, n = new URLSearchParams();
  switch (e.request._tag) {
    case "Single":
      return n.append("query", rS(e.request.document.expression)), e.request.variables && n.append("variables", t.stringify(e.request.variables)), e.request.document.operationName && n.append("operationName", e.request.document.operationName), n;
    case "Batch": {
      const a = ((r = e.request.variables) == null ? void 0 : r.map((s) => t.stringify(s))) ?? [], i = e.request.query.map(rS), o = uD(i, a).map(([s, l]) => ({
        query: s,
        variables: l
      }));
      return n.append("query", t.stringify(o)), n;
    }
    default:
      throw Ob(e.request);
  }
};
class Y6 {
  constructor(t, n = {}) {
    wt(this, "url");
    wt(this, "requestConfig");
    /**
     * Send a GraphQL query to the server.
     */
    wt(this, "rawRequest", async (...t) => {
      const [n, r, a] = t, i = F6(n, r, a), { headers: o, fetch: s = globalThis.fetch, method: l = "POST", requestMiddleware: c, responseMiddleware: u, excludeOperationName: f, ...d } = this.requestConfig, { url: h } = this;
      i.signal !== void 0 && (d.signal = i.signal);
      const g = Jp(i.query, f), v = await em({
        url: h,
        request: {
          _tag: "Single",
          document: g,
          variables: i.variables
        },
        headers: {
          ...So(Zp(o)),
          ...So(i.requestHeaders)
        },
        fetch: s,
        method: l,
        fetchOptions: d,
        middleware: c
      });
      if (u && await u(v, {
        operationName: g.operationName,
        variables: r,
        url: this.url
      }), v instanceof Error)
        throw v;
      return v;
    });
    this.url = t, this.requestConfig = n;
  }
  async request(t, ...n) {
    const [r, a] = n, i = K6(t, r, a), { headers: o, fetch: s = globalThis.fetch, method: l = "POST", requestMiddleware: c, responseMiddleware: u, excludeOperationName: f, ...d } = this.requestConfig, { url: h } = this;
    i.signal !== void 0 && (d.signal = i.signal);
    const g = Jp(i.document, f), v = await em({
      url: h,
      request: {
        _tag: "Single",
        document: g,
        variables: i.variables
      },
      headers: {
        ...So(Zp(o)),
        ...So(i.requestHeaders)
      },
      fetch: s,
      method: l,
      fetchOptions: d,
      middleware: c
    });
    if (u && await u(v, {
      operationName: g.operationName,
      variables: i.variables,
      url: this.url
    }), v instanceof Error)
      throw v;
    return v.data;
  }
  async batchRequests(t, n) {
    const r = I6(t, n), { headers: a, excludeOperationName: i, ...o } = this.requestConfig;
    r.signal !== void 0 && (o.signal = r.signal);
    const s = r.documents.map(({ document: d }) => Jp(d, i)), l = s.map(({ expression: d }) => d), c = s.some(({ isMutation: d }) => d), u = r.documents.map(({ variables: d }) => d), f = await em({
      url: this.url,
      request: {
        _tag: "Batch",
        operationName: void 0,
        query: l,
        hasMutations: c,
        variables: u
      },
      headers: {
        ...So(Zp(a)),
        ...So(r.requestHeaders)
      },
      fetch: this.requestConfig.fetch ?? globalThis.fetch,
      method: this.requestConfig.method || "POST",
      fetchOptions: o,
      middleware: this.requestConfig.requestMiddleware
    });
    if (this.requestConfig.responseMiddleware && await this.requestConfig.responseMiddleware(f, {
      operationName: void 0,
      variables: u,
      url: this.url
    }), f instanceof Error)
      throw f;
    return f.data;
  }
  setHeaders(t) {
    return this.requestConfig.headers = t, this;
  }
  /**
   * Attach a header to the client. All subsequent requests will have this header.
   */
  setHeader(t, n) {
    const { headers: r } = this.requestConfig;
    return r ? r[t] = n : this.requestConfig.headers = { [t]: n }, this;
  }
  /**
   * Change the client endpoint. All subsequent requests will send to this endpoint.
   */
  setEndpoint(t) {
    return this.url = t, this;
  }
}
const K6 = (e, t, n) => e.document ? e : {
  document: e,
  variables: t,
  requestHeaders: n,
  signal: void 0
}, Rb = (e, ...t) => e.reduce((n, r, a) => `${n}${r}${a in t ? String(t[a]) : ""}`, ""), X6 = { VITE_API_BFF_URL: "https://api.hml.pas.app.br/" }, W6 = X6, Z6 = () => {
  const { hostname: e, apiKey: t, userId: n } = ol();
  return {
    "x-hostname": e ?? "embed-host",
    ...t ? { "x-api-key": t } : {},
    ...n ? { "x-user-id": n } : {},
    "accept-language": vt.language
  };
}, J6 = (e) => new Y6(W6.VITE_API_BFF_URL, {
  headers: {
    ...Z6(),
    ...e || {}
  }
}), _b = {
  request: (e, t, n) => J6(n).request(e, t)
}, e8 = Rb`
query GetPersona($token: String!, $assistantId: ID!, $personaId: ID!) {
  getPersona(token: $token, assistantId: $assistantId, personaId: $personaId) {
    id
    name
    description
    shortPresentation
    avatar {
      id
      uri
    }
    videoPresentationUrl
    hallucinationLevel
  }
}
`, t8 = async (e, t, n, r = {}) => {
  const { apiKey: a, hostname: i } = ol(), o = r.apiKey ?? a, l = {
    "x-hostname": r.hostname ?? i ?? "embed-host"
  };
  return o && (l["x-api-key"] = o), (await _b.request(
    e8,
    {
      token: e,
      assistantId: t,
      personaId: n
    },
    l
  )).getPersona;
}, lS = {
  page: 1,
  perPage: 10
}, n8 = Rb`
  query AssistantByTenant($token: String!, $pagination: PaginationInput) {
    assistantByTenant(token: $token, pagination: $pagination) {
      currentPage
      totalPages
      totalRows
      perPage
      page {
        id
        persona {
          id
          name
          description
          shortPresentation
          avatar {
            uri
          }
        }
        createdAt
      }
    }
}
`, r8 = async (e, {
  page: t = lS.page,
  perPage: n = lS.perPage,
  apiKey: r,
  hostname: a
} = {}) => {
  const { apiKey: i, hostname: o } = ol(), s = r ?? i, l = a ?? o ?? "embed-host", c = {
    token: e,
    pagination: {
      page: t,
      perPage: n
    }
  }, u = {
    "x-hostname": l
  };
  return s && (u["x-api-key"] = s), (await _b.request(n8, c, u)).assistantByTenant;
}, cS = {
  user: void 0,
  token: void 0,
  refreshToken: void 0,
  expiresIn: void 0,
  lastLogin: void 0,
  isAuthenticated: !1
}, hD = cD()(
  (e) => ({
    ...cS,
    actions: {
      setInitialAuth: (t) => e({
        ...t,
        isAuthenticated: !!t.user && !!t.token
      }),
      setRefreshedToken: (t) => e({
        token: t.token,
        refreshToken: t.refreshToken,
        expiresIn: t.expiresIn,
        lastLogin: (/* @__PURE__ */ new Date()).toISOString(),
        isAuthenticated: !0
      }),
      clearAuth: () => e(cS)
    }
  })
), a8 = () => hD((e) => e.token), i8 = (e, t, n = 2) => {
  var i;
  if (e >= n) return !1;
  const r = t, a = ((i = r == null ? void 0 : r.response) == null ? void 0 : i.status) ?? (r == null ? void 0 : r.status);
  return typeof a == "number" && a >= 500;
}, o8 = (e) => Math.min(1e3 * 2 ** e, 5e3), s8 = () => {
  const e = a8();
  return Sy({
    queryKey: ["assistants"],
    queryFn: () => {
      if (!e)
        throw new Error(yB("common.validation.missingParameters"));
      return r8(e);
    },
    enabled: !!e,
    staleTime: Number.POSITIVE_INFINITY,
    retry: (t, n) => i8(t, n, 2),
    retryDelay: o8,
    refetchOnMount: !1,
    refetchOnWindowFocus: !1,
    refetchOnReconnect: !1
  });
}, l8 = Rb`
  query Organization {
    organizationByIdIdentity {
      logoUri
      name
      solution {
        name
        description
        logoUri
        bannerUri
        faviconUri
      }
    }
  }
`, c8 = async () => (await _b.request(l8)).organizationByIdIdentity, u8 = 1e3 * 60 * 10, f8 = () => Sy({
  queryKey: ["organization"],
  queryFn: c8,
  staleTime: u8,
  refetchOnWindowFocus: !1
}), d8 = ({
  onClientsReady: e,
  apolloClient: t,
  authToken: n,
  apiKey: r,
  hostname: a,
  userId: i
}) => {
  var c, u, f, d, h;
  const o = xy(), s = y.useRef(!1), { data: l } = s8();
  return f8(), Sy({
    queryKey: ["persona", (u = (c = l == null ? void 0 : l.page) == null ? void 0 : c[0]) == null ? void 0 : u.id],
    queryFn: async () => {
      var b, p;
      if (!n || !((b = l == null ? void 0 : l.page) != null && b[0]))
        return null;
      const g = l.page[0], v = (p = g.persona) == null ? void 0 : p.id;
      if (!v || !g.id)
        return null;
      try {
        const { apiKey: m, hostname: w } = ol(), x = r ?? m, S = a ?? w;
        return S ? await t8(n, g.id, v, {
          apiKey: x,
          hostname: S
        }) : (console.warn("[PreloadQueries] No hostname available for getPersona"), null);
      } catch (m) {
        return console.error("[PreloadQueries] Failed to load persona", m), null;
      }
    },
    enabled: !!n && !!((h = (d = (f = l == null ? void 0 : l.page) == null ? void 0 : f[0]) == null ? void 0 : d.persona) != null && h.id),
    staleTime: Number.POSITIVE_INFINITY,
    refetchOnMount: !1,
    refetchOnWindowFocus: !1,
    refetchOnReconnect: !1
  }), y.useEffect(() => {
    !s.current && o && t && (s.current = !0, e(o, t));
  }, [o, t, e]), null;
}, h8 = ({
  apiKey: e,
  authToken: t,
  hostname: n,
  onClientsReady: r,
  userId: a
}) => {
  const { apolloClient: i, queryClient: o } = y.useMemo(() => {
    const l = lD({
      uri: "https://api.hml.pas.app.br/",
      devtools: !1,
      hostname: n,
      apiKey: e,
      authToken: t,
      userId: a
    }), c = new kO();
    return {
      apolloClient: l.apolloClient,
      queryClient: c
    };
  }, [e, t, n, a]), s = hD((l) => l.actions.setInitialAuth);
  return y.useEffect(() => {
    if (K_({
      apiKey: e,
      token: t,
      hostname: n,
      userId: a
    }), t) {
      const { token: l } = ol();
      (!l || l === t) && s({
        token: t,
        user: void 0,
        refreshToken: void 0,
        expiresIn: void 0,
        lastLogin: void 0
      });
    }
  }, [e, t, n, a, s]), /* @__PURE__ */ N.jsx(kA, { client: i, children: /* @__PURE__ */ N.jsx(Ey, { client: o, children: /* @__PURE__ */ N.jsx(
    d8,
    {
      onClientsReady: r,
      apolloClient: i,
      authToken: t,
      apiKey: e,
      hostname: n,
      userId: a
    }
  ) }) });
}, p8 = ({
  onClick: e,
  assetBaseUrl: t
}) => {
  const n = xy(), r = D6(), a = N6(), o = `${t.endsWith("/") ? t : `${t}/`}images/assistant.png`, s = y.useSyncExternalStore(
    (d) => n.getQueryCache().subscribe(d),
    () => n.getQueryData([
      "assistants"
    ])
  ), l = y.useSyncExternalStore(
    (d) => n.getQueryCache().subscribe(d),
    () => n.getQueryState(["assistants"])
  ), c = (l == null ? void 0 : l.status) === "pending" || (l == null ? void 0 : l.fetchStatus) === "fetching", u = y.useMemo(() => {
    var d, h, g, v;
    if (s != null && s.page && s.page.length > 0) {
      const b = s.page.find(
        (m) => m.id === r
      );
      return b ? a || ((h = (d = b.persona) == null ? void 0 : d.avatar) == null ? void 0 : h.uri) : (v = (g = s.page[0].persona) == null ? void 0 : g.avatar) == null ? void 0 : v.uri;
    }
  }, [s, r, a]);
  if (c || !s)
    return null;
  const f = u || o;
  return /* @__PURE__ */ N.jsx(
    "button",
    {
      type: "button",
      onClick: e,
      className: "cursor-pointer w-9 h-9 rounded-full bg-blue-600 text-white flex items-center justify-center shadow-lg transition-transform duration-200 ease-out hover:scale-105 focus:outline-none focus:ring-opacity-50 overflow-hidden",
      "aria-label": "Abrir/Fechar chat",
      children: /* @__PURE__ */ N.jsx(
        "img",
        {
          src: f,
          alt: "Assistente",
          className: "w-full h-full object-cover rounded-full pointer-events-none",
          onError: (d) => {
            d.currentTarget.src !== o && (d.currentTarget.src = o);
          }
        }
      )
    }
  );
}, m8 = ({
  onClick: e,
  assetBaseUrl: t,
  queryClient: n
}) => n ? /* @__PURE__ */ N.jsx(Ey, { client: n, children: /* @__PURE__ */ N.jsx(p8, { onClick: e, assetBaseUrl: t }) }) : null, g8 = (e) => {
  if (e)
    return e;
  if (typeof window < "u")
    return window.location.hostname;
};
function v8({
  apiKey: e,
  auth: t,
  hostname: n,
  userId: r,
  position: a = "bottom-right",
  hasCustomCoordinates: i = !1,
  shadowContainer: o,
  assetBaseUrl: s,
  language: l
}) {
  const [c, u] = y.useState(!1), [f, d] = y.useState(!1), [h, g] = y.useState(!1), [v, b] = y.useState(!1), [p, m] = y.useState(void 0), [w, x] = y.useState(void 0), S = L6(), T = y.useRef({
    apiKey: void 0,
    auth: void 0,
    hostname: void 0,
    userId: void 0
  }), E = y.useMemo(() => {
    const U = g8(n), R = {
      apiKey: e,
      auth: t,
      hostname: U,
      userId: r
    }, q = T.current;
    return (q.apiKey !== R.apiKey || q.auth !== R.auth || q.hostname !== R.hostname || q.userId !== R.userId) && (K_({
      apiKey: R.apiKey,
      token: R.auth,
      hostname: R.hostname,
      userId: R.userId
    }), T.current = R), R;
  }, [e, t, n, r]), O = y.useCallback(() => {
    const U = !c;
    u(U), U && b(!0), U && S ? g(!1) : U || (d(!1), g(!1));
  }, [c, S]), D = () => {
    var Q;
    const U = ((Q = a == null ? void 0 : a.split("|")[0]) == null ? void 0 : Q.trim()) || "bottom-right";
    if (i) {
      const k = "fixed z-[2147483646]";
      switch (U.toLowerCase()) {
        case "top-left":
          return `${k} top-4 left-4`;
        case "top-right":
          return `${k} top-4 right-4`;
        case "bottom-left":
          return `${k} bottom-4 left-4`;
        case "bottom-right":
          return `${k} bottom-4 right-4`;
        default:
          return `${k} bottom-4 right-4`;
      }
    }
    const R = "absolute z-[-1]", q = "mb-2", z = "mt-2";
    switch (U.toLowerCase()) {
      case "top-left":
        return `${R} top-full left-0 ${z}`;
      case "top-right":
        return `${R} top-full right-0 ${z}`;
      case "bottom-left":
        return `${R} bottom-full left-0 ${q}`;
      case "bottom-right":
        return `${R} bottom-full right-0 ${q}`;
      default:
        return `${R} bottom-full right-0 ${q}`;
    }
  }, A = y.useCallback(() => {
    O();
  }, [O]);
  return y.useEffect(() => {
    M6({ isFullscreen: f, isMobile: S, isFixedRight: h });
  }, [f, S, h]), y.useEffect(() => {
    l && ["pt-BR", "en-US", "es-ES"].includes(l) && vt.language !== l && vt.changeLanguage(l).catch((R) => {
      console.error(
        "[pas-assistant-embedded] Erro ao mudar idioma:",
        R
      );
    });
  }, [l]), /* @__PURE__ */ N.jsxs("div", { className: "relative", children: [
    (c || v) && /* @__PURE__ */ N.jsx(
      "div",
      {
        className: `${D()} ${c || f || h ? "" : "hidden"}`,
        children: /* @__PURE__ */ N.jsx(
          C6,
          {
            onClose: O,
            apiKey: e,
            authToken: t,
            hostname: E.hostname,
            userId: E.userId,
            shadowContainer: o,
            assetBaseUrl: s,
            onFullscreenChange: d,
            onFixedRightChange: g,
            isMobile: S,
            isVisible: c || f || h,
            sharedQueryClient: p,
            sharedApolloClient: w
          }
        )
      }
    ),
    /* @__PURE__ */ N.jsx(
      h8,
      {
        apiKey: e,
        authToken: t,
        hostname: E.hostname,
        onClientsReady: (U, R) => {
          m(U), x(R);
        }
      }
    ),
    !c && !f && !h && /* @__PURE__ */ N.jsx(
      m8,
      {
        onClick: A,
        assetBaseUrl: s,
        queryClient: p
      }
    )
  ] });
}
const y8 = '/*! tailwindcss v4.1.17 | MIT License | https://tailwindcss.com */@layer properties{@supports (((-webkit-hyphens:none)) and (not (margin-trim:inline))) or ((-moz-orient:inline) and (not (color:rgb(from red r g b)))){*,:before,:after,::backdrop{--tw-translate-x:0;--tw-translate-y:0;--tw-translate-z:0;--tw-rotate-x:initial;--tw-rotate-y:initial;--tw-rotate-z:initial;--tw-skew-x:initial;--tw-skew-y:initial;--tw-border-style:solid;--tw-leading:initial;--tw-font-weight:initial;--tw-tracking:initial;--tw-shadow:0 0 #0000;--tw-shadow-color:initial;--tw-shadow-alpha:100%;--tw-inset-shadow:0 0 #0000;--tw-inset-shadow-color:initial;--tw-inset-shadow-alpha:100%;--tw-ring-color:initial;--tw-ring-shadow:0 0 #0000;--tw-inset-ring-color:initial;--tw-inset-ring-shadow:0 0 #0000;--tw-ring-inset:initial;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-offset-shadow:0 0 #0000;--tw-outline-style:solid;--tw-backdrop-blur:initial;--tw-backdrop-brightness:initial;--tw-backdrop-contrast:initial;--tw-backdrop-grayscale:initial;--tw-backdrop-hue-rotate:initial;--tw-backdrop-invert:initial;--tw-backdrop-opacity:initial;--tw-backdrop-saturate:initial;--tw-backdrop-sepia:initial;--tw-duration:initial;--tw-ease:initial;--tw-scale-x:1;--tw-scale-y:1;--tw-scale-z:1}}}@layer theme{:root,:host{--font-sans:"Inter","ui-sans-serif","system-ui","sans-serif";--font-mono:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;--color-red-500:oklch(63.7% .237 25.331);--color-red-600:oklch(57.7% .245 27.325);--color-red-900:oklch(39.6% .141 25.723);--color-amber-500:oklch(76.9% .188 70.08);--color-yellow-300:oklch(90.5% .182 98.111);--color-yellow-400:oklch(85.2% .199 91.936);--color-yellow-500:oklch(79.5% .184 86.047);--color-yellow-600:oklch(68.1% .162 75.834);--color-green-600:oklch(62.7% .194 149.214);--color-blue-100:oklch(93.2% .032 255.585);--color-blue-200:oklch(88.2% .059 254.128);--color-blue-300:oklch(80.9% .105 251.813);--color-blue-500:oklch(62.3% .214 259.815);--color-blue-600:oklch(54.6% .245 262.881);--color-slate-200:oklch(92.9% .013 255.508);--color-gray-200:oklch(92.8% .006 264.531);--color-gray-500:oklch(55.1% .027 264.364);--color-gray-600:oklch(44.6% .03 256.802);--color-gray-700:oklch(37.3% .034 259.733);--color-gray-900:oklch(21% .034 264.665);--color-neutral-500:oklch(55.6% 0 0);--color-neutral-700:oklch(37.1% 0 0);--color-neutral-800:oklch(26.9% 0 0);--color-neutral-900:oklch(20.5% 0 0);--color-black:#000;--color-white:#fff;--spacing:.25rem;--text-xs:.75rem;--text-xs--line-height:calc(1/.75);--text-sm:.875rem;--text-sm--line-height:calc(1.25/.875);--text-base:1rem;--text-base--line-height: 1.5 ;--text-lg:1.125rem;--text-lg--line-height:calc(1.75/1.125);--text-xl:1.25rem;--text-xl--line-height:calc(1.75/1.25);--font-weight-normal:400;--font-weight-medium:500;--font-weight-semibold:600;--font-weight-bold:700;--tracking-tighter:-.05em;--radius-md:.375rem;--radius-lg:.5rem;--radius-xl:.75rem;--radius-2xl:1rem;--radius-3xl:1.5rem;--ease-out:cubic-bezier(0,0,.2,1);--ease-in-out:cubic-bezier(.4,0,.2,1);--animate-pulse:pulse 2s cubic-bezier(.4,0,.6,1)infinite;--blur-sm:8px;--default-transition-duration:.15s;--default-transition-timing-function:cubic-bezier(.4,0,.2,1);--default-font-family:var(--font-sans);--default-mono-font-family:var(--font-mono);--color-primary:#266efd;--color-gray-5:#ffffff80;--color-gray-20:#131720;--color-gray-30:#191e29;--color-gray-40:#0c0e12;--color-background-dialog:#2d2d34;--color-red-9:#e5484d;--color-red-10:#ffd8d9;--color-green-4:#3b7d5e;--color-green-5:#46a758;--color-green-6:#30a46c;--color-blue-primary:#246bfd;--color-neutral-1:#888891;--color-neutral-2:#595969;--color-neutral-3:#1c2024;--color-semantic-default:#2e3542;--color-drawer:#26262c;--color-border-drawer:#42424d;--color-list-active-side-nav:#1c1c21;--color-list-active:#383842;--color-list-normal-side-nav:#131316;--color-copy-button-hover:#0b0b0d;--icon-size-custom:1.125rem;--bg-body:var(--color-gray-40);--text-primary:#fff;--text-secondary:var(--color-neutral-1);--text-muted:var(--color-gray-5)}}@layer base{*,:after,:before,::backdrop{box-sizing:border-box;border:0 solid;margin:0;padding:0}::file-selector-button{box-sizing:border-box;border:0 solid;margin:0;padding:0}html,:host{-webkit-text-size-adjust:100%;-moz-tab-size:4;tab-size:4;line-height:1.5;font-family:var(--default-font-family,ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji");font-feature-settings:var(--default-font-feature-settings,normal);font-variation-settings:var(--default-font-variation-settings,normal);-webkit-tap-highlight-color:transparent}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;-webkit-text-decoration:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:var(--default-mono-font-family,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace);font-feature-settings:var(--default-mono-font-feature-settings,normal);font-variation-settings:var(--default-mono-font-variation-settings,normal);font-size:1em}small{font-size:80%}sub,sup{vertical-align:baseline;font-size:75%;line-height:0;position:relative}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}:-moz-focusring{outline:auto}progress{vertical-align:baseline}summary{display:list-item}ol,ul,menu{list-style:none}img,svg,video,canvas,audio,iframe,embed,object{vertical-align:middle;display:block}img,video{max-width:100%;height:auto}button,input,select,optgroup,textarea{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}::file-selector-button{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}:where(select:is([multiple],[size])) optgroup{font-weight:bolder}:where(select:is([multiple],[size])) optgroup option{padding-inline-start:20px}::file-selector-button{margin-inline-end:4px}::placeholder{opacity:1}@supports (not ((-webkit-appearance:-apple-pay-button))) or (contain-intrinsic-size:1px){::placeholder{color:currentColor}@supports (color:color-mix(in lab,red,red)){::placeholder{color:color-mix(in oklab,currentcolor 50%,transparent)}}}textarea{resize:vertical}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-date-and-time-value{min-height:1lh;text-align:inherit}::-webkit-datetime-edit{display:inline-flex}::-webkit-datetime-edit-fields-wrapper{padding:0}::-webkit-datetime-edit{padding-block:0}::-webkit-datetime-edit-year-field{padding-block:0}::-webkit-datetime-edit-month-field{padding-block:0}::-webkit-datetime-edit-day-field{padding-block:0}::-webkit-datetime-edit-hour-field{padding-block:0}::-webkit-datetime-edit-minute-field{padding-block:0}::-webkit-datetime-edit-second-field{padding-block:0}::-webkit-datetime-edit-millisecond-field{padding-block:0}::-webkit-datetime-edit-meridiem-field{padding-block:0}::-webkit-calendar-picker-indicator{line-height:1}:-moz-ui-invalid{box-shadow:none}button,input:where([type=button],[type=reset],[type=submit]){-webkit-appearance:button;-moz-appearance:button;appearance:button}::file-selector-button{-webkit-appearance:button;-moz-appearance:button;appearance:button}::-webkit-inner-spin-button{height:auto}::-webkit-outer-spin-button{height:auto}[hidden]:where(:not([hidden=until-found])){display:none!important}}@layer components;@layer utilities{.pointer-events-auto{pointer-events:auto}.pointer-events-none{pointer-events:none}.visible{visibility:visible}.absolute{position:absolute}.fixed{position:fixed}.relative{position:relative}.static{position:static}.inset-0{inset:calc(var(--spacing)*0)}.-top-10{top:calc(var(--spacing)*-10)}.top-0{top:calc(var(--spacing)*0)}.top-1\\/2{top:50%}.top-2{top:calc(var(--spacing)*2)}.top-4{top:calc(var(--spacing)*4)}.top-full{top:100%}.right-0{right:calc(var(--spacing)*0)}.right-2{right:calc(var(--spacing)*2)}.right-3{right:calc(var(--spacing)*3)}.right-4{right:calc(var(--spacing)*4)}.bottom-4{bottom:calc(var(--spacing)*4)}.bottom-full{bottom:100%}.left-0{left:calc(var(--spacing)*0)}.left-1\\/2{left:50%}.left-2{left:calc(var(--spacing)*2)}.left-3{left:calc(var(--spacing)*3)}.left-4{left:calc(var(--spacing)*4)}.\\!z-\\[800\\]{z-index:800!important}.\\!z-\\[1000\\]{z-index:1000!important}.\\!z-\\[1100\\]{z-index:1100!important}.z-10{z-index:10}.z-40{z-index:40}.z-50{z-index:50}.z-\\[-1\\]{z-index:-1}.z-\\[400\\]{z-index:400}.z-\\[800\\]{z-index:800}.z-\\[1000\\]{z-index:1000}.z-\\[1100\\]{z-index:1100}.z-\\[9999\\]{z-index:9999}.z-\\[2147483646\\]{z-index:2147483646}.z-\\[2147483647\\]{z-index:2147483647}.container{width:100%}@media (min-width:40rem){.container{max-width:40rem}}@media (min-width:48rem){.container{max-width:48rem}}@media (min-width:64rem){.container{max-width:64rem}}@media (min-width:80rem){.container{max-width:80rem}}@media (min-width:96rem){.container{max-width:96rem}}.m-0{margin:calc(var(--spacing)*0)}.mx-auto{margin-inline:auto}.my-0{margin-block:calc(var(--spacing)*0)}.my-4{margin-block:calc(var(--spacing)*4)}.mt-2{margin-top:calc(var(--spacing)*2)}.mt-3{margin-top:calc(var(--spacing)*3)}.mt-6{margin-top:calc(var(--spacing)*6)}.mt-8{margin-top:calc(var(--spacing)*8)}.mt-\\[30px\\]{margin-top:30px}.mt-auto{margin-top:auto}.mr-2{margin-right:calc(var(--spacing)*2)}.mb-2{margin-bottom:calc(var(--spacing)*2)}.mb-2\\.5{margin-bottom:calc(var(--spacing)*2.5)}.ml-auto{margin-left:auto}.box-border{box-sizing:border-box}.block{display:block}.flex{display:flex}.grid{display:grid}.hidden{display:none}.inline{display:inline}.inline-block{display:inline-block}.inline-flex{display:inline-flex}.table{display:table}.aspect-square{aspect-ratio:1}.size-10{width:calc(var(--spacing)*10);height:calc(var(--spacing)*10)}.\\!h-6{height:calc(var(--spacing)*6)!important}.\\!h-auto{height:auto!important}.h-1{height:calc(var(--spacing)*1)}.h-1\\.5{height:calc(var(--spacing)*1.5)}.h-2\\.5{height:calc(var(--spacing)*2.5)}.h-4{height:calc(var(--spacing)*4)}.h-5{height:calc(var(--spacing)*5)}.h-6{height:calc(var(--spacing)*6)}.h-7{height:calc(var(--spacing)*7)}.h-7\\.5{height:calc(var(--spacing)*7.5)}.h-8{height:calc(var(--spacing)*8)}.h-9{height:calc(var(--spacing)*9)}.h-10{height:calc(var(--spacing)*10)}.h-11{height:calc(var(--spacing)*11)}.h-12{height:calc(var(--spacing)*12)}.h-15{height:calc(var(--spacing)*15)}.h-25{height:calc(var(--spacing)*25)}.h-32{height:calc(var(--spacing)*32)}.h-\\[1\\.25rem\\]{height:1.25rem}.h-\\[3\\.5rem\\]{height:3.5rem}.h-\\[3\\.75rem\\]{height:3.75rem}.h-\\[85vh\\]{height:85vh}.h-\\[calc\\(100\\%-100px\\)\\]{height:calc(100% - 100px)}.h-auto{height:auto}.h-fit{height:fit-content}.h-full{height:100%}.h-px{height:1px}.h-screen{height:100vh}.max-h-\\[3\\.75rem\\]{max-height:3.75rem}.max-h-\\[9\\.375rem\\]{max-height:9.375rem}.max-h-\\[10rem\\]{max-height:10rem}.max-h-\\[12\\.5rem\\]{max-height:12.5rem}.max-h-\\[24rem\\]{max-height:24rem}.min-h-0{min-height:calc(var(--spacing)*0)}.min-h-5{min-height:calc(var(--spacing)*5)}.min-h-6{min-height:calc(var(--spacing)*6)}.min-h-\\[3\\.5rem\\]{min-height:3.5rem}.min-h-fit{min-height:fit-content}.\\!w-6{width:calc(var(--spacing)*6)!important}.w-0{width:calc(var(--spacing)*0)}.w-1{width:calc(var(--spacing)*1)}.w-1\\.5{width:calc(var(--spacing)*1.5)}.w-1\\/2{width:50%}.w-2\\.5{width:calc(var(--spacing)*2.5)}.w-4{width:calc(var(--spacing)*4)}.w-5{width:calc(var(--spacing)*5)}.w-6{width:calc(var(--spacing)*6)}.w-7{width:calc(var(--spacing)*7)}.w-7\\.5{width:calc(var(--spacing)*7.5)}.w-8{width:calc(var(--spacing)*8)}.w-9{width:calc(var(--spacing)*9)}.w-10{width:calc(var(--spacing)*10)}.w-12{width:calc(var(--spacing)*12)}.w-15{width:calc(var(--spacing)*15)}.w-25{width:calc(var(--spacing)*25)}.w-48{width:calc(var(--spacing)*48)}.w-\\[8\\.125rem\\]{width:8.125rem}.w-\\[35\\.5rem\\]{width:35.5rem}.w-\\[250px\\]{width:250px}.w-auto{width:auto}.w-fit{width:fit-content}.w-full{width:100%}.w-max{width:max-content}.w-screen{width:100vw}.max-w-40{max-width:calc(var(--spacing)*40)}.max-w-\\[8\\.125rem\\]{max-width:8.125rem}.max-w-\\[23\\.75rem\\]{max-width:23.75rem}.max-w-\\[30rem\\]{max-width:30rem}.max-w-\\[36rem\\]{max-width:36rem}.max-w-\\[37\\.5rem\\]{max-width:37.5rem}.max-w-\\[40rem\\]{max-width:40rem}.max-w-\\[47\\.25rem\\]{max-width:47.25rem}.max-w-\\[48rem\\]{max-width:48rem}.max-w-\\[70\\%\\]{max-width:70%}.max-w-\\[90vw\\]{max-width:90vw}.max-w-\\[95\\%\\]{max-width:95%}.max-w-\\[100vw\\]{max-width:100vw}.max-w-\\[calc\\(100\\%-2rem\\)\\]{max-width:calc(100% - 2rem)}.max-w-full{max-width:100%}.min-w-0{min-width:calc(var(--spacing)*0)}.min-w-\\[11\\.25rem\\]{min-width:11.25rem}.min-w-\\[18\\.75rem\\]{min-width:18.75rem}.min-w-\\[40px\\]{min-width:40px}.min-w-full{min-width:100%}.flex-1{flex:1}.shrink-0{flex-shrink:0}.border-collapse{border-collapse:collapse}.-translate-x-1\\/2{--tw-translate-x: -50% ;translate:var(--tw-translate-x)var(--tw-translate-y)}.-translate-y-1\\/2{--tw-translate-y: -50% ;translate:var(--tw-translate-x)var(--tw-translate-y)}.rotate-180{rotate:180deg}.transform{transform:var(--tw-rotate-x,)var(--tw-rotate-y,)var(--tw-rotate-z,)var(--tw-skew-x,)var(--tw-skew-y,)}.animate-pulse{animation:var(--animate-pulse)}.cursor-not-allowed{cursor:not-allowed}.cursor-pointer{cursor:pointer}.resize{resize:both}.resize-none{resize:none}.flex-col{flex-direction:column}.flex-row{flex-direction:row}.items-center{align-items:center}.items-end{align-items:flex-end}.items-start{align-items:flex-start}.items-stretch{align-items:stretch}.justify-between{justify-content:space-between}.justify-center{justify-content:center}.justify-end{justify-content:flex-end}.justify-start{justify-content:flex-start}.gap-0\\.5{gap:calc(var(--spacing)*.5)}.gap-1{gap:calc(var(--spacing)*1)}.gap-1\\.5{gap:calc(var(--spacing)*1.5)}.gap-1\\.25{gap:calc(var(--spacing)*1.25)}.gap-2{gap:calc(var(--spacing)*2)}.gap-2\\.5{gap:calc(var(--spacing)*2.5)}.gap-3{gap:calc(var(--spacing)*3)}.gap-4{gap:calc(var(--spacing)*4)}.gap-5{gap:calc(var(--spacing)*5)}.gap-8{gap:calc(var(--spacing)*8)}.gap-\\[1\\.4375rem\\]{gap:1.4375rem}.self-center{align-self:center}.truncate{text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.overflow-hidden{overflow:hidden}.overflow-x-auto{overflow-x:auto}.overflow-x-hidden{overflow-x:hidden}.overflow-y-auto{overflow-y:auto}.\\!rounded-md{border-radius:var(--radius-md)!important}.rounded{border-radius:.25rem}.rounded-2xl{border-radius:var(--radius-2xl)}.rounded-3xl{border-radius:var(--radius-3xl)}.rounded-\\[6px\\]{border-radius:6px}.rounded-full{border-radius:3.40282e38px}.rounded-lg{border-radius:var(--radius-lg)}.rounded-md{border-radius:var(--radius-md)}.rounded-none{border-radius:0}.rounded-xl{border-radius:var(--radius-xl)}.rounded-t-3xl{border-top-left-radius:var(--radius-3xl);border-top-right-radius:var(--radius-3xl)}.rounded-b-3xl{border-bottom-right-radius:var(--radius-3xl);border-bottom-left-radius:var(--radius-3xl)}.border{border-style:var(--tw-border-style);border-width:1px}.border-2{border-style:var(--tw-border-style);border-width:2px}.border-t{border-top-style:var(--tw-border-style);border-top-width:1px}.border-b{border-bottom-style:var(--tw-border-style);border-bottom-width:1px}.border-l{border-left-style:var(--tw-border-style);border-left-width:1px}.border-none{--tw-border-style:none;border-style:none}.border-blue-200{border-color:var(--color-blue-200)}.border-border-drawer{border-color:var(--color-border-drawer)}.border-gray-600\\/70{border-color:#4a5565b3}@supports (color:color-mix(in lab,red,red)){.border-gray-600\\/70{border-color:color-mix(in oklab,var(--color-gray-600)70%,transparent)}}.border-gray-700{border-color:var(--color-gray-700)}.border-gray-700\\/60{border-color:#36415399}@supports (color:color-mix(in lab,red,red)){.border-gray-700\\/60{border-color:color-mix(in oklab,var(--color-gray-700)60%,transparent)}}.border-green-6{border-color:var(--color-green-6)}.border-neutral-1{border-color:var(--color-neutral-1)}.border-neutral-2{border-color:var(--color-neutral-2)}.border-neutral-700{border-color:var(--color-neutral-700)}.border-primary{border-color:var(--color-primary)}.border-red-9{border-color:var(--color-red-9)}.border-red-10{border-color:var(--color-red-10)}.border-transparent{border-color:#0000}.border-white\\/20{border-color:#fff3}@supports (color:color-mix(in lab,red,red)){.border-white\\/20{border-color:color-mix(in oklab,var(--color-white)20%,transparent)}}.border-white\\/50{border-color:#ffffff80}@supports (color:color-mix(in lab,red,red)){.border-white\\/50{border-color:color-mix(in oklab,var(--color-white)50%,transparent)}}.border-yellow-300{border-color:var(--color-yellow-300)}.\\!bg-background-dialog{background-color:var(--color-background-dialog)!important}.bg-background-dialog{background-color:var(--color-background-dialog)}.bg-black\\/35{background-color:#00000059}@supports (color:color-mix(in lab,red,red)){.bg-black\\/35{background-color:color-mix(in oklab,var(--color-black)35%,transparent)}}.bg-black\\/50{background-color:#00000080}@supports (color:color-mix(in lab,red,red)){.bg-black\\/50{background-color:color-mix(in oklab,var(--color-black)50%,transparent)}}.bg-blue-100{background-color:var(--color-blue-100)}.bg-blue-500{background-color:var(--color-blue-500)}.bg-blue-600{background-color:var(--color-blue-600)}.bg-blue-600\\/20{background-color:#155dfc33}@supports (color:color-mix(in lab,red,red)){.bg-blue-600\\/20{background-color:color-mix(in oklab,var(--color-blue-600)20%,transparent)}}.bg-copy-button-hover{background-color:var(--color-copy-button-hover)}.bg-drawer{background-color:var(--color-drawer)}.bg-gray-200{background-color:var(--color-gray-200)}.bg-gray-600{background-color:var(--color-gray-600)}.bg-gray-900{background-color:var(--color-gray-900)}.bg-green-4{background-color:var(--color-green-4)}.bg-green-5\\/20{background-color:#46a75833}@supports (color:color-mix(in lab,red,red)){.bg-green-5\\/20{background-color:color-mix(in oklab,var(--color-green-5)20%,transparent)}}.bg-list-active{background-color:var(--color-list-active)}.bg-list-active-side-nav{background-color:var(--color-list-active-side-nav)}.bg-list-normal-side-nav{background-color:var(--color-list-normal-side-nav)}.bg-neutral-1{background-color:var(--color-neutral-1)}.bg-neutral-2{background-color:var(--color-neutral-2)}.bg-neutral-3{background-color:var(--color-neutral-3)}.bg-neutral-800{background-color:var(--color-neutral-800)}.bg-neutral-900{background-color:var(--color-neutral-900)}.bg-neutral-900\\/40{background-color:#17171766}@supports (color:color-mix(in lab,red,red)){.bg-neutral-900\\/40{background-color:color-mix(in oklab,var(--color-neutral-900)40%,transparent)}}.bg-primary{background-color:var(--color-primary)}.bg-red-9{background-color:var(--color-red-9)}.bg-red-500\\/20{background-color:#fb2c3633}@supports (color:color-mix(in lab,red,red)){.bg-red-500\\/20{background-color:color-mix(in oklab,var(--color-red-500)20%,transparent)}}.bg-red-900\\/50{background-color:#82181a80}@supports (color:color-mix(in lab,red,red)){.bg-red-900\\/50{background-color:color-mix(in oklab,var(--color-red-900)50%,transparent)}}.bg-semantic-default{background-color:var(--color-semantic-default)}.bg-slate-200{background-color:var(--color-slate-200)}.bg-transparent{background-color:#0000}.bg-white{background-color:var(--color-white)}.bg-white\\/10{background-color:#ffffff1a}@supports (color:color-mix(in lab,red,red)){.bg-white\\/10{background-color:color-mix(in oklab,var(--color-white)10%,transparent)}}.bg-yellow-400{background-color:var(--color-yellow-400)}.bg-yellow-500\\/20{background-color:#edb20033}@supports (color:color-mix(in lab,red,red)){.bg-yellow-500\\/20{background-color:color-mix(in oklab,var(--color-yellow-500)20%,transparent)}}.fill-background-dialog{fill:var(--color-background-dialog)}.fill-current{fill:currentColor}.fill-list-active-side-nav{fill:var(--color-list-active-side-nav)}.fill-none{fill:none}.fill-primary{fill:var(--color-primary)}.fill-white{fill:var(--color-white)}.object-contain{object-fit:contain}.object-cover{object-fit:cover}.\\!p-0{padding:calc(var(--spacing)*0)!important}.p-0{padding:calc(var(--spacing)*0)}.p-0\\.5{padding:calc(var(--spacing)*.5)}.p-1{padding:calc(var(--spacing)*1)}.p-2{padding:calc(var(--spacing)*2)}.p-2\\.5{padding:calc(var(--spacing)*2.5)}.p-4{padding:calc(var(--spacing)*4)}.p-8{padding:calc(var(--spacing)*8)}.px-1{padding-inline:calc(var(--spacing)*1)}.px-2{padding-inline:calc(var(--spacing)*2)}.px-2\\.5{padding-inline:calc(var(--spacing)*2.5)}.px-3{padding-inline:calc(var(--spacing)*3)}.px-3\\.5{padding-inline:calc(var(--spacing)*3.5)}.px-4{padding-inline:calc(var(--spacing)*4)}.px-5{padding-inline:calc(var(--spacing)*5)}.px-6{padding-inline:calc(var(--spacing)*6)}.px-7{padding-inline:calc(var(--spacing)*7)}.px-10{padding-inline:calc(var(--spacing)*10)}.py-0\\.5{padding-block:calc(var(--spacing)*.5)}.py-2{padding-block:calc(var(--spacing)*2)}.py-2\\.5{padding-block:calc(var(--spacing)*2.5)}.py-3{padding-block:calc(var(--spacing)*3)}.py-4{padding-block:calc(var(--spacing)*4)}.py-5{padding-block:calc(var(--spacing)*5)}.py-8{padding-block:calc(var(--spacing)*8)}.\\!pt-12{padding-top:calc(var(--spacing)*12)!important}.pt-1\\.5{padding-top:calc(var(--spacing)*1.5)}.pt-2{padding-top:calc(var(--spacing)*2)}.pt-5{padding-top:calc(var(--spacing)*5)}.pt-10{padding-top:calc(var(--spacing)*10)}.pt-16{padding-top:calc(var(--spacing)*16)}.pt-18{padding-top:calc(var(--spacing)*18)}.pr-2{padding-right:calc(var(--spacing)*2)}.pr-4{padding-right:calc(var(--spacing)*4)}.pr-5{padding-right:calc(var(--spacing)*5)}.pr-9{padding-right:calc(var(--spacing)*9)}.pr-11{padding-right:calc(var(--spacing)*11)}.pb-2\\.5{padding-bottom:calc(var(--spacing)*2.5)}.pb-3{padding-bottom:calc(var(--spacing)*3)}.pb-4{padding-bottom:calc(var(--spacing)*4)}.pb-5{padding-bottom:calc(var(--spacing)*5)}.pb-6{padding-bottom:calc(var(--spacing)*6)}.pb-10{padding-bottom:calc(var(--spacing)*10)}.pl-1\\.5{padding-left:calc(var(--spacing)*1.5)}.pl-2\\.5{padding-left:calc(var(--spacing)*2.5)}.pl-4{padding-left:calc(var(--spacing)*4)}.pl-5{padding-left:calc(var(--spacing)*5)}.pl-9{padding-left:calc(var(--spacing)*9)}.pl-11{padding-left:calc(var(--spacing)*11)}.text-center{text-align:center}.text-left{text-align:left}.align-top{vertical-align:top}.text-base{font-size:var(--text-base);line-height:var(--tw-leading,var(--text-base--line-height))}.text-base\\/7{font-size:var(--text-base);line-height:calc(var(--spacing)*7)}.text-lg{font-size:var(--text-lg);line-height:var(--tw-leading,var(--text-lg--line-height))}.text-lg\\/7{font-size:var(--text-lg);line-height:calc(var(--spacing)*7)}.text-sm{font-size:var(--text-sm);line-height:var(--tw-leading,var(--text-sm--line-height))}.text-sm\\/7{font-size:var(--text-sm);line-height:calc(var(--spacing)*7)}.text-xl{font-size:var(--text-xl);line-height:var(--tw-leading,var(--text-xl--line-height))}.text-xs{font-size:var(--text-xs);line-height:var(--tw-leading,var(--text-xs--line-height))}.text-\\[10px\\]{font-size:10px}.leading-6{--tw-leading:calc(var(--spacing)*6);line-height:calc(var(--spacing)*6)}.leading-\\[1\\.4\\]{--tw-leading:1.4;line-height:1.4}.leading-\\[21px\\]{--tw-leading:21px;line-height:21px}.font-bold{--tw-font-weight:var(--font-weight-bold);font-weight:var(--font-weight-bold)}.font-medium{--tw-font-weight:var(--font-weight-medium);font-weight:var(--font-weight-medium)}.font-normal{--tw-font-weight:var(--font-weight-normal);font-weight:var(--font-weight-normal)}.font-semibold{--tw-font-weight:var(--font-weight-semibold);font-weight:var(--font-weight-semibold)}.tracking-\\[-0\\.08px\\]{--tw-tracking:-.08px;letter-spacing:-.08px}.tracking-\\[0\\.0125rem\\]{--tw-tracking:.0125rem;letter-spacing:.0125rem}.tracking-tighter{--tw-tracking:var(--tracking-tighter);letter-spacing:var(--tracking-tighter)}.break-normal{overflow-wrap:normal;word-break:normal}.break-words{overflow-wrap:break-word}.whitespace-nowrap{white-space:nowrap}.whitespace-pre{white-space:pre}.whitespace-pre-wrap{white-space:pre-wrap}.text-\\[\\#2B3140\\]{color:#2b3140}.text-\\[\\#4A556E\\]{color:#4a556e}.text-amber-500{color:var(--color-amber-500)}.text-black{color:var(--color-black)}.text-blue-300{color:var(--color-blue-300)}.text-blue-500{color:var(--color-blue-500)}.text-blue-600{color:var(--color-blue-600)}.text-gray-500{color:var(--color-gray-500)}.text-green-4{color:var(--color-green-4)}.text-green-600{color:var(--color-green-600)}.text-neutral-1{color:var(--color-neutral-1)}.text-neutral-2{color:var(--color-neutral-2)}.text-primary{color:var(--color-primary)}.text-primary\\/70{color:#266efdb3}@supports (color:color-mix(in lab,red,red)){.text-primary\\/70{color:color-mix(in oklab,var(--color-primary)70%,transparent)}}.text-primary\\/75{color:#266efdbf}@supports (color:color-mix(in lab,red,red)){.text-primary\\/75{color:color-mix(in oklab,var(--color-primary)75%,transparent)}}.text-red-9{color:var(--color-red-9)}.text-red-9\\/70{color:#e5484db3}@supports (color:color-mix(in lab,red,red)){.text-red-9\\/70{color:color-mix(in oklab,var(--color-red-9)70%,transparent)}}.text-red-500{color:var(--color-red-500)}.text-red-600{color:var(--color-red-600)}.text-white{color:var(--color-white)}.text-white\\/50{color:#ffffff80}@supports (color:color-mix(in lab,red,red)){.text-white\\/50{color:color-mix(in oklab,var(--color-white)50%,transparent)}}.text-white\\/70{color:#ffffffb3}@supports (color:color-mix(in lab,red,red)){.text-white\\/70{color:color-mix(in oklab,var(--color-white)70%,transparent)}}.text-white\\/90{color:#ffffffe6}@supports (color:color-mix(in lab,red,red)){.text-white\\/90{color:color-mix(in oklab,var(--color-white)90%,transparent)}}.text-yellow-500{color:var(--color-yellow-500)}.text-yellow-600{color:var(--color-yellow-600)}.lowercase{text-transform:lowercase}.uppercase{text-transform:uppercase}.opacity-0{opacity:0}.opacity-50{opacity:.5}.opacity-100{opacity:1}.shadow{--tw-shadow:0 1px 3px 0 var(--tw-shadow-color,#0000001a),0 1px 2px -1px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.shadow-lg{--tw-shadow:0 10px 15px -3px var(--tw-shadow-color,#0000001a),0 4px 6px -4px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.shadow-xl{--tw-shadow:0 20px 25px -5px var(--tw-shadow-color,#0000001a),0 8px 10px -6px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.outline-0{outline-style:var(--tw-outline-style);outline-width:0}.backdrop-blur-sm{--tw-backdrop-blur:blur(var(--blur-sm));-webkit-backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,);backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,)}.transition-all{transition-property:all;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.transition-colors{transition-property:color,background-color,border-color,outline-color,text-decoration-color,fill,stroke,--tw-gradient-from,--tw-gradient-via,--tw-gradient-to;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.transition-opacity{transition-property:opacity;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.transition-transform{transition-property:transform,translate,scale,rotate;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.delay-1500{transition-delay:1.5s}.delay-3000{transition-delay:3s}.duration-150{--tw-duration:.15s;transition-duration:.15s}.duration-200{--tw-duration:.2s;transition-duration:.2s}.duration-300{--tw-duration:.3s;transition-duration:.3s}.duration-500{--tw-duration:.5s;transition-duration:.5s}.duration-2000{--tw-duration:2s;transition-duration:2s}.ease-in-out{--tw-ease:var(--ease-in-out);transition-timing-function:var(--ease-in-out)}.ease-out{--tw-ease:var(--ease-out);transition-timing-function:var(--ease-out)}.outline-none{--tw-outline-style:none;outline-style:none}.select-none{-webkit-user-select:none;user-select:none}@media (hover:hover){.group-hover\\:block:is(:where(.group):hover *){display:block}.group-hover\\:opacity-100:is(:where(.group):hover *){opacity:1}}.placeholder\\:text-white\\/50::placeholder{color:#ffffff80}@supports (color:color-mix(in lab,red,red)){.placeholder\\:text-white\\/50::placeholder{color:color-mix(in oklab,var(--color-white)50%,transparent)}}.last\\:border-b-0:last-child{border-bottom-style:var(--tw-border-style);border-bottom-width:0}@media (hover:hover){.hover\\:scale-105:hover{--tw-scale-x:105%;--tw-scale-y:105%;--tw-scale-z:105%;scale:var(--tw-scale-x)var(--tw-scale-y)}.hover\\:justify-between:hover{justify-content:space-between}.hover\\:border-neutral-1\\/70:hover{border-color:#888891b3}@supports (color:color-mix(in lab,red,red)){.hover\\:border-neutral-1\\/70:hover{border-color:color-mix(in oklab,var(--color-neutral-1)70%,transparent)}}.hover\\:border-primary:hover{border-color:var(--color-primary)}.hover\\:border-primary\\/70:hover{border-color:#266efdb3}@supports (color:color-mix(in lab,red,red)){.hover\\:border-primary\\/70:hover{border-color:color-mix(in oklab,var(--color-primary)70%,transparent)}}.hover\\:border-red-9:hover{border-color:var(--color-red-9)}.hover\\:border-red-9\\/70:hover{border-color:#e5484db3}@supports (color:color-mix(in lab,red,red)){.hover\\:border-red-9\\/70:hover{border-color:color-mix(in oklab,var(--color-red-9)70%,transparent)}}.hover\\:border-semantic-default:hover{border-color:var(--color-semantic-default)}.hover\\:border-white:hover{border-color:var(--color-white)}.hover\\:bg-black:hover{background-color:var(--color-black)}.hover\\:bg-copy-button-hover:hover{background-color:var(--color-copy-button-hover)}.hover\\:bg-list-active:hover{background-color:var(--color-list-active)}.hover\\:bg-list-active-side-nav:hover{background-color:var(--color-list-active-side-nav)}.hover\\:bg-neutral-2:hover{background-color:var(--color-neutral-2)}.hover\\:bg-neutral-700:hover{background-color:var(--color-neutral-700)}.hover\\:bg-primary\\/70:hover{background-color:#266efdb3}@supports (color:color-mix(in lab,red,red)){.hover\\:bg-primary\\/70:hover{background-color:color-mix(in oklab,var(--color-primary)70%,transparent)}}.hover\\:bg-red-9\\/70:hover{background-color:#e5484db3}@supports (color:color-mix(in lab,red,red)){.hover\\:bg-red-9\\/70:hover{background-color:color-mix(in oklab,var(--color-red-9)70%,transparent)}}.hover\\:bg-white:hover{background-color:var(--color-white)}.hover\\:bg-white\\/20:hover{background-color:#fff3}@supports (color:color-mix(in lab,red,red)){.hover\\:bg-white\\/20:hover{background-color:color-mix(in oklab,var(--color-white)20%,transparent)}}.hover\\:bg-white\\/70:hover{background-color:#ffffffb3}@supports (color:color-mix(in lab,red,red)){.hover\\:bg-white\\/70:hover{background-color:color-mix(in oklab,var(--color-white)70%,transparent)}}.hover\\:bg-white\\/90:hover{background-color:#ffffffe6}@supports (color:color-mix(in lab,red,red)){.hover\\:bg-white\\/90:hover{background-color:color-mix(in oklab,var(--color-white)90%,transparent)}}.hover\\:text-blue-600\\/70:hover{color:#155dfcb3}@supports (color:color-mix(in lab,red,red)){.hover\\:text-blue-600\\/70:hover{color:color-mix(in oklab,var(--color-blue-600)70%,transparent)}}.hover\\:text-semantic-default:hover{color:var(--color-semantic-default)}.hover\\:text-white\\/70:hover{color:#ffffffb3}@supports (color:color-mix(in lab,red,red)){.hover\\:text-white\\/70:hover{color:color-mix(in oklab,var(--color-white)70%,transparent)}}.hover\\:opacity-70:hover{opacity:.7}.hover\\:ring-1:hover{--tw-ring-shadow:var(--tw-ring-inset,)0 0 0 calc(1px + var(--tw-ring-offset-width))var(--tw-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.hover\\:ring-blue-600:hover{--tw-ring-color:var(--color-blue-600)}.hover\\:ring-neutral-1:hover{--tw-ring-color:var(--color-neutral-1)}.hover\\:ring-primary:hover{--tw-ring-color:var(--color-primary)}.hover\\:ring-red-9:hover{--tw-ring-color:var(--color-red-9)}.hover\\:ring-semantic-default:hover{--tw-ring-color:var(--color-semantic-default)}.hover\\:ring-white:hover{--tw-ring-color:var(--color-white)}}.focus\\:border-neutral-1:focus{border-color:var(--color-neutral-1)}.focus\\:border-neutral-1\\/70:focus{border-color:#888891b3}@supports (color:color-mix(in lab,red,red)){.focus\\:border-neutral-1\\/70:focus{border-color:color-mix(in oklab,var(--color-neutral-1)70%,transparent)}}.focus\\:border-primary:focus{border-color:var(--color-primary)}.focus\\:border-primary\\/70:focus{border-color:#266efdb3}@supports (color:color-mix(in lab,red,red)){.focus\\:border-primary\\/70:focus{border-color:color-mix(in oklab,var(--color-primary)70%,transparent)}}.focus\\:border-red-9:focus{border-color:var(--color-red-9)}.focus\\:border-red-9\\/70:focus{border-color:#e5484db3}@supports (color:color-mix(in lab,red,red)){.focus\\:border-red-9\\/70:focus{border-color:color-mix(in oklab,var(--color-red-9)70%,transparent)}}.focus\\:border-semantic-default:focus{border-color:var(--color-semantic-default)}.focus\\:border-white:focus{border-color:var(--color-white)}.focus\\:bg-primary\\/70:focus{background-color:#266efdb3}@supports (color:color-mix(in lab,red,red)){.focus\\:bg-primary\\/70:focus{background-color:color-mix(in oklab,var(--color-primary)70%,transparent)}}.focus\\:bg-red-9\\/70:focus{background-color:#e5484db3}@supports (color:color-mix(in lab,red,red)){.focus\\:bg-red-9\\/70:focus{background-color:color-mix(in oklab,var(--color-red-9)70%,transparent)}}.focus\\:bg-white:focus{background-color:var(--color-white)}.focus\\:bg-white\\/70:focus{background-color:#ffffffb3}@supports (color:color-mix(in lab,red,red)){.focus\\:bg-white\\/70:focus{background-color:color-mix(in oklab,var(--color-white)70%,transparent)}}.focus\\:text-blue-600\\/70:focus{color:#155dfcb3}@supports (color:color-mix(in lab,red,red)){.focus\\:text-blue-600\\/70:focus{color:color-mix(in oklab,var(--color-blue-600)70%,transparent)}}.focus\\:text-primary\\/70:focus{color:#266efdb3}@supports (color:color-mix(in lab,red,red)){.focus\\:text-primary\\/70:focus{color:color-mix(in oklab,var(--color-primary)70%,transparent)}}.focus\\:text-red-9\\/70:focus{color:#e5484db3}@supports (color:color-mix(in lab,red,red)){.focus\\:text-red-9\\/70:focus{color:color-mix(in oklab,var(--color-red-9)70%,transparent)}}.focus\\:text-semantic-default:focus{color:var(--color-semantic-default)}.focus\\:text-white\\/70:focus{color:#ffffffb3}@supports (color:color-mix(in lab,red,red)){.focus\\:text-white\\/70:focus{color:color-mix(in oklab,var(--color-white)70%,transparent)}}.focus\\:opacity-70:focus{opacity:.7}.focus\\:ring-1:focus{--tw-ring-shadow:var(--tw-ring-inset,)0 0 0 calc(1px + var(--tw-ring-offset-width))var(--tw-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.focus\\:ring-2:focus{--tw-ring-shadow:var(--tw-ring-inset,)0 0 0 calc(2px + var(--tw-ring-offset-width))var(--tw-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.focus\\:ring-4:focus{--tw-ring-shadow:var(--tw-ring-inset,)0 0 0 calc(4px + var(--tw-ring-offset-width))var(--tw-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.focus\\:ring-blue-600:focus{--tw-ring-color:var(--color-blue-600)}.focus\\:ring-neutral-1:focus{--tw-ring-color:var(--color-neutral-1)}.focus\\:ring-neutral-1\\/15:focus{--tw-ring-color:#88889126}@supports (color:color-mix(in lab,red,red)){.focus\\:ring-neutral-1\\/15:focus{--tw-ring-color:color-mix(in oklab,var(--color-neutral-1)15%,transparent)}}.focus\\:ring-neutral-500:focus{--tw-ring-color:var(--color-neutral-500)}.focus\\:ring-primary:focus{--tw-ring-color:var(--color-primary)}.focus\\:ring-red-9:focus{--tw-ring-color:var(--color-red-9)}.focus\\:ring-semantic-default:focus{--tw-ring-color:var(--color-semantic-default)}.focus\\:ring-white:focus{--tw-ring-color:var(--color-white)}.focus\\:outline-none:focus{--tw-outline-style:none;outline-style:none}.focus-visible\\:border-neutral-1:focus-visible{border-color:var(--color-neutral-1)}.focus-visible\\:border-neutral-1\\/70:focus-visible{border-color:#888891b3}@supports (color:color-mix(in lab,red,red)){.focus-visible\\:border-neutral-1\\/70:focus-visible{border-color:color-mix(in oklab,var(--color-neutral-1)70%,transparent)}}.focus-visible\\:border-neutral-2:focus-visible{border-color:var(--color-neutral-2)}.focus-visible\\:border-primary:focus-visible{border-color:var(--color-primary)}.focus-visible\\:border-primary\\/70:focus-visible{border-color:#266efdb3}@supports (color:color-mix(in lab,red,red)){.focus-visible\\:border-primary\\/70:focus-visible{border-color:color-mix(in oklab,var(--color-primary)70%,transparent)}}.focus-visible\\:border-red-9:focus-visible{border-color:var(--color-red-9)}.focus-visible\\:border-red-9\\/70:focus-visible{border-color:#e5484db3}@supports (color:color-mix(in lab,red,red)){.focus-visible\\:border-red-9\\/70:focus-visible{border-color:color-mix(in oklab,var(--color-red-9)70%,transparent)}}.focus-visible\\:border-semantic-default:focus-visible{border-color:var(--color-semantic-default)}.focus-visible\\:border-white:focus-visible{border-color:var(--color-white)}.focus-visible\\:bg-neutral-2:focus-visible{background-color:var(--color-neutral-2)}.focus-visible\\:bg-primary\\/70:focus-visible{background-color:#266efdb3}@supports (color:color-mix(in lab,red,red)){.focus-visible\\:bg-primary\\/70:focus-visible{background-color:color-mix(in oklab,var(--color-primary)70%,transparent)}}.focus-visible\\:bg-red-9\\/70:focus-visible{background-color:#e5484db3}@supports (color:color-mix(in lab,red,red)){.focus-visible\\:bg-red-9\\/70:focus-visible{background-color:color-mix(in oklab,var(--color-red-9)70%,transparent)}}.focus-visible\\:bg-white:focus-visible{background-color:var(--color-white)}.focus-visible\\:text-blue-600\\/70:focus-visible{color:#155dfcb3}@supports (color:color-mix(in lab,red,red)){.focus-visible\\:text-blue-600\\/70:focus-visible{color:color-mix(in oklab,var(--color-blue-600)70%,transparent)}}.focus-visible\\:text-primary\\/70:focus-visible{color:#266efdb3}@supports (color:color-mix(in lab,red,red)){.focus-visible\\:text-primary\\/70:focus-visible{color:color-mix(in oklab,var(--color-primary)70%,transparent)}}.focus-visible\\:text-red-9\\/70:focus-visible{color:#e5484db3}@supports (color:color-mix(in lab,red,red)){.focus-visible\\:text-red-9\\/70:focus-visible{color:color-mix(in oklab,var(--color-red-9)70%,transparent)}}.focus-visible\\:text-semantic-default:focus-visible{color:var(--color-semantic-default)}.focus-visible\\:text-white\\/70:focus-visible{color:#ffffffb3}@supports (color:color-mix(in lab,red,red)){.focus-visible\\:text-white\\/70:focus-visible{color:color-mix(in oklab,var(--color-white)70%,transparent)}}.focus-visible\\:opacity-70:focus-visible{opacity:.7}.focus-visible\\:ring-1:focus-visible{--tw-ring-shadow:var(--tw-ring-inset,)0 0 0 calc(1px + var(--tw-ring-offset-width))var(--tw-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.focus-visible\\:ring-2:focus-visible{--tw-ring-shadow:var(--tw-ring-inset,)0 0 0 calc(2px + var(--tw-ring-offset-width))var(--tw-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.focus-visible\\:ring-4:focus-visible{--tw-ring-shadow:var(--tw-ring-inset,)0 0 0 calc(4px + var(--tw-ring-offset-width))var(--tw-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.focus-visible\\:ring-blue-500\\/50:focus-visible{--tw-ring-color:#3080ff80}@supports (color:color-mix(in lab,red,red)){.focus-visible\\:ring-blue-500\\/50:focus-visible{--tw-ring-color:color-mix(in oklab,var(--color-blue-500)50%,transparent)}}.focus-visible\\:ring-blue-600:focus-visible{--tw-ring-color:var(--color-blue-600)}.focus-visible\\:ring-neutral-1:focus-visible{--tw-ring-color:var(--color-neutral-1)}.focus-visible\\:ring-neutral-1\\/15:focus-visible{--tw-ring-color:#88889126}@supports (color:color-mix(in lab,red,red)){.focus-visible\\:ring-neutral-1\\/15:focus-visible{--tw-ring-color:color-mix(in oklab,var(--color-neutral-1)15%,transparent)}}.focus-visible\\:ring-neutral-2:focus-visible{--tw-ring-color:var(--color-neutral-2)}.focus-visible\\:ring-primary:focus-visible{--tw-ring-color:var(--color-primary)}.focus-visible\\:ring-red-9:focus-visible{--tw-ring-color:var(--color-red-9)}.focus-visible\\:ring-red-500:focus-visible{--tw-ring-color:var(--color-red-500)}.focus-visible\\:ring-semantic-default:focus-visible{--tw-ring-color:var(--color-semantic-default)}.focus-visible\\:ring-white:focus-visible{--tw-ring-color:var(--color-white)}.focus-visible\\:ring-white\\/20:focus-visible{--tw-ring-color:#fff3}@supports (color:color-mix(in lab,red,red)){.focus-visible\\:ring-white\\/20:focus-visible{--tw-ring-color:color-mix(in oklab,var(--color-white)20%,transparent)}}.focus-visible\\:outline-none:focus-visible{--tw-outline-style:none;outline-style:none}.active\\:scale-95:active{--tw-scale-x:95%;--tw-scale-y:95%;--tw-scale-z:95%;scale:var(--tw-scale-x)var(--tw-scale-y)}.disabled\\:cursor-not-allowed:disabled{cursor:not-allowed}.disabled\\:opacity-50:disabled{opacity:.5}.data-\\[swipe\\=cancel\\]\\:translate-x-0[data-swipe=cancel]{--tw-translate-x:calc(var(--spacing)*0);translate:var(--tw-translate-x)var(--tw-translate-y)}.data-\\[swipe\\=end\\]\\:translate-x-\\[var\\(--radix-toast-swipe-end-x\\)\\][data-swipe=end]{--tw-translate-x:var(--radix-toast-swipe-end-x);translate:var(--tw-translate-x)var(--tw-translate-y)}.data-\\[swipe\\=move\\]\\:translate-x-\\[var\\(--radix-toast-swipe-move-x\\)\\][data-swipe=move]{--tw-translate-x:var(--radix-toast-swipe-move-x);translate:var(--tw-translate-x)var(--tw-translate-y)}.data-\\[swipe\\=move\\]\\:transition-none[data-swipe=move]{transition-property:none}@media (min-width:48rem){.md\\:max-w-\\[70\\%\\]{max-width:70%}.md\\:max-w-\\[90\\%\\]{max-width:90%}}@media (min-width:64rem){.lg\\:max-w-\\[60\\%\\]{max-width:60%}.lg\\:max-w-\\[85\\%\\]{max-width:85%}.lg\\:pt-4{padding-top:calc(var(--spacing)*4)}}@media (min-width:80rem){.xl\\:max-w-\\[60\\%\\]{max-width:60%}.xl\\:max-w-\\[80\\%\\]{max-width:80%}}@media (min-width:96rem){.\\32xl\\:max-w-\\[50\\%\\]{max-width:50%}.\\32xl\\:max-w-\\[75\\%\\]{max-width:75%}}.\\[\\&_\\*\\]\\:fill-none *{fill:none}.\\[\\&_\\*\\]\\:stroke-white *{stroke:var(--color-white)}.\\[\\&_\\*\\]\\:stroke-white\\/70 *{stroke:#ffffffb3}@supports (color:color-mix(in lab,red,red)){.\\[\\&_\\*\\]\\:stroke-white\\/70 *{stroke:color-mix(in oklab,var(--color-white)70%,transparent)}}.\\[\\&_\\*\\]\\:stroke-\\[1\\.5\\] *{stroke-width:1.5px}.\\[\\&_path\\]\\:fill-none path{fill:none}.\\[\\&_path\\]\\:fill-white path{fill:var(--color-white)}.\\[\\&_path\\]\\:stroke-black path{stroke:var(--color-black)}.\\[\\&_path\\]\\:stroke-none path{stroke:none}.\\[\\&_path\\]\\:stroke-white\\/70 path{stroke:#ffffffb3}@supports (color:color-mix(in lab,red,red)){.\\[\\&_path\\]\\:stroke-white\\/70 path{stroke:color-mix(in oklab,var(--color-white)70%,transparent)}}@media (hover:hover){.hover\\:\\[\\&_path\\]\\:fill-none:hover path{fill:none}.hover\\:\\[\\&_path\\]\\:stroke-white:hover path{stroke:var(--color-white)}}.\\[\\&_svg\\]\\:h-5 svg{height:calc(var(--spacing)*5)}.\\[\\&_svg\\]\\:w-5 svg{width:calc(var(--spacing)*5)}.icon-xxs{width:.75rem;height:.75rem}.icon-xs{width:1rem;height:1rem}.icon-sm{width:1.25rem;height:1.25rem}.icon-md{width:1.5rem;height:1.5rem}.icon-lg{width:2rem;height:2rem}.icon-xl{width:2.5rem;height:2.5rem}}:root[data-theme=light],:host([theme=light]),[data-theme=light]{--color-gray-40:#fff;--color-gray-30:#f3f4f6;--color-gray-20:#e5e7eb;--color-gray-10:#d1d5db;--color-gray-5:#00000080;--color-list-active-side-nav:#fff;--color-list-active:#fff;--color-list-normal-side-nav:#e5e7eb;--color-drawer:#fff;--color-background-dialog:#e5e7eb;--color-neutral-1:#6b7280;--color-neutral-2:#4b5563;--color-neutral-3:#1f2937;--bg-body:#fff;--bg-surface-elevated:#fff;--bg-surface-subtle:#fff;--bg-drawer:#fff;--bg-list-active-side-nav:#fff;--bg-list-active:#fff;--bg-list-normal-side-nav:#e5e7eb;--bg-background-dialog:#e5e7eb;--text-primary:#1c2024;--text-secondary:#4b5563;--text-muted:#00000080;--border-subtle:#0f172a1a;--border-strong:#0f172a33;--color-border-drawer:#0f172a1a;--color-border-side-nav:#0f172a1a}:host([theme=light]) .text-white,:host([theme=light]) [class*=text-white],[data-theme=light] .text-white,[data-theme=light] [class*=text-white],:root[data-theme=light] .text-white,:root[data-theme=light] [class*=text-white]{color:var(--text-primary)!important}:host([theme=light]) [class*="text-white/"],[data-theme=light] [class*="text-white/"],:root[data-theme=light] [class*="text-white/"]{color:var(--text-muted)!important}:host([theme=light]) .fill-white,:host([theme=light]) [class*=fill-white],[data-theme=light] .fill-white,[data-theme=light] [class*=fill-white],:root[data-theme=light] .fill-white,:root[data-theme=light] [class*=fill-white]{fill:var(--text-primary)!important}:host([theme=light]) svg[style*="stroke: white"],:host([theme=light]) svg[style*="stroke:white"],[data-theme=light] svg[style*="stroke: white"],[data-theme=light] svg[style*="stroke:white"],:root[data-theme=light] svg[style*="stroke: white"],:root[data-theme=light] svg[style*="stroke:white"]{stroke:var(--text-primary)!important}:host([theme=light]) ::placeholder,[data-theme=light] ::placeholder,:root[data-theme=light] ::placeholder{color:var(--text-muted)!important;opacity:1!important}:host([theme=light]) ::-webkit-input-placeholder{color:var(--text-muted)!important;opacity:1!important}:host([theme=light]) ::placeholder{color:var(--text-muted)!important;opacity:1!important}:host([theme=light]) :-ms-placeholder-shown{color:var(--text-muted)!important;opacity:1!important}[data-theme=light] ::-webkit-input-placeholder{color:var(--text-muted)!important;opacity:1!important}[data-theme=light] ::placeholder{color:var(--text-muted)!important;opacity:1!important}[data-theme=light] :-ms-placeholder-shown{color:var(--text-muted)!important;opacity:1!important}:root[data-theme=light] ::-webkit-input-placeholder{color:var(--text-muted)!important;opacity:1!important}:root[data-theme=light] ::placeholder{color:var(--text-muted)!important;opacity:1!important}:root[data-theme=light] :-ms-placeholder-shown{color:var(--text-muted)!important;opacity:1!important}:host([theme=light]) [class*="placeholder:text-white"],:host([theme=light]) textarea[class*="placeholder:text-white"]::placeholder,:host([theme=light]) .prompt-textarea::placeholder,[data-theme=light] [class*="placeholder:text-white"],[data-theme=light] textarea[class*="placeholder:text-white"]::placeholder,[data-theme=light] .prompt-textarea::placeholder,:root[data-theme=light] [class*="placeholder:text-white"],:root[data-theme=light] textarea[class*="placeholder:text-white"]::placeholder,:root[data-theme=light] .prompt-textarea::placeholder{--tw-placeholder-opacity:1!important;color:var(--text-muted)!important;opacity:1!important}:host([theme=light]) .prompt-textarea,[data-theme=light] .prompt-textarea,:root[data-theme=light] .prompt-textarea{color:#000!important}:host([theme=light]) .bg-neutral-800,:host([theme=light]) [class*=bg-neutral-800],[data-theme=light] .bg-neutral-800,[data-theme=light] [class*=bg-neutral-800],:root[data-theme=light] .bg-neutral-800,:root[data-theme=light] [class*=bg-neutral-800]{background-color:#e5e7eb!important}:host([theme=light]) button[class*=bg-neutral-2]:not(:hover),:host([theme=light]) [class*=bg-neutral-2]:not(:hover),[data-theme=light] button[class*=bg-neutral-2]:not(:hover),[data-theme=light] [class*=bg-neutral-2]:not(:hover),:root[data-theme=light] button[class*=bg-neutral-2]:not(:hover),:root[data-theme=light] [class*=bg-neutral-2]:not(:hover){background-color:#0000!important}:host([theme=light]) button:hover .bg-neutral-2,:host([theme=light]) [class*="hover:bg-neutral-2"]:hover,[data-theme=light] button:hover .bg-neutral-2,[data-theme=light] [class*="hover:bg-neutral-2"]:hover,:root[data-theme=light] button:hover .bg-neutral-2,:root[data-theme=light] [class*="hover:bg-neutral-2"]:hover{background-color:#0000001a!important}:host([theme=light]) .text-neutral-2,:host([theme=light]) [class*=text-neutral-2],[data-theme=light] .text-neutral-2,[data-theme=light] [class*=text-neutral-2],:root[data-theme=light] .text-neutral-2,:root[data-theme=light] [class*=text-neutral-2]{color:var(--text-secondary)!important}:host([theme=light]) svg.fill-current,[data-theme=light] svg.fill-current,:root[data-theme=light] svg.fill-current{fill:currentColor}:host([theme=light]) .fill-list-active-side-nav,:host([theme=light]) [class*=fill-list-active-side-nav],[data-theme=light] .fill-list-active-side-nav,[data-theme=light] [class*=fill-list-active-side-nav],:root[data-theme=light] .fill-list-active-side-nav,:root[data-theme=light] [class*=fill-list-active-side-nav]{fill:#0b0c10!important}:host([theme=light]) button:hover[class*="hover:bg-neutral-2"],:host([theme=light]) [class*="hover:bg-neutral-2"]:hover,[data-theme=light] button:hover[class*="hover:bg-neutral-2"],[data-theme=light] [class*="hover:bg-neutral-2"]:hover,:root[data-theme=light] button:hover[class*="hover:bg-neutral-2"],:root[data-theme=light] [class*="hover:bg-neutral-2"]:hover,:host([theme=light]) button.text-white:hover,[data-theme=light] button.text-white:hover,:root[data-theme=light] button.text-white:hover{background-color:#0000001a!important}:host([theme=light]) button.text-white svg,:host([theme=light]) button.text-white svg *,[data-theme=light] button.text-white svg,[data-theme=light] button.text-white svg *,:root[data-theme=light] button.text-white svg,:root[data-theme=light] button.text-white svg *{color:var(--text-primary)!important;fill:var(--text-primary)!important;stroke:var(--text-primary)!important}:host([theme=light]) .bg-primary.text-white,:host([theme=light]) .bg-primary[class*=text-white],:host([theme=light]) [class*=bg-primary].text-white,:host([theme=light]) [class*=bg-primary][class*=text-white],[data-theme=light] .bg-primary.text-white,[data-theme=light] .bg-primary[class*=text-white],[data-theme=light] [class*=bg-primary].text-white,[data-theme=light] [class*=bg-primary][class*=text-white],:root[data-theme=light] .bg-primary.text-white,:root[data-theme=light] .bg-primary[class*=text-white],:root[data-theme=light] [class*=bg-primary].text-white,:root[data-theme=light] [class*=bg-primary][class*=text-white],:host([theme=light]) [class*=bg-primary] .text-white,:host([theme=light]) [class*=bg-primary] [class*=text-white],:host([theme=light]) [class*=bg-primary] * .text-white,[data-theme=light] [class*=bg-primary] .text-white,[data-theme=light] [class*=bg-primary] [class*=text-white],[data-theme=light] [class*=bg-primary] * .text-white,:root[data-theme=light] [class*=bg-primary] .text-white,:root[data-theme=light] [class*=bg-primary] [class*=text-white],:root[data-theme=light] [class*=bg-primary] * .text-white,:host([theme=light]) .inline-flex.bg-primary,:host([theme=light]) .inline-flex[class*=bg-primary],[data-theme=light] .inline-flex.bg-primary,[data-theme=light] .inline-flex[class*=bg-primary],:root[data-theme=light] .inline-flex.bg-primary,:root[data-theme=light] .inline-flex[class*=bg-primary],:host([theme=light]) .inline-flex.bg-primary *,:host([theme=light]) .inline-flex[class*=bg-primary] *,[data-theme=light] .inline-flex.bg-primary *,[data-theme=light] .inline-flex[class*=bg-primary] *,:root[data-theme=light] .inline-flex.bg-primary *,:root[data-theme=light] .inline-flex[class*=bg-primary] *{color:#fff!important}:host([theme=light]) .bg-neutral-800[class*=scrollButtonStyle],:host([theme=light]) [class*=scrollButtonStyle].bg-neutral-800,:host([theme=light]) [class*=scrollButtonStyle][class*=bg-neutral-800],:host([theme=light]) button[aria-label*=scroll].bg-neutral-800,:host([theme=light]) button[aria-label*=scroll][class*=bg-neutral-800],:host([theme=light]) button[aria-label*=Scroll].bg-neutral-800,[data-theme=light] .bg-neutral-800[class*=scrollButtonStyle],[data-theme=light] [class*=scrollButtonStyle].bg-neutral-800,[data-theme=light] [class*=scrollButtonStyle][class*=bg-neutral-800],[data-theme=light] button[aria-label*=scroll].bg-neutral-800,[data-theme=light] button[aria-label*=scroll][class*=bg-neutral-800],[data-theme=light] button[aria-label*=Scroll].bg-neutral-800,:root[data-theme=light] .bg-neutral-800[class*=scrollButtonStyle],:root[data-theme=light] [class*=scrollButtonStyle].bg-neutral-800,:root[data-theme=light] [class*=scrollButtonStyle][class*=bg-neutral-800],:root[data-theme=light] button[aria-label*=scroll].bg-neutral-800,:root[data-theme=light] button[aria-label*=scroll][class*=bg-neutral-800],:root[data-theme=light] button[aria-label*=Scroll].bg-neutral-800,:host([theme=light]) [class*=scrollButtonStyle],:host([theme=light]) button[aria-label*=scroll],:host([theme=light]) button[aria-label*=Scroll],[data-theme=light] [class*=scrollButtonStyle],[data-theme=light] button[aria-label*=scroll],[data-theme=light] button[aria-label*=Scroll],:root[data-theme=light] [class*=scrollButtonStyle],:root[data-theme=light] button[aria-label*=scroll],:root[data-theme=light] button[aria-label*=Scroll]{color:var(--text-primary)!important;background-color:#e5e7eb!important;border:1px solid #0000001a!important}:host([theme=light]) [class*=scrollButtonStyle]:hover,:host([theme=light]) button[aria-label*=scroll]:hover,:host([theme=light]) button[aria-label*=Scroll]:hover,[data-theme=light] [class*=scrollButtonStyle]:hover,[data-theme=light] button[aria-label*=scroll]:hover,[data-theme=light] button[aria-label*=Scroll]:hover,:root[data-theme=light] [class*=scrollButtonStyle]:hover,:root[data-theme=light] button[aria-label*=scroll]:hover,:root[data-theme=light] button[aria-label*=Scroll]:hover,:host([theme=light]) [class*=scrollButtonStyle][class*="hover:bg-neutral-700"]:hover,:host([theme=light]) button[aria-label*=scroll][class*="hover:bg-neutral-700"]:hover,[data-theme=light] [class*=scrollButtonStyle][class*="hover:bg-neutral-700"]:hover,[data-theme=light] button[aria-label*=scroll][class*="hover:bg-neutral-700"]:hover,:root[data-theme=light] [class*=scrollButtonStyle][class*="hover:bg-neutral-700"]:hover,:root[data-theme=light] button[aria-label*=scroll][class*="hover:bg-neutral-700"]:hover{background-color:#d1d5db!important}:host([theme=light]) [class*=scrollButtonStyle] svg,:host([theme=light]) [class*=scrollButtonStyle] .text-white,:host([theme=light]) [class*=scrollButtonStyle] [class*=text-white],:host([theme=light]) [class*=scrollButtonStyle] .icon-size-custom.text-white,:host([theme=light]) button[aria-label*=scroll] svg,:host([theme=light]) button[aria-label*=scroll] .text-white,:host([theme=light]) button[aria-label*=scroll] .icon-size-custom.text-white,:host([theme=light]) button[aria-label*=Scroll] svg,:host([theme=light]) button[aria-label*=Scroll] .text-white,:host([theme=light]) button[aria-label*=Scroll] .icon-size-custom.text-white,[data-theme=light] [class*=scrollButtonStyle] svg,[data-theme=light] [class*=scrollButtonStyle] .text-white,[data-theme=light] [class*=scrollButtonStyle] [class*=text-white],[data-theme=light] [class*=scrollButtonStyle] .icon-size-custom.text-white,[data-theme=light] button[aria-label*=scroll] svg,[data-theme=light] button[aria-label*=scroll] .text-white,[data-theme=light] button[aria-label*=scroll] .icon-size-custom.text-white,[data-theme=light] button[aria-label*=Scroll] svg,[data-theme=light] button[aria-label*=Scroll] .text-white,[data-theme=light] button[aria-label*=Scroll] .icon-size-custom.text-white,:root[data-theme=light] [class*=scrollButtonStyle] svg,:root[data-theme=light] [class*=scrollButtonStyle] .text-white,:root[data-theme=light] [class*=scrollButtonStyle] [class*=text-white],:root[data-theme=light] [class*=scrollButtonStyle] .icon-size-custom.text-white,:root[data-theme=light] button[aria-label*=scroll] svg,:root[data-theme=light] button[aria-label*=scroll] .text-white,:root[data-theme=light] button[aria-label*=scroll] .icon-size-custom.text-white,:root[data-theme=light] button[aria-label*=Scroll] svg,:root[data-theme=light] button[aria-label*=Scroll] .text-white,:root[data-theme=light] button[aria-label*=Scroll] .icon-size-custom.text-white{color:var(--text-primary)!important;fill:var(--text-primary)!important;stroke:var(--text-primary)!important}:host([theme=light]) [data-testid=assistant-select-button]:hover,:host([theme=light]) [data-testid=assistant-select-button]:focus,[data-theme=light] [data-testid=assistant-select-button]:hover,[data-theme=light] [data-testid=assistant-select-button]:focus,:root[data-theme=light] [data-testid=assistant-select-button]:hover,:root[data-theme=light] [data-testid=assistant-select-button]:focus{background-color:#0000!important}:host([theme=light]) [data-testid=assistant-select-button],:host([theme=light]) [data-testid=assistant-select-button] *,:host([theme=light]) [data-testid=assistant-select-button] svg,:host([theme=light]) [data-testid=assistant-select-button] [name=arrow-down],:host([theme=light]) [data-testid=assistant-select-button] .transform svg,:host([theme=light]) [data-testid=assistant-select-button] .transform[class*=arrow-down],[data-theme=light] [data-testid=assistant-select-button],[data-theme=light] [data-testid=assistant-select-button] *,[data-theme=light] [data-testid=assistant-select-button] svg,[data-theme=light] [data-testid=assistant-select-button] [name=arrow-down],[data-theme=light] [data-testid=assistant-select-button] .transform svg,[data-theme=light] [data-testid=assistant-select-button] .transform[class*=arrow-down],:root[data-theme=light] [data-testid=assistant-select-button],:root[data-theme=light] [data-testid=assistant-select-button] *,:root[data-theme=light] [data-testid=assistant-select-button] svg,:root[data-theme=light] [data-testid=assistant-select-button] [name=arrow-down],:root[data-theme=light] [data-testid=assistant-select-button] .transform svg,:root[data-theme=light] [data-testid=assistant-select-button] .transform[class*=arrow-down],:host([theme=light]) button[class*=cursor-pointer][class*=text-white] svg,:host([theme=light]) button[class*=cursor-pointer][class*=text-white] [name=arrow-down],[data-theme=light] button[class*=cursor-pointer][class*=text-white] svg,[data-theme=light] button[class*=cursor-pointer][class*=text-white] [name=arrow-down],:root[data-theme=light] button[class*=cursor-pointer][class*=text-white] svg,:root[data-theme=light] button[class*=cursor-pointer][class*=text-white] [name=arrow-down]{color:var(--text-primary)!important;fill:var(--text-primary)!important;stroke:var(--text-primary)!important;opacity:1!important;visibility:visible!important}:host([theme=light]) button[class*=cursor-pointer][class*=text-white]:not([class*=hover]):hover,[data-theme=light] button[class*=cursor-pointer][class*=text-white]:not([class*=hover]):hover,:root[data-theme=light] button[class*=cursor-pointer][class*=text-white]:not([class*=hover]):hover{background-color:#0000!important}:host([theme=light]) .expand-menu-icon,:host([theme=light]) .expand-menu-icon svg,:host([theme=light]) .expand-menu-icon svg *,:host([theme=light]) .expand-menu-icon svg use,:host([theme=light]) .expand-menu-icon svg path,[data-theme=light] .expand-menu-icon,[data-theme=light] .expand-menu-icon svg,[data-theme=light] .expand-menu-icon svg *,[data-theme=light] .expand-menu-icon svg use,[data-theme=light] .expand-menu-icon svg path,:root[data-theme=light] .expand-menu-icon,:root[data-theme=light] .expand-menu-icon svg,:root[data-theme=light] .expand-menu-icon svg *,:root[data-theme=light] .expand-menu-icon svg use,:root[data-theme=light] .expand-menu-icon svg path{stroke:#000!important;fill:#0000!important;color:#000!important}:host([theme=light]) svg symbol#expand-full path,:host([theme=light]) svg symbol#layout-right path,[data-theme=light] svg symbol#expand-full path,[data-theme=light] svg symbol#layout-right path,:root[data-theme=light] svg symbol#expand-full path,:root[data-theme=light] svg symbol#layout-right path{stroke:#000!important;fill:#0000!important}:host([theme=light]) .triple-dots-icon,:host([theme=light]) .triple-dots-icon svg,:host([theme=light]) .triple-dots-icon svg *,:host([theme=light]) .triple-dots-icon svg use,:host([theme=light]) .triple-dots-icon svg path,[data-theme=light] .triple-dots-icon,[data-theme=light] .triple-dots-icon svg,[data-theme=light] .triple-dots-icon svg *,[data-theme=light] .triple-dots-icon svg use,[data-theme=light] .triple-dots-icon svg path,:root[data-theme=light] .triple-dots-icon,:root[data-theme=light] .triple-dots-icon svg,:root[data-theme=light] .triple-dots-icon svg *,:root[data-theme=light] .triple-dots-icon svg use,:root[data-theme=light] .triple-dots-icon svg path{stroke:#000!important;fill:#0000!important;color:#000!important}:host([theme=light]) svg symbol#triple-dots path,[data-theme=light] svg symbol#triple-dots path,:root[data-theme=light] svg symbol#triple-dots path{stroke:#000!important;fill:#0000!important}:host([theme=light]) [class*="hover:bg-list-active-side-nav"]:hover,:host([theme=light]) [data-testid=conversation-highlight]:hover,:host([theme=light]) [class*=containerStyle]:hover,[data-theme=light] [class*="hover:bg-list-active-side-nav"]:hover,[data-theme=light] [data-testid=conversation-highlight]:hover,[data-theme=light] [class*=containerStyle]:hover,:root[data-theme=light] [class*="hover:bg-list-active-side-nav"]:hover,:root[data-theme=light] [data-testid=conversation-highlight]:hover,:root[data-theme=light] [class*=containerStyle]:hover{background-color:#fff!important}:host([theme=light]) [data-testid=assistant-list] [class*="hover:bg-list-active-side-nav"]:hover,[data-theme=light] [data-testid=assistant-list] [class*="hover:bg-list-active-side-nav"]:hover,:root[data-theme=light] [data-testid=assistant-list] [class*="hover:bg-list-active-side-nav"]:hover{background-color:#0000!important}body{background-color:var(--bg-body);color:var(--text-primary)}@keyframes fadeIn{0%{opacity:0;transform:translateY(-40px)}to{opacity:1;transform:translateY(0)}}@keyframes slide-in{0%{transform:translate(-1000px)}to{transform:translate(0)}}@keyframes slide-out{0%{transform:translate(0)}to{transform:translate(-1000px)}}.shadow-toast{box-shadow:0 4px 12px -2px #0003}.animate-slide-in{animation:.5s ease-out forwards slide-in}.animate-slide-out{animation:1s ease-out forwards slide-out}.animate-fadeIn{animation:.3s ease-in-out fadeIn}.drawer-shadow{box-shadow:0 4px 47px #0003}.w-fill-available{width:-webkit-fill-available}.custom-scroll::-webkit-scrollbar{width:6px;height:6px}.custom-scroll::-webkit-scrollbar-track{background:0 0;border-radius:30px}.custom-scroll::-webkit-scrollbar-thumb{background:#ffffff80;border-radius:30px}:host([theme=light]) .custom-scroll::-webkit-scrollbar-thumb{background:#0003}[data-theme=light] .custom-scroll::-webkit-scrollbar-thumb{background:#0003}:root[data-theme=light] .custom-scroll::-webkit-scrollbar-thumb{background:#0003}:host([theme=light]) .loader-spinner,[data-theme=light] .loader-spinner,:root[data-theme=light] .loader-spinner{border-top-color:var(--text-primary)}:host([theme=light]) .loader-dot,[data-theme=light] .loader-dot,:root[data-theme=light] .loader-dot{background-color:#383842!important}:host([theme=light]) [class*=bg-drawer] [class*="hover:bg-list-active"]:hover,[data-theme=light] [class*=bg-drawer] [class*="hover:bg-list-active"]:hover,:root[data-theme=light] [class*=bg-drawer] [class*="hover:bg-list-active"]:hover{background-color:#e5e7eb!important}.custom-scroll::-webkit-scrollbar-horizontal{height:6px}.TEXT-content ol{flex-direction:column;gap:13px;margin-left:16px;list-style-type:decimal;display:flex}@keyframes scale-in{0%{opacity:0;transform:scale(0)}to{opacity:1;transform:scale(1)}}@keyframes scale-out{0%{opacity:1;transform:scale(1)}to{opacity:0;transform:scale(0)}}.animate-scale-in{animation:.3s cubic-bezier(.16,1,.3,1) forwards scale-in}.animate-scale-out{animation:.2s cubic-bezier(.4,0,1,1) forwards scale-out}textarea{transition:height .2s ease-out}.DialogContent{transform-box:fill-viewport;will-change:transform,opacity}.prompt-textarea::placeholder{text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.icon-size-custom{width:var(--icon-size-custom);height:var(--icon-size-custom)}.loader-spinner{box-sizing:border-box;border-top:3px solid #fff;border-right:3px solid #0000;border-radius:50%;width:16px;height:16px;animation:1s linear infinite rotation;display:inline-block}@keyframes rotation{0%{transform:rotate(0)}to{transform:rotate(360deg)}}.assistant-thinking-ring{border:2px solid #0000;border-top-color:var(--color-blue-primary);border-right-color:var(--color-blue-primary);border-bottom-color:#0000;border-left-color:#0000;border-radius:50%;width:calc(100% + 8px);height:calc(100% + 8px);animation:1s linear infinite rotation;position:absolute;top:-4px;left:-4px}.chat-window--floating .dialog-list-container,.chat-window--fixed-right .dialog-list-container{border-left:none!important;border-right:none!important;padding-left:.75rem!important;padding-right:.75rem!important}.chat-window--fullscreen .dialog-list-container{max-width:70%!important}@media (min-width:768px){.chat-window--fullscreen .dialog-list-container{max-width:70%!important}}@media (min-width:1024px){.chat-window--fullscreen .dialog-list-container{max-width:60%!important}}@media (min-width:1280px){.chat-window--fullscreen .dialog-list-container{max-width:60%!important}}@media (min-width:1536px){.chat-window--fullscreen .dialog-list-container{max-width:50%!important}}:host([theme=light]) [class*=bg-neutral-900] th,:host([theme=light]) th[class*=bg-neutral-900],:host([theme=light]) thead[class*=bg-neutral-900] th,[data-theme=light] [class*=bg-neutral-900] th,[data-theme=light] th[class*=bg-neutral-900],[data-theme=light] thead[class*=bg-neutral-900] th,:root[data-theme=light] [class*=bg-neutral-900] th,:root[data-theme=light] th[class*=bg-neutral-900],:root[data-theme=light] thead[class*=bg-neutral-900] th,:host([theme=light]) pre[class*=markdownPreBlock],:host([theme=light]) pre[class*=p-4],:host([theme=light]) pre[class*=bg-gray-900],:host([theme=light]) [class*=markdownPreBlock] pre,:host([theme=light]) [class*=code-block] pre,[data-theme=light] pre[class*=markdownPreBlock],[data-theme=light] pre[class*=p-4],[data-theme=light] pre[class*=bg-gray-900],[data-theme=light] [class*=markdownPreBlock] pre,[data-theme=light] [class*=code-block] pre,:root[data-theme=light] pre[class*=markdownPreBlock],:root[data-theme=light] pre[class*=p-4],:root[data-theme=light] pre[class*=bg-gray-900],:root[data-theme=light] [class*=markdownPreBlock] pre,:root[data-theme=light] [class*=code-block] pre,:host([theme=light]) pre code,:host([theme=light]) pre[class*=bg-gray-900] code,:host([theme=light]) [class*=code-block] pre code,[data-theme=light] pre code,[data-theme=light] pre[class*=bg-gray-900] code,[data-theme=light] [class*=code-block] pre code,:root[data-theme=light] pre code,:root[data-theme=light] pre[class*=bg-gray-900] code,:root[data-theme=light] [class*=code-block] pre code{color:#fff!important}:host([theme=light]) [data-testid=copy-button]:not([data-copied=true]):not(:hover) svg path,[data-theme=light] [data-testid=copy-button]:not([data-copied=true]):not(:hover) svg path,:root[data-theme=light] [data-testid=copy-button]:not([data-copied=true]):not(:hover) svg path{stroke:#000!important;fill:none!important}:host([theme=light]) [data-testid=copy-button]:not([data-copied=true]):hover svg path,[data-theme=light] [data-testid=copy-button]:not([data-copied=true]):hover svg path,:root[data-theme=light] [data-testid=copy-button]:not([data-copied=true]):hover svg path{stroke:#fff!important;fill:none!important}@property --tw-translate-x{syntax:"*";inherits:false;initial-value:0}@property --tw-translate-y{syntax:"*";inherits:false;initial-value:0}@property --tw-translate-z{syntax:"*";inherits:false;initial-value:0}@property --tw-rotate-x{syntax:"*";inherits:false}@property --tw-rotate-y{syntax:"*";inherits:false}@property --tw-rotate-z{syntax:"*";inherits:false}@property --tw-skew-x{syntax:"*";inherits:false}@property --tw-skew-y{syntax:"*";inherits:false}@property --tw-border-style{syntax:"*";inherits:false;initial-value:solid}@property --tw-leading{syntax:"*";inherits:false}@property --tw-font-weight{syntax:"*";inherits:false}@property --tw-tracking{syntax:"*";inherits:false}@property --tw-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-shadow-color{syntax:"*";inherits:false}@property --tw-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-inset-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-inset-shadow-color{syntax:"*";inherits:false}@property --tw-inset-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-ring-color{syntax:"*";inherits:false}@property --tw-ring-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-inset-ring-color{syntax:"*";inherits:false}@property --tw-inset-ring-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-ring-inset{syntax:"*";inherits:false}@property --tw-ring-offset-width{syntax:"<length>";inherits:false;initial-value:0}@property --tw-ring-offset-color{syntax:"*";inherits:false;initial-value:#fff}@property --tw-ring-offset-shadow{syntax:"*";inherits:false;initial-value:0 0 #0000}@property --tw-outline-style{syntax:"*";inherits:false;initial-value:solid}@property --tw-backdrop-blur{syntax:"*";inherits:false}@property --tw-backdrop-brightness{syntax:"*";inherits:false}@property --tw-backdrop-contrast{syntax:"*";inherits:false}@property --tw-backdrop-grayscale{syntax:"*";inherits:false}@property --tw-backdrop-hue-rotate{syntax:"*";inherits:false}@property --tw-backdrop-invert{syntax:"*";inherits:false}@property --tw-backdrop-opacity{syntax:"*";inherits:false}@property --tw-backdrop-saturate{syntax:"*";inherits:false}@property --tw-backdrop-sepia{syntax:"*";inherits:false}@property --tw-duration{syntax:"*";inherits:false}@property --tw-ease{syntax:"*";inherits:false}@property --tw-scale-x{syntax:"*";inherits:false;initial-value:1}@property --tw-scale-y{syntax:"*";inherits:false;initial-value:1}@property --tw-scale-z{syntax:"*";inherits:false;initial-value:1}@keyframes pulse{50%{opacity:.5}}', b8 = "@font-face{font-family:Inter;src:url(" + new URL("fonts/inter/inter-regular.woff2", import.meta.url).href + ') format("woff2"),url(' + new URL("fonts/inter/inter-regular.woff", import.meta.url).href + ') format("woff");font-weight:400;font-style:normal;font-display:swap;font-feature-settings:"kern" 1;font-synthesis:none}@font-face{font-family:Inter;src:url(' + new URL("fonts/inter/inter-medium.woff2", import.meta.url).href + ') format("woff2"),url(' + new URL("fonts/inter/inter-medium.woff", import.meta.url).href + ') format("woff");font-weight:500;font-style:normal;font-display:swap;font-feature-settings:"kern" 1;font-synthesis:none}@font-face{font-family:Inter;src:url(' + new URL("fonts/inter/inter-bold.woff2", import.meta.url).href + ') format("woff2"),url(' + new URL("fonts/inter/inter-bold.woff", import.meta.url).href + ') format("woff");font-weight:700;font-style:normal;font-display:swap;font-feature-settings:"kern" 1;font-synthesis:none}@font-face{font-family:Inter;src:url(' + new URL("fonts/inter/inter-light.woff2", import.meta.url).href + ') format("woff2"),url(' + new URL("fonts/inter/inter-light.woff", import.meta.url).href + ') format("woff");font-weight:300;font-style:normal;font-display:swap;font-feature-settings:"kern" 1;font-synthesis:none}@font-face{font-family:Inter Fallback;font-style:normal;font-weight:400;src:local("Arial");ascent-override:88.98%;descent-override:22.18%;line-gap-override:0%;size-adjust:108.87%}@font-face{font-family:Inter Fallback;font-style:normal;font-weight:500;src:local("Arial");ascent-override:96.27%;descent-override:24%;line-gap-override:0%;size-adjust:100.63%}@font-face{font-family:Inter Fallback;font-style:normal;font-weight:700;src:local("Arial Bold");ascent-override:94.12%;descent-override:23.46%;line-gap-override:0%;size-adjust:102.92%}@font-face{font-family:Inter Fallback;font-style:normal;font-weight:300;src:local("Arial");ascent-override:91.25%;descent-override:22.74%;line-gap-override:0%;size-adjust:106.17%}', w8 = [
  "top-left",
  "top-right",
  "bottom-left",
  "bottom-right"
];
class x8 {
  constructor() {
    wt(this, "defaultPosition", "bottom-right");
  }
  isValidFormat(t) {
    const n = t.trim();
    if (this.isPresetPosition(n.toLowerCase()))
      return !0;
    const r = this.parseCoordinateString(n);
    if (r) {
      const a = !!(r.top || r.bottom), i = !!(r.left || r.right);
      return a && i;
    }
    return !1;
  }
  resolveConfig(t) {
    if (!t)
      return { basePosition: this.defaultPosition };
    const n = t.trim();
    if (!n)
      return { basePosition: this.defaultPosition };
    const r = n.toLowerCase();
    if (this.isPresetPosition(r))
      return { basePosition: r };
    const a = this.parseCoordinateString(n);
    if (a) {
      const i = this.deriveBasePosition(a);
      if (i)
        return { basePosition: i, coordinates: a };
    }
    return console.warn(
      `[pas-assistant-embedded] No foi possvel resolver position: "${n}". Usando padro.`
    ), { basePosition: this.defaultPosition };
  }
  applyCoordinates(t, n) {
    const r = ["top", "right", "bottom", "left"];
    for (const a of r) {
      const i = n == null ? void 0 : n[a];
      i !== void 0 ? t.style.setProperty(a, i, "important") : t.style.removeProperty(a);
    }
  }
  isPresetPosition(t) {
    return t ? w8.includes(t) : !1;
  }
  parseCoordinateString(t) {
    if (!t) return;
    const n = {}, r = /(top|right|bottom|left)\s*[:=]\s*([-+]?\d+(\.\d+)?)(px|%|rem|vh|vw)?/gi;
    let a = r.exec(t);
    for (; a !== null; ) {
      const [, s, l, , c] = a, u = s.toLowerCase(), f = this.normalizeCoordinateValue(l, c, u);
      f && (n[u] = f), a = r.exec(t);
    }
    const i = !!(n.top || n.bottom), o = !!(n.left || n.right);
    if (i && o && Object.keys(n).length > 0)
      return n;
  }
  normalizeCoordinateValue(t, n, r) {
    const a = t.trim();
    if (a) {
      if (n)
        return `${a}${n}`;
      if (/^-?\d+(\.\d+)?$/.test(a)) {
        const i = Number.parseFloat(a);
        return r ? `${this.clampCoordinateValue(i, r)}px` : `${a}px`;
      }
      return a;
    }
  }
  clampCoordinateValue(t, n) {
    if (n === "left" || n === "right")
      return Math.max(0, Math.min(t, 568));
    if (n === "top" || n === "bottom") {
      if (typeof window < "u") {
        const r = window.innerHeight * 85 / 100;
        return Math.max(0, Math.min(t, r));
      }
      return Math.max(0, t);
    }
    return t;
  }
  deriveBasePosition(t) {
    const n = this.resolveAxisDirection("vertical", t), r = this.resolveAxisDirection("horizontal", t);
    if (!(!n || !r))
      return `${n}-${r}`;
  }
  resolveAxisDirection(t, n) {
    const r = (o) => {
      if (!o) return !1;
      const s = Number.parseFloat(o);
      return !Number.isNaN(s) && s > 0;
    };
    if (t === "vertical") {
      const o = r(n.top), s = r(n.bottom);
      return o && !s ? "top" : !o && s ? "bottom" : o && s && n.top && n.bottom ? this.pickClosestEdge("top", n.top, n.bottom) : void 0;
    }
    const a = r(n.right), i = r(n.left);
    if (a && !i) return "right";
    if (!a && i) return "left";
    if (a && i && n.right && n.left)
      return this.pickClosestEdge("right", n.right, n.left);
  }
  pickClosestEdge(t, n, r) {
    const a = t === "top" ? "vertical" : "horizontal", i = Number.parseFloat(n), o = Number.parseFloat(r);
    return Number.isNaN(i) && Number.isNaN(o) ? t : i === 0 && o > 0 ? a === "vertical" ? "bottom" : "left" : o === 0 && i > 0 ? a === "vertical" ? "top" : "right" : Number.isNaN(i) ? a === "vertical" ? "bottom" : "left" : Number.isNaN(o) ? a === "vertical" ? "top" : "right" : a === "vertical" ? i < o ? "bottom" : "top" : i < o ? "left" : "right";
  }
}
class E8 {
  constructor() {
    wt(this, "_apiKey");
    wt(this, "_auth");
    wt(this, "_hostname");
    wt(this, "_userId");
    wt(this, "_loaded", !1);
  }
  loadFromElement(t) {
    const n = t.getAttribute("api-key") ?? t.getAttribute("apikey") ?? t.getAttribute("apiKey");
    n && (this._apiKey = n.trim(), t.removeAttribute("api-key"), t.removeAttribute("apikey"), t.removeAttribute("apiKey"));
    const r = t.getAttribute("auth");
    r && (this._auth = r.trim(), t.removeAttribute("auth"));
    const a = t.getAttribute("hostname");
    a && a.trim() !== "" && (this._hostname = a.trim(), t.removeAttribute("hostname"));
    const i = t.getAttribute("user-id") ?? t.getAttribute("userId");
    i && i.trim() !== "" && (this._userId = i.trim(), t.removeAttribute("user-id"), t.removeAttribute("userId")), this.checkLoaded(t);
  }
  checkLoaded(t) {
    const n = t.hasAttribute("api-key") || t.hasAttribute("apikey") || t.hasAttribute("apiKey"), r = t.hasAttribute("auth"), a = t.hasAttribute("hostname"), i = t.hasAttribute("user-id") || t.hasAttribute("userId");
    !n && !r && !a && !i && (this._loaded = !0);
  }
  handleAttributeChange(t, n, r) {
    return n === "api-key" || n === "apikey" || n === "apiKey" ? r ? (this._apiKey = r.trim(), t.removeAttribute("api-key"), t.removeAttribute("apikey"), t.removeAttribute("apiKey"), this.checkLoaded(t), !0) : !1 : n === "auth" ? r ? (this._auth = r.trim(), t.removeAttribute("auth"), this.checkLoaded(t), !0) : !1 : n === "hostname" ? r && r.trim() !== "" ? (this._hostname = r.trim(), t.removeAttribute("hostname"), this.checkLoaded(t), !0) : !1 : (n === "user-id" || n === "userId") && r && r.trim() !== "" ? (this._userId = r.trim(), t.removeAttribute("user-id"), t.removeAttribute("userId"), this.checkLoaded(t), !0) : !1;
  }
  get apiKey() {
    return this._apiKey;
  }
  set apiKey(t) {
    this._apiKey = t == null ? void 0 : t.trim(), this._loaded = !0;
  }
  get auth() {
    return this._auth;
  }
  set auth(t) {
    this._auth = t == null ? void 0 : t.trim(), this._loaded = !0;
  }
  get hostname() {
    return this._hostname;
  }
  set hostname(t) {
    this._hostname = t == null ? void 0 : t.trim(), this._loaded = !0;
  }
  get userId() {
    return this._userId;
  }
  set userId(t) {
    this._userId = t == null ? void 0 : t.trim(), this._loaded = !0;
  }
  get loaded() {
    return this._loaded;
  }
}
function S8() {
  const e = (r) => {
    try {
      const a = new URL(r, window.location.href), i = a.pathname.replace(/[^/]*$/, "");
      return `${a.origin}${i}`;
    } catch {
      return `${window.location.origin}/`;
    }
  }, t = document.currentScript;
  if (t != null && t.src)
    return e(t.src);
  const n = Array.from(document.scripts).filter(
    (r) => r.src.includes("pas-assistant-embedded")
  );
  return n.length > 0 ? e(n[n.length - 1].src) : `${window.location.origin}/`;
}
class pD extends HTMLElement {
  constructor() {
    super();
    wt(this, "root", null);
    wt(this, "shadowContainer");
    wt(this, "assetBaseUrl");
    wt(this, "positionManager", new x8());
    wt(this, "sensitiveData", new E8());
    wt(this, "positionConfig", {
      basePosition: "bottom-right"
    });
    typeof window < "u" && (window.__PAS_ASSISTANT_EMBEDDED__ = !0), this.shadowContainer = this.attachShadow({ mode: "open" }), this.assetBaseUrl = S8(), this.setupShadowDOM(), this.updatePositionState();
  }
  static get observedAttributes() {
    return [
      "api-key",
      "apikey",
      "apiKey",
      "auth",
      "hostname",
      "user-id",
      "userId",
      "position",
      "language"
    ];
  }
  setupShadowDOM() {
    const n = document.createElement("style");
    n.textContent = `
      :host { 
        position: fixed; 
        z-index: 2147483647; 
        display: block; 
        width: auto; 
        height: auto; 
        --chat-offset: 2rem;
        overflow: visible !important;
        contain: none !important;
        isolation: isolate;
      }
      :host(:not([position])),
      :host([position="bottom-right"]) { bottom: var(--chat-offset); right: var(--chat-offset); }
      :host([position="bottom-left"]) { bottom: var(--chat-offset); left: var(--chat-offset); }
      :host([position="top-right"]) { top: var(--chat-offset); right: var(--chat-offset); }
      :host([position="top-left"]) { top: var(--chat-offset); left: var(--chat-offset); }
      :host {
        /* Default theme is dark */
        --pas-theme: dark;
      }

      :host([theme="light"]) {
        --pas-theme: light;
      }

      :host > * {
        overflow: visible !important;
        contain: none !important;
      }
      [data-radix-popper-content-wrapper] {
        z-index: 2147483647 !important;
        pointer-events: auto !important;
        position: fixed !important;
        visibility: visible !important;
        opacity: 1 !important;
      }
      @keyframes slideIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
      .animate-slideIn { animation: slideIn 0.3s ease-out; }
    `;
    const r = document.createElement("style");
    r.textContent = `${b8}
${y8}`;
    const a = document.createElement("style");
    a.textContent = `
      .custom-scroll::-webkit-scrollbar { width: 6px; height: 6px; }
      .custom-scroll::-webkit-scrollbar-track { background: transparent; border-radius: 30px; }
      .custom-scroll::-webkit-scrollbar-thumb { background: rgba(255, 255, 255, 0.5); border-radius: 30px; }
      .custom-scroll::-webkit-scrollbar-horizontal { height: 6px; }
    `;
    const i = document.createElement("div");
    i.style.display = "none", i.id = "icon-sprite-container";
    const o = `${this.assetBaseUrl}icons.sprite.svg`;
    typeof window < "u" && typeof fetch < "u" && fetch(o).then((c) => c.text()).then((c) => {
      i.innerHTML = c;
    }).catch((c) => {
      console.error("Erro ao carregar sprite SVG:", c);
    }), this.shadowContainer.appendChild(n), this.shadowContainer.appendChild(r), this.shadowContainer.appendChild(a), this.shadowContainer.appendChild(i);
    const s = document.createElement("div");
    s.id = "react-app-root", s.style.overflow = "visible", s.style.contain = "none";
    const l = this.theme ?? "dark";
    s.setAttribute("data-theme", l), this.shadowContainer.appendChild(s), this.root = CM.createRoot(s);
  }
  connectedCallback() {
    this.sensitiveData.loadFromElement(this), this.updatePositionState(), this.renderReact();
  }
  attributeChangedCallback(n, r, a) {
    if (this.sensitiveData.handleAttributeChange(this, n, a)) {
      this.root && this.renderReact();
      return;
    }
    if (n === "position") {
      a && !this.positionManager.isValidFormat(a) && (console.warn(
        `[pas-assistant-embedded] Formato de position invlido: "${a}". Use uma posio predefinida (top-left, top-right, bottom-left, bottom-right) ou coordenadas customizadas (ex: "top:12 left:12").`
      ), this.removeAttribute("position")), this.updatePositionState(), this.root && this.renderReact();
      return;
    }
    if (n === "language") {
      this.root && this.renderReact();
      return;
    }
    if (n === "theme") {
      const i = this.shadowContainer.getElementById("react-app-root");
      i && i.setAttribute("data-theme", this.theme ?? "dark"), this.root && this.renderReact();
      return;
    }
  }
  disconnectedCallback() {
    this.root && (this.root.unmount(), this.root = null);
  }
  get apiKey() {
    return this.sensitiveData.apiKey;
  }
  set apiKey(n) {
    this.sensitiveData.apiKey = n, this.root && this.renderReact();
  }
  get auth() {
    return this.sensitiveData.auth;
  }
  set auth(n) {
    this.sensitiveData.auth = n, this.root && this.renderReact();
  }
  get hostname() {
    return this.sensitiveData.hostname;
  }
  set hostname(n) {
    this.sensitiveData.hostname = n, this.root && this.renderReact();
  }
  get userId() {
    return this.sensitiveData.userId;
  }
  set userId(n) {
    this.sensitiveData.userId = n, this.root && this.renderReact();
  }
  get position() {
    return this.getAttribute("position") ?? void 0;
  }
  set position(n) {
    if (n == null || n.trim() === "") {
      this.removeAttribute("position"), this.updatePositionState();
      return;
    }
    const r = String(n).trim();
    if (!this.positionManager.isValidFormat(r)) {
      console.warn(
        `[pas-assistant-embedded] Formato de position invlido: "${r}". Use uma posio predefinida (top-left, top-right, bottom-left, bottom-right) ou coordenadas customizadas (ex: "top:12 left:12").`
      ), this.removeAttribute("position"), this.updatePositionState();
      return;
    }
    this.setAttribute("position", r), this.updatePositionState();
  }
  get language() {
    const n = this.getAttribute("language");
    if (!n || n.trim() === "")
      return;
    const r = n.trim().toLowerCase();
    if (["pt-br", "en-us", "es-es"].includes(r)) {
      const i = r.split("-");
      if (i.length === 2)
        return `${i[0]}-${i[1].toUpperCase()}`;
    }
  }
  set language(n) {
    if (n == null || n.trim() === "") {
      this.removeAttribute("language"), this.root && this.renderReact();
      return;
    }
    const r = String(n).trim();
    ["pt-BR", "en-US", "es-ES"].includes(r) ? (this.setAttribute("language", r), this.root && this.renderReact()) : (console.warn(
      `[pas-assistant-embedded] Idioma invlido: "${r}". Use 'pt-BR', 'en-US' ou 'es-ES'.`
    ), this.removeAttribute("language"), this.root && this.renderReact());
  }
  /**
   * Theme getter/setter
   * Aceita 'dark' (padro) ou 'light'.
   */
  get theme() {
    const n = this.getAttribute("theme");
    if (!n || n.trim() === "")
      return;
    const r = n.trim().toLowerCase();
    if (["dark", "light"].includes(r))
      return r;
  }
  set theme(n) {
    if (n == null || String(n).trim() === "") {
      this.removeAttribute("theme");
      const i = this.shadowContainer.getElementById("react-app-root");
      i && i.setAttribute("data-theme", "dark"), this.root && this.renderReact();
      return;
    }
    const r = String(n).trim().toLowerCase();
    if (["dark", "light"].includes(r)) {
      this.setAttribute("theme", r);
      const i = this.shadowContainer.getElementById("react-app-root");
      i && i.setAttribute("data-theme", r), this.root && this.renderReact();
    } else {
      console.warn(
        `[pas-assistant-embedded] Tema invlido: "${r}". Use 'dark' ou 'light'.`
      ), this.removeAttribute("theme");
      const i = this.shadowContainer.getElementById("react-app-root");
      i && i.setAttribute("data-theme", "dark"), this.root && this.renderReact();
    }
  }
  renderReact() {
    if (!this.root) return;
    this.sensitiveData.loaded || this.sensitiveData.loadFromElement(this);
    const n = this.sensitiveData.apiKey, r = this.sensitiveData.auth, a = this.sensitiveData.hostname, i = this.sensitiveData.userId, o = this.positionConfig.basePosition, s = !!this.positionConfig.coordinates, l = this.language;
    this.root.render(
      /* @__PURE__ */ N.jsx(
        v8,
        {
          apiKey: n,
          auth: r,
          hostname: a,
          userId: i,
          position: o,
          hasCustomCoordinates: s,
          shadowContainer: this.shadowContainer,
          assetBaseUrl: this.assetBaseUrl,
          language: l
        }
      )
    );
  }
  updatePositionState() {
    const n = this.getAttribute("position");
    this.positionConfig = this.positionManager.resolveConfig(n), this.positionManager.applyCoordinates(this, this.positionConfig.coordinates);
  }
}
wt(pD, "VALID_ATTRIBUTES", /* @__PURE__ */ new Set([
  "api-key",
  "apikey",
  "apiKey",
  "auth",
  "hostname",
  "user-id",
  "userId",
  "position",
  "language",
  "theme"
]));
customElements.get("pas-assistant-embedded") ? console.warn('Web Component "pas-assistant-embedded" j definido.') : customElements.define("pas-assistant-embedded", pD);
export {
  O8 as $,
  F8 as A,
  e_ as B,
  Iq as C,
  lS as D,
  Fq as E,
  lc as F,
  Rb as G,
  U4 as H,
  Fs as I,
  G8 as J,
  S_ as K,
  ab as L,
  xb as M,
  cn as N,
  N8 as O,
  Pq as P,
  qM as Q,
  jq as R,
  YI as S,
  I8 as T,
  k8 as U,
  hq as V,
  pq as W,
  mq as X,
  gq as Y,
  j8 as Z,
  s8 as _,
  JO as a,
  C8 as a0,
  _d as a1,
  qc as a2,
  Rd as a3,
  cD as a4,
  vt as a5,
  H8 as a6,
  sl as a7,
  _8 as a8,
  D8 as a9,
  ou as aa,
  Zm as ab,
  Cc as ac,
  HM as ad,
  Lt as ae,
  rn as af,
  LM as ag,
  Y8 as ah,
  hi as ai,
  fr as aj,
  Wr as ak,
  D6 as al,
  N6 as am,
  Sy as an,
  t8 as ao,
  V8 as ap,
  $8 as aq,
  $4 as ar,
  fi as b,
  xy as c,
  tn as d,
  Qt as e,
  ol as f,
  r8 as g,
  R8 as h,
  Tw as i,
  N as j,
  A8 as k,
  a2 as l,
  _b as m,
  a8 as n,
  o8 as o,
  Q8 as p,
  du as q,
  y as r,
  i8 as s,
  yB as t,
  f8 as u,
  at as v,
  q8 as w,
  B8 as x,
  t_ as y,
  U8 as z
};
